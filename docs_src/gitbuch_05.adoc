// adapted from: "remote.txt"

[[ch.distributed-git]]
= Distributed Git
// Verteiltes Git

include::gitbuch_footnotes.adoc[tag=Chapter_5]


////
Git ist ein _verteiltes_ Versionskontrollsystem.
Um diese Eigenschaft zu verstehen, ist zunächst ein kurzer Exkurs in die Welt der _zentralen_ Versionsverwaltung notwendig: Wie der Name schon sagt, wird bei einem zentralen Versionskontrollsystem, wie z.B. RCS, CVS und Subversion, die Entwicklungsgeschichte zentral auf einem Server in _dem_ Repository abgespeichert, und alle Entwickler synchronisieren ihre Arbeit mit diesem einen Repository.
Entwickler, die etwas verändern möchten, laden sich eine aktuelle Version auf ihren Rechner herunter (_Checkout_), pflegen ihre Modifikationen ein und schicken diese dann wieder an den Server zurück (_Commit_).
////

Git is a _distributed_ version control system.
To understand this feature, a brief digression into the world of centralized version management is necessary: As the name suggests, in a _central_ version control system, such as RCS, CVS, and Subversion, the development history is stored centrally on a repository server, and all developers synchronize their work with _this_ one repository.
Developers who want to change something download a current version to their computer (_checkout_), maintain their modifications, and then send them back to the server (_commit_).



[[sec.distributed-systems]]
== How Does Distributed Version Control Work?
// Wie funktioniert verteilte Versionsverwaltung?

////
Einer der großen Nachteile des zentralen Ansatzes ist, dass für die meisten Arbeitsschritte eine Verbindung zum Server bestehen muss.
Möchten Sie z.B. die Geschichte einsehen oder einen Commit machen, brauchen Sie eine Netzwerkverbindung zum Server.
Leider ist diese nicht immer gewährleistet, vielleicht ist der Server außer Betrieb oder Sie arbeiten gerade auf Ihrem Laptop ohne (W)LAN-Anschluss.
////

One of the major disadvantages of the centralized approach is that a connection to the server is required for most of the work steps.
For example, if you want to view history or make a commit, you need a network connection to the server.
Unfortunately, this is not always guaranteed, maybe the server is down or you are working on your laptop without a (W)LAN connection.


////
Bei verteilten Systemen ist das anders geregelt: Grundsätzlich verfügt hier jeder Entwickler über eine eigene, lokale Kopie des Repositorys -- stellt sich also die Frage, wie Entwickler Veränderungen untereinander austauschen.
////

For distributed systems this is regulated differently: Basically, each developer has his or her own local copy of the repository, so the question arises of how developers share changes.


////
Ein Ansatz ist, ein einzelnes "`Haupt-Repository`"bereitzustellen, das alle Entwickler nutzen, um ihre lokalen Repositories zu synchronisieren.
Die Entwickler verbinden sich also ab und zu mit diesem Repository, laden die eigenen Commits hoch (_Push_) und die der Kollegen herunter (_Fetch_ bzw. _Pull_).
Dieser sehr zentrale Ansatz kommt in der Praxis häufig zum Einsatz.
Eine Darstellung finden Sie in Abbildung 5.1, "Zentraler Workflow mit verteilter Versionsverwaltung".
////

One approach is to provide a single "`master repository`" that all developers use to synchronize their local repositories.
The developers connect to this repository from time to time, uploading their own commits (_push_) and downloading those of their colleagues (_fetch_ or _pull_).
This very centralized approach is often used in practice.
For an illustration, see <<fig.central-workflow>>.


////
Es gibt im Git-Umfeld allerdings zwei nennenswerte Alternativen, die wir in diesem Kapitel vorstellen: den _Integration-Manager_-Workflow, bei dem mehrere öffentliche Repositories zum Einsatz kommen (Abschnitt 5.6, "Verteilter Workflow mit mehreren Remotes"), und den Patch-Austausch per E-Mail (Abschnitt 5.9, "Patches per E-Mail").
////

However, there are two noteworthy alternatives in the Git environment that we will introduce in this chapter: the _Integration Manager_ workflow, which uses multiple public repositories (<<sec.multi-remote>>), and patch exchange by e-mail (<<sec.patch-queue>>).



// @TRANSLATE IMAGE TEXT

// .Zentraler Workflow mit verteilter Versionsverwaltung
.Central workflow with distributed version management
image::central-workflow.svg[id="fig.central-workflow",scaledwidth="70%",width="70%",align="center"]


////
Im Unterschied zu zentralen Systemen erfolgen die Commit- und Checkout-Vorgänge bei Git lokal.
Auch andere alltägliche Aufgaben, wie das Einsehen der Geschichte oder das Wechseln in einen Branch, spielen sich lokal ab.
Einzig das Hoch- und Herunterladen von Commits sind nicht-lokale Vorgänge.
Dadurch ergeben sich im Vergleich zur zentralen Versionsverwaltung zwei wichtige Vorteile: Es wird kein Netzwerk gebraucht, und alles geht (darum) schneller.
Wie häufig Sie Ihr Repository synchronisieren, hängt unter anderem von der Größe und der Entwicklungsgeschwindigkeit des Projekts ab.
Arbeiten Sie gerade mit einem Kollegen an den Interna Ihrer Software, müssen Sie wahrscheinlich häufiger synchronisieren als bei einem Feature, das keine weitreichenden Auswirkungen auf die übrige Codebasis hat.
Es kann durchaus sein, dass einmaliges Synchronisieren pro Tag genügt.
So können Sie auch ohne permanente Netzanbindung produktiv arbeiten.
////

Unlike central systems, Git's commit and checkout processes are local.
Other day-to-day tasks, such as reviewing history or switching to a branch, are also done locally.
Only the uploading and downloading of commits are non-local operations.
This has two important advantages over centralized version management: No network is needed, and everything is faster.
How often you synchronize your repository depends, among other things, on the size and development speed of the project.
If you're working with a colleague on the internals of your software, you'll probably need to synchronize more often than if you're working with a feature that doesn't have a major impact on the rest of the code base.
It may well be that one synchronization per day is sufficient.
So you can work productively even without a permanent network connection.


////
In diesem Kapitel geht es darum, wie Sie Veränderungen zwischen Ihrem lokalen und einem entfernten Repository (_Remote Repository_ oder _Remote_) austauschen, was Sie beachten müssen, wenn Sie mit mehreren Remotes arbeiten, und wie Sie Patches per E-Mail verschicken, so dass sie leicht vom Empfänger einzupflegen sind.
////

This chapter is about how to exchange changes between your local repository and a _remote repository_ (aka _remote_), what to consider when working with multiple remotes, and how to email patches so that they can be easily applied by the recipient.


////
Die wichtigsten Kommandos im Überblick:
////

The most important commands at a glance:




////
`git remote` ::
Allgemeine Konfiguration von Remotes: hinzufügen, entfernen, umbenennen usw.
////

`git remote` ::
General configuration of remotes: add, remove, rename, etc.


////
`git clone` ::
Komplette Kopie herunterladen.
////

`git clone` ::
Download complete copy.


////
`git pull` und `git fetch` ::
Commits und Referenzen aus einem Remote herunterladen.
////

`git pull` and `git fetch` ::
Download commits and references from a remote.


////
`git push` ::
Commits und Referenzen in ein Remote hochladen.
////

`git push` ::
Upload commits and references to a remote.



[[sec.clone]]
== Cloning Repositories
// Repositories klonen

////
Den ersten Befehl in Zusammenhang mit den Remote-Repositories haben Sie bereits kennengelernt: `git clone`.
Hier illustrieren wir den Klonvorgang mit unserem "`Git-Spickzettel`"[65]:
////

You have already seen the first command related to remote repositories: `git clone`.
Here we illustrate the cloning process with our "`git cheat sheet`":{fn65}

[subs="quotes"]
--------
$ *git clone git://github.com/esc/git-cheatsheet-de.git*
Initialized empty Git repository in /tmp/test/git-cheatsheet-de/.git/
remote: Counting objects: 77, done.
remote: Compressing objects: 100% (77/77), done.
remote: Total 77 (delta 45), reused 0 (delta 0)
Receiving objects: 100% (77/77), 132.44 KiB, done.
Resolving deltas: 100% (45/45), done.
--------


////
Bei diesem Aufruf gibt Git diverse Statusmeldungen aus.
Die wichtigsten sind: die Benachrichtigung, in welches Verzeichnis das neue Repository geklont wird (`Initialized empty Git repository in /tmp/test/git-cheatsheet-de/.git/`), sowie die Bestätigung, dass alle Objekte erfolgreich empfangen wurden (`Receiving objects: 100% (77/77), 132.44 KiB, done.`).
Ist der Klonvorgang erfolgreich, wird der `master`-Branch ausgecheckt,[66] und der Working Tree samt Repository befindet sich in dem Verzeichnis `git-cheatsheet-de`.
////

Git will issue various status messages when this call is made.
The most important ones are: the notification of which directory the new repository will be cloned to (`Initialized empty Git repository in /tmp/test/git-cheatsheet-de/.git/`), and the confirmation that all objects have been successfully received ((`Receiving objects: 100% (77/77), 132.44 KiB, done.`)
If the cloning process is successful, the `master` branch is checked out,{fn66} and the working tree including repository is located in the directory `git-cheatsheet-en`.


[subs="quotes"]
--------
$ *cd git-cheatsheet-de*
$ *ls*
cheatsheet.pdf  cheatsheet.tex  Makefile  README
$ *ls -d .&#42;*
.git/
--------


////
Um den Klon in einem anderen Verzeichnis zu erstellen, übergeben Sie es einfach als Argument:
////

To create the clone in a different directory, simply pass it as an argument:


[subs="quotes"]
--------
$ *git clone git://github.com/esc/git-cheatsheet-de.git cheatsheet*
Initialized empty Git repository in /tmp/test/cheatsheet/.git/
$ *ls*
cheatsheet/
--------


////
Außerdem wird das Ursprungsrepository, also die Herkunft des Klons, als Remote-Repository mit dem Namen `origin` konfiguriert.
Das Kommando `git remote` zeigt die Einstellung an:
////

Furthermore, the source repository, i.e. the origin of the clone, is configured as a remote repository named `origin`.
The git remote command displays the setting:


[subs="quotes"]
--------
$ *git remote*
origin
--------



////
Die Einstellung wird in der Konfigurationsdatei `.git/config` mit dem Eintrag `remote` festgehalten, in diesem Fall nur für `origin`:
////

The setting is stored in the configuration file `.git/config` with the entry `remote`, in this case only for `origin`:


--------
[remote "origin"]
    fetch = +refs/heads/*:refs/remotes/origin/*
    url = git://github.com/esc/git-cheatsheet-de.git
--------


////
Sie sehen in dem Ausschnitt zwei Einstellungen: `fetch` und `url`.
Die erste, der sog. _Refspec_, gibt an, welche Veränderungen bei der Synchronisation mit dem Remote-Repository heruntergeladen werden sollen, und die zweite, mit welcher URL dies geschieht.
////

You will see two settings in the section: `fetch` and `url`.
The first, called the _refspec_, specifies which changes are to be downloaded when synchronizing with the remote repository, and the second specifies the URL used to do this.


////
Außerdem dient `git remote` zum Verwalten von Remote-Repositories.
Sie können z.B. mit `git remote add` weitere Remote-Repositories hinzufügen, über `git remote set-url` die URL für das Remote-Repository anpassen usw., doch dazu später mehr.
////

`git remote` is also used to manage remote repositories.
For example, you can add more remote repositories using `git remote add`, adapt the URL for the remote repository using `git remote set-url`, and so on, but more on this later.



////
Der Name `origin` ist nur eine Konvention; mit `git remote rename` passen Sie den Namen des Ursprungsrepositorys Ihren Wünschen entsprechend an, z.B. von `origin` zu `github`:
////

The name `origin` is just a convention; with `git remote rename` you can change the name of the source repository to suit your needs, for example, from `origin` to `github`:


[subs="quotes"]
--------
$ *git remote rename origin github*
$ *git remote*
github
--------


////
Mit der Option `--origin` bzw. `-o` setzen Sie den Namen gleich beim Klonen:
////

With the option `--origin` or `-o` you set the name immediately when cloning:


[subs="quotes"]
--------
$ *git clone -o github git://github.com/esc/git-cheatsheet-de.git*
--------



[[sec.repository-url]]
=== Repository URLs

////
Git unterstützt mehrere Protokolle, um auf ein Remote-Repository zuzugreifen, die gängigsten drei sind das Git-Protokoll, SSH und HTTP(S).
Das Git-Protokoll wurde speziell für Git entwickelt und begünstigt die Datenübertragung, da immer die kleinstmögliche Datenmenge übertragen wird.
Es unterstützt keine Authentifizierung und wird daher häufig in einer SSH-Verbindung übertragen.
Dadurch wird sowohl eine effiziente (Git-Protokoll) als auch sichere (SSH) Übertragung gewährleistet.
HTTP(S) kommt dann zum Einsatz, wenn eine Firewall sehr restriktiv konfiguriert ist und die zugelassenen Ports drastisch eingeschränkt sind.[67]
////

Git supports several protocols for accessing a remote repository, the most common three being Git protocol, SSH, and HTTP(S).
Designed specifically for Git, the Git protocol favors data transfer by always transferring the smallest possible amount of data.
It doesn't support authentication, so it's often transmitted over an SSH connection.
This ensures both efficient (Git protocol) and secure (SSH) transmission.
HTTP(S) is used when a firewall is configured very restrictively and the allowed ports are drastically restricted.{fn67}


////
Im Allgemeinen enthält eine valide URL das Übertragungsprotokoll, die Adresse des Servers sowie den Pfad zu dem Repository:[68]
////

In general, a valid URL contains the transfer protocol, the address of the server and the path to the repository:{fn68}



* `ssh://[user@]gitbu.ch[:port]/pfad/zum/repo.git/`
* `git://gitbu.ch[:port]/pfad/zum/repo.git/`
* `http[s]://gitbu.ch[:port]/pfad/zum/repo.git/`


////
Für das SSH-Protokoll existiert noch die Kurzform:
////

For the SSH protocol the short form still exists:

* `[user@]gitbu.ch:pfad/zum/repo.git/`


////
Außerdem ist es möglich, lokale Repositories mit der folgenden Syntax zu klonen:
////

It is also possible to clone repositories locally using the following syntax:


* `/pfad/zum/repo.git/`
* `+file:///pfad/zum/repo.git/+`


////
Wenn Sie wissen wollen, welche URLs für ein Remote-Repository konfiguriert sind, verwenden Sie die Option `--verbose` bzw. `-v` von `git remote`:
////

If you want to know what URLs are configured for a remote repository, use git remote's `--verbose` or `-v` option:


[subs="quotes"]
--------------------
$ *git remote -v*
origin  git://github.com/esc/git-cheatsheet-de.git (fetch)
origin  git://github.com/esc/git-cheatsheet-de.git (push)
--------------------


////
Sie sehen, dass es zwei URLs für das Remote-Repository `origin` gibt, die aber standardmäßig auf denselben Wert gesetzt sind.
Die erste URL (`fetch`) gibt an, von wo und mit welchem Protokoll Veränderungen heruntergeladen werden.
Die zweite URL (`push`) gibt an, wohin und mit welchem Protokoll Veränderungen hochgeladen werden.
Unterschiedliche URLs sind vor allem dann interessant, wenn Sie mit verschiedenen Protokollen herunter- bzw.  hochladen.
Ein gängiges Beispiel ist, mit dem Git-Protokoll (`git://`) herunterzuladen und mit dem SSH-Protokoll (`ssh://`) hoch.
Es wird dann ohne Authentifizierung und Verschlüsselung heruntergeladen, was einen Geschwindigkeitsvorteil bietet, aber mit Authentifizierung und Verschlüsselung hochgeladen, was sicherstellt, dass nur Sie oder andere zugriffsberechtigte Personen hochladen können.
Mit dem Kommando `git remote set-url` passen Sie die URLs an:
////

You can see that there are two URLs for the remote repository origin, but they are set to the same value by default.
The first URL (`fetch`) specifies from where and with which protocol changes are downloaded.
The second URL (`push`) specifies where changes are uploaded to and with which protocol.
Different URLs are particularly interesting if you download or upload with different protocols.
A common example is to download with the git protocol (`git://`) and upload with the SSH protocol (`ssh://`).
It is then downloaded without authentication and encryption, which provides a speed advantage, but uploaded with authentication and encryption, which ensures that only you or other authorized people can upload.
You can use the `git remote set-url` command to customize the URLs:


[subs="quotes"]
--------------------
$ *git remote set-url --add \*
  *--push origin pass:quotes[git@github.com]:esc/git-cheatsheet-de.git*
$ *git remote -v*
origin  git://github.com/esc/git-cheatsheet-de.git (fetch)
origin  git@github.com:esc/git-cheatsheet-de.git (push)
--------------------


[TIP]
==================================
////
Falls Sie die URL eines Repositorys anpassen wollen, ist es häufig schneller, dies direkt in der Konfigurationsdatei `.git/config` zu tun.
Git stellt dafür das Kommando `git config -e` bereit: es öffnet diese Datei in Ihrem Editor.
////

If you want to customize the URL of a repository, it is often faster to do this directly in the `.git/config` configuration file.
Git provides the `git config -e` command for this: it opens this file in your editor.
==================================





[[sec.remote-tracking-branches]]
=== Remote-Tracking-Branches

////
Der aktuelle Zustand des Remote-Repositorys wird lokal gespeichert.
Git verwendet dazu den Mechanismus der _Remote-Tracking-Branches_, spezielle Branches -- also lokale Referenzen -- , die den Zustand der Branches im Remote, sog. _Remote-Branches_, widerspiegeln.
Sie "`verfolgen`"also die Remote-Branches und werden bei einer Synchronisation mit dem Remote entsprechend von Git vorgerückt bzw.  gesetzt, sofern sich die Branches in dem Remote verändert haben.
Im Hinblick auf den Commit-Graphen sind Remote-Tracking-Branches Markierungen innerhalb des Graphen, die auf die gleichen Commits zeigen wie die Branches im Remote-Repository.
Sie können Remote-Tracking-Branches nicht wie normale Branches verändern, Git verwaltet sie automatisch, sorgt also für deren Aktualisierung.
Wenn Sie ein Repository klonen, initialisiert Git für jeden Remote-Branch einen Remote-Tracking-Branch.
////

The current status of the remote repository is stored locally.
Git uses the mechanism of _remote tracking branches_, special branches -- local references -- that reflect the state of the remote branches.
They "`track`" the remote branches and are advanced or set by Git when synchronizing with the remote, if the branches in the remote have changed.
In terms of the commit graph, remote tracking branches are markers within the graph that point to the same commits as the branches in the remote repository.
You can't modify remote tracking branches like normal branches; Git manages them automatically, so it updates them.
When you clone a repository, Git initializes a remote tracking branch for each remote branch.

// .Erzeugte Remote-Tracking-Branches
.Generated Remote Tracking Branches
image::clone.svg[id="fig.clone",scaledwidth="100%",width="100%",align="center"]


////
In Abbildung 5.2, "Erzeugte Remote-Tracking-Branches" sehen Sie ein Beispiel.
Das Remote-Repository `origin` hat drei Branches: `pu`, `maint` und `master`.
Git erstellt in dem geklonten Repository für jeden dieser _Remote-Branches_ einen _Remote-Tracking-Branch_.
Außerdem wird in dem Klon ein lokaler Branch `master` erstellt, der dem Remote-Branch `master` entspricht.
Dieser wird ausgecheckt und ist der Branch, in dem Sie arbeiten sollten, wenn Sie vorhaben, Commits in den `master` hochzuladen (siehe aber auch Abschnitt 5.3.1, "git fetch").
////

<<fig.clone>> shows an example.
The `origin` remote repository has three branches: `pu`, `maint`, and `master`.
Git creates a _remote tracking branch_ in the cloned repository for each of these _remote branches_.
It also creates a local branch `master` in the clone that corresponds to the remote branch `master`.
This is checked out and is the branch you should work in if you plan to upload commits to the `master` (but see <<sec.git-fetch>>).


////
In dem Beispiel mit dem Git-Spickzettel gibt es auf der Remote-Seite nur einen einzigen Branch, nämlich `master`.
Darum erzeugt Git in dem Klon auch nur einen Remote-Tracking-Branch, und zwar `origin/master`.
Der Befehl `git branch -r` zeigt alle Remote-Tracking-Branches an:
////

In the git fetch example, there is only one branch on the remote side, master.
That's why Git creates only one remote tracking branch in the clone, `origin/master`.
The `git branch -r` command shows all remote tracking branches:



[subs="quotes"]
-------------------
$ *git branch -r*
  origin/HEAD -&gt; origin/master
  origin/master
-------------------


////
Der Sondereintrag `origin/HEAD -> origin/master` besagt, dass in dem Remote-Repository der `HEAD` auf den Branch `master` zeigt.
Das ist für das Klonen insofern wichtig, als dieser Branch nach dem Klonen ausgecheckt wird.
Die Liste der Remote-Tracking-Branches ist in dem Beispiel etwas spärlich, mehr Einträge sehen Sie in einem Klon des Git-via-Git Repositorys:
////

The special entry `origin/HEAD -> origin/master` states that in the remote repository the `HEAD` points to the branch `master`.
This is important for cloning, because this branch is checked out after cloning.
The list of remote tracking branches is a bit sparse in this example, you can see more entries in a clone of the Git-via-Git repository:


[subs="quotes"]
-----------------------
$ *git branch -r*
  origin/HEAD -&gt; origin/master
  origin/html
  origin/maint
  origin/man
  origin/master
  origin/next
  origin/pu
  origin/todo
-----------------------


////
Alle Branches lassen Sie sich mit `git branch -a` anzeigen:
////

All branches can be displayed with `git branch -a`:


[subs="quotes"]
-------------------------
$ *git branch -a*
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
-------------------------


////
In diesem Fall verwendet Git das Präfix `remotes/`, um Remote-Tracking-Branches eindeutig von den normalen zu unterscheiden.
Haben Sie die Farbausgabe aktiviert, werden die unterschiedlichen Branches zudem farblich kodiert: der ausgecheckte Branch grün, Remote-Tracking-Branches rot.
////

In this case, Git uses the prefix `remotes/` to clearly distinguish remote tracking branches from normal ones.
If you have enabled color output, the different branches will also be color-coded: the checked-out branch green, remote tracking branches red.


////
Remote-Tracking-Branches sind auch nur Referenzen und werden daher wie alle Referenzen unter `.git/refs` gespeichert.
Da es sich aber um besondere Referenzen handelt, die zudem noch mit einem Remote-Repository verknüpft sind, landen sie unter `.git/refs/remotes/<remote-name>` (siehe auch Abschnitt 3.1.1, "HEAD und andere symbolische Referenzen").
In Gitk werden die Remote-Tracking-Branches mit dem Präfix `remotes/<remote-name>/` angezeigt, das zudem dunkelgelb gefärbt ist (Abbildung 5.3, "Branch next und der entsprechende Remote-Tracking-Branch in Gitk").

////
Remote Tracking Branches are also references only and are therefore stored under `.git/refs` like all references.
However, since they are special references that are also linked to a remote repository, they end up under `.git/refs/remotes/<remote-name>` (see <<sec.branch-refs>>).
In Gitk, the remote tracking branches are displayed with the prefix `remotes/<remote-name>/`, which is also colored dark yellow (<<fig.remote-tracking-gitk>>).


// .Branch `next` und der entsprechende Remote-Tracking-Branch in Gitk
.Branch `next` and the corresponding remote tracking branch in Gitk
image::remote-tracking-gitk.png[id="fig.remote-tracking-gitk",scaledwidth="90%",width="90%",align="center"]





[[sec.downloading-commits]]
== Downloading Commits
// Commits herunterladen

////
Was bedeutet es nun, wenn Sie zwei Repositories synchronisieren, etwa einen Klon mit dem Ursprung?
Synchronisation bedeutet in diesem Kontext zweierlei: erstens das Herunterladen von Commits und Referenzen, zweitens das Hochladen.
Im Hinblick auf den Commit-Graphen muss der lokale Graph mit dem auf der Remote-Seite synchronisiert werden, damit beide dieselbe Struktur haben.
In diesem Abschnitt behandeln wir zunächst, wie Sie Commits und Referenzen aus einem Remote herunterladen.
Dafür gibt es zwei Kommandos: `git fetch` und `git pull`.
Wir stellen zuerst beide Kommandos vor und beschreiben in Abschnitt 5.3.3, "git fetch vs. git pull", welches Kommando unter welchen Umständen zu bevorzugen ist.
////

Now what does it mean when you synchronize two repositories, such as a clone with the source?
Synchronization in this context means two things: first, downloading commits and references, and second, uploading.
As far as the commit graph is concerned, the local graph needs to be synchronized with the one on the remote side, so that both have the same structure.
In this section, we first discuss how to download commits and references from a remote.
There are two commands for this: `git fetch` and `git pull`.
We'll first introduce both commands, and in <<sec.fetch-vs-pull>> we'll describe which command is preferable under which circumstances.



// @NOTE: Should we leave this title lowercase, since it's a Git command?
[[sec.git-fetch]]
=== git fetch

////
Sobald in einem Remote neue Commits von anderen Entwicklern angelegt wurden, wollen Sie diese in Ihr lokales Repository herunterladen.
Im einfachsten Fall wollen Sie nur herausfinden, welche Commits Sie lokal noch nicht haben, diese herunterladen und die Remote-Tracking-Branches auf den neuesten Stand bringen, so dass sie den aktuellen Zustand im Remote widerspiegeln.
////

As soon as new commits are created by other developers in a remote, you want to download them to your local repository.
In the simplest case, you just want to find out which commits you don't have locally, download them, and update the remote tracking branches so that they reflect the current status in the remote.


////
Verwenden Sie dazu das Kommando `git fetch`:
////

Use the `git fetch` command to do this:


[subs="quotes"]
--------
$ *git fetch origin*
...
From github.com:esc/git-cheatsheet-de
   79170e8..003e3c7  master     -&gt; origin/master
--------


////
Git quittiert den Aufruf mit einer Meldung, dass `origin/master` von dem Commit `79170e8` auf den Commit `003e3c7` gesetzt wurde.
Die Notation `master -> origin/master` besagt, dass der Branch `master` aus dem Remote verwendet wurde, um den Remote-Tracking-Branch `origin/master` zu aktualisieren.
Sprich: Branches aus dem Remote auf der linken Seite und Remote-Tracking-Branches auf der rechten.
////

Git acknowledges the call with a message that `origin/master` has been set from commit `79170e8` to commit `003e3c7`.
The notation `master -> origin/master` indicates that the branch `master` from the remote was used to update the remote tracking branch `origin/master`.
In other words: Branches from the remote on the left and remote tracking branches on the right.


////
Welche Auswirkung das auf den Commit-Graphen hat, sehen Sie Abbildung 5.4, "Remote-Tracking-Branches werden aktualisiert": Auf der linken Seite ist der Ausgangszustand des Remote `origin` und daneben der des Klons dargestellt.
Sowohl im Remote als auch im Klon sind seit der letzten Synchronisation neue Commits hinzugekommen (C und D).
Der Remote-Tracking-Branch `origin/master` im Klon zeigt auf Commit B; dies ist der letzte Zustand des Remotes, der dem Klon bekannt ist.
Durch einen Aufruf von `git fetch origin` aktualisiert Git den Remote-Tracking-Branch im Klon, damit dieser den aktuellen Zustand des `master` (zeigt auf Commit C) im Remote widerspiegelt.
Dazu lädt Git den fehlenden Commit C herunter und setzt anschließend den Remote-Tracking-Branch darauf.
////

See <<fig.fetch>> for the effect this has on the commit graph: On the left side is the initial state of the remote origin and next to it that of the clone.
Both the remote and the clone have new commits since the last synchronization (C and D).
The remote tracking branch `origin/master` in the clone points to commit B; this is the last state of the remote known to the clone.
By calling `git fetch origin`, Git updates the remote tracking branch in the clone to reflect the current status of the `master` (pointing to commit C) in the remote.
To do this, Git downloads the missing commit C and then sets the remote tracking branch on it.


// .Remote-Tracking-Branches werden aktualisiert
.Remote Tracking Branches are updated
image::fetch.svg[id="fig.fetch",scaledwidth="100%",width="100%",align="center"]



[[sec.refspec]]
==== Refspec

////
Der _Refspec_ (_Reference Specification_) sorgt dafür, dass die Remote-Tracking-Branches gesetzt werden.
Dies ist eine Beschreibung der Referenzen, die aus dem Remote geholt werden sollen.
Ein Beispiel gab es schon weiter oben:
////

The _refspec_ (_reference specification_) ensures that the remote tracking branches are set.
This is a description of the references to be retrieved from the remote.
An example was given above:


--------
[remote "origin"]
    fetch = +refs/heads/*:refs/remotes/origin/*
    url = git://github.com/esc/git-cheatsheet-de.git
--------


////
In dem Eintrag `fetch` wird der Refspec für das Remote gespeichert.
Er hat die Form: `<remote-refs>:<lokale-refs>` mit einem optionalen Plus (+).
Das Beispiel ist so konfiguriert, dass alle Branches, also alle Referenzen, die im Remote unter `refs/heads` gespeichert sind, lokal unter `refs/remotes/origin` landen.[69]
Somit wird z.B. der Branch `master` aus dem Remote `origin` (`refs/heads/master`) lokal als `refs/remotes/origin/master` gespeichert.
////

In the entry `fetch` the refspec for the remote is stored.
It has the form: `<remote-refs>:<local-refs>` with an optional plus (+).
The example is configured so that all branches, i.e. all references stored in the remote under `refs/heads`, end up locally under `refs/remotes/origin`.{fn69}
Thus, for example, the branch `master` from the remote `origin` (`refs/heads/master`) is stored locally as `refs/remotes/origin/master`.


////
Im Normalfall werden die Remote-Tracking-Branches, ähnlich wie bei einem Fast-Forward-Merge, "`vorgespult`".
Der Remote-Tracking-Branch wird also nur aktualisiert, wenn der Ziel-Commit ein Nachfahre der aktuellen Referenz ist.
Es kann vorkommen, dass dies nicht möglich ist, z.B. nach einem Rebase.
In dem Fall verweigert Git, den Remote-Tracking-Branch zu aktualisieren.
Das Plus setzt jedoch dieses Verhalten außer Kraft, und der Remote-Tracking-Branch wird trotzdem aktualisiert.
Sollte das vorkommen, weist Git mit dem Zusatz `(forced update)` darauf hin:
////

Normally the remote tracking branches are "`fast-forwarded`", similar to a fast-forward merge.
The remote tracking branch is therefore only updated if the target commit is a descendant of the current reference.
This may not be possible, for example, after a rebase.
In this case, Git will refuse to update the remote tracking branch.
However, the plus overrides this behavior, and the remote tracking branch is still updated.
If this happens, Git will indicate this with the addition `(forced update)`:


--------
 + f5225b8..0efec48 pu         -> origin/pu  (forced update)
--------



////
Diese Einstellung ist in der Praxis sinnvoll und wird daher standardmäßig gesetzt.
Außerdem müssen Sie sich als Benutzer nicht darum kümmern, den Refspec zu setzen, denn wenn Sie das Kommando `git clone` oder `git remote add` verwenden, erstellt Ihnen Git automatisch den entsprechenden Default-Eintrag.
Manchmal wollen Sie den Refspec explizit einschränken.
Wenn Sie z.B. Namespaces für alle Entwickler verwenden und Sie nur an dem `master`-Branch sowie an den Branches der anderen Entwickler in Ihrem Team (Beatrice und Carlos) interessiert sind, könnte das so aussehen:
////

This setting is useful in practice and is therefore set by default.
Furthermore, as a user you do not need to worry about setting the refspec, because if you use the command `git clone` or `git remote add`, Git automatically creates the corresponding default entry for you.
Sometimes you may want to restrict the refspec explicitly.
For example, if you use namespaces for all developers and you are only interested in the `master` branch and the branches of the other developers in your team (Beatrice and Carlos), it might look like this:


--------
[remote "firma"]
    url = axel@example.com:produkt.git
    fetch = +refs/heads/master:refs/remotes/origin/master
    fetch = +refs/heads/beatrice/*:refs/remotes/origin/beatrice/*
    fetch = +refs/heads/carlos/*:refs/remotes/origin/carlos/*
--------

////
Im Hinblick auf den Commit-Graphen ist es so, dass Git nur die Commits herunterlädt, die notwendig sind, um Referenzen in dem Commit-Graphen zu erreichen.
Das ist sinnvoll, weil Commits, die nicht durch eine Referenz "`gesichert`" sind, als unerreichbar gelten, und letztlich irgendwann gelöscht werden (siehe auch Abschnitt 3.1.2, "Branches verwalten").
In dem letzten Beispiel ist es deshalb für Git nicht notwendig, Commits herunterzuladen, die durch die Branches referenziert werden, die nicht im Refspec stehen.
Im Sinne der Verteiltheit muss Git also nicht zwingend den gesamten Commit-Graphen synchronisieren, es reichen die "`relevanten`"Teile.
////

With regard to the commit graph, Git only downloads those commits that are necessary to get references in the commit graph.
This makes sense, because commits that are not "`secured`" by a reference are considered unreachable, and will eventually be deleted (see also <<sec.branch-management>>).
In the last example, Git therefore does not need to download commits that are referenced by the branches that are not in the refspec.
In terms of distribution, Git does not necessarily need to synchronize the entire commit graph, the "`relevant`" parts are sufficient.


////
Sie können alternativ auch den Refspec auf der Kommandozeile angeben:
////

Alternatively, you can specify the refspec on the command line:



[subs="quotes"]
--------
$ *git fetch origin +refs/heads/master:refs/remotes/origin/master*
--------

////
Sollte ein Refspec vorliegen, der keine Referenz auf der rechten Seite des Doppelpunkts hat, liegt kein Ziel zum Speichern vor.
In dem Fall legt Git die Referenz stattdessen in der Datei `.git/FETCH_HEAD` ab, und Sie können den Spezialbegriff `FETCH_HEAD` für einen Merge verwenden:
////

If there is a refspec that has no reference on the right side of the colon, there is no target to store.
In this case, Git places the reference in the `.git/FETCH_HEAD` file instead, and you can use the special term `FETCH_HEAD` for a merge:


[subs="quotes"]
--------
$ *git fetch origin master*
From github.com:esc/git-cheatsheet-de
 * branch            master     -&gt; FETCH_HEAD
$ *cat .git/FETCH_HEAD*
003e3c70ce7310f6d6836748f45284383480d40e
    branch 'master' of github.com:esc/git-cheatsheet-de
$ *git merge FETCH_HEAD*
--------

////
Das Feature kann nützlich sein, wenn Sie ein einziges Mal an einem Branch im Remote interessiert sind, für den Sie keinen Remote-Tracking-Branch konfiguriert haben und das auch nicht tun wollen.
////

This feature can be useful if you are interested in a single remote branch that you have not configured a remote tracking branch for and do not want to do so.






[[sec.prune]]
==== Deleting Expired Remote Tracking Branches
//   Verfallene Remote-Tracking-Branches löschen

////
Sollte ein Remote-Branch gelöscht werden (wie z.B. in  Abschnitt 5.4.1, "Remote-Referenzen löschen" beschrieben), bezeichnet man den entsprechenden Remote-Tracking-Branch als _stale_ ("`abgelaufen`" bzw.  "`verfallen`").
Da solche Branches meist keinen weiteren Nutzen haben, löschen Sie sie (engl. _prune_, "`beschneiden`"):
////

If a Remote Branch is deleted (as described in <<sec.push-delete>>), the corresponding Remote Tracking Branch is referred to as _stale_ ("`expired`").
Since such branches usually have no further use, delete them (_prune_):

[subs="quotes"]
--------
$ *git remote prune origin*
--------

////
Direkt beim Herunterladen löschen:
////

Delete directly during download:

[subs="quotes"]
--------
$ *git fetch --prune*
--------


////
Da dies häufig das gewünschte Verhalten ist, bietet Git die Option `fetch.prune` an.
Setzen Sie diese auf `true`, dann verhält sich `git fetch` bei jedem Aufruf so, als ob Sie es mit der Option `--prune` aufgerufen hätten.
////

Since this is often the desired behavior, Git offers the `fetch.prune` option.
If you set it to `true`, git fetch will behave as if you had called it with the `--prune` option.





[[sec.local-working-branches]]
==== Working with Local Branches
//   Lokale Branches zum Arbeiten

////
Bisher haben wir nur besprochen, wie Sie die Veränderung in einem Remote verfolgen.
Wenn Sie selbst Veränderungen vornehmen, die auf einem der Branches im Remote aufbauen, müssen Sie zuerst einen lokalen Branch erstellen, in dem Sie Commits machen dürfen:[70]
////

So far we have only discussed how to track the change in a remote.
If you make changes yourself that are based on one of the branches in the remote, you must first create a local branch where you are allowed to make commits:{fn70}

[subs="quotes"]
--------
$ *git checkout -b next origin/next*
Branch next set up to track remote branch next from origin.
Switched to a new branch _next_
--------


////
Wenn noch kein lokaler Branch mit Namen `next` existiert, funktioniert auch folgende Abkürzung:
////

If no local branch named `next` exists yet, the following abbreviation also works:


[subs="quotes"]
--------
$ *git checkout next*
Branch next set up to track remote branch next from origin.
Switched to a new branch _next_
--------


////
Die Meldung `set up to track` besagt, dass Git den Branch `next` aus dem Remote `origin` als _Upstream-Branch_ für den lokalen Branch `next` konfiguriert.
Dies ist eine Art "`Verknüpfung`", die anderen Git-Kommandos zugute kommt.
Genaueres finden Sie in Abschnitt 5.3.2, "git pull".
////

The `set up to track` message indicates that Git is configuring the branch `next` from the remote `origin` as the _upstream branch_ for the local branch `next`.
This is a kind of "`shortcut`" that benefits other Git commands.
For more details, see <<sec.pull>>.


////
In dem lokalen Branch können Sie wie gewohnt arbeiten.
Beachten Sie aber, dass Sie die Commits immer nur _lokal_ tätigen.
Um Ihre Arbeit zu veröffentlichen, also in ein Remote hochzuladen, brauchen Sie noch das Kommando `git push` (Abschnitt 5.4, "Commits hochladen: git push").
////

You can work in the local branch as usual.
Note, however, that you only ever commit _locally_.
To publish your work, i.e. upload it to a remote branch, you still need the `git push` command (<<sec.uploading-commits>>).




// @NOTE: Should we leave this title lowercase, since it's a Git command?
[[sec.pull]]
=== git pull

////
Angenommen, Sie wollen Commits aus dem Remote-Repository in Ihren lokalen Branch übernehmen.
Dazu führen Sie zuerst ein `git fetch` aus, um neue Commits zu holen, und anschließend mergen Sie die Veränderung aus dem entsprechenden Remote-Tracking-Branch:[71]
////

Suppose you want to transfer commits from the remote repository to your local branch.
To do this, first run a `git fetch` to fetch new commits, and then merge the change from the corresponding remote tracking branch:{fn71}


[subs="quotes"]
--------
$ *git merge origin/master*
Updating 79170e8..003e3c7
Fast-forward
 cheatsheet.pdf |  Bin 89792 -&gt; 95619 bytes
 cheatsheet.tex |   19 +++++++++++++++++---
 2 files changed, 16 insertions(+), 3 deletions(-)
--------


////
Für diesen Anwendungsfall stellt Git das Kommando `git pull` bereit, um Ihren Workflow zu beschleunigen.
Es ist eine Kombination von `git fetch` und `git merge` oder `git rebase`.
////

For this use case, Git provides the `git pull` command to speed up your workflow.
It is a combination of `git fetch` and `git merge` or `git rebase`.


////
Neue Commits von `origin` herunterladen und alle Commits, die vom dortigen `master` referenziert werden, in den aktuellen Branch mergen ist also mit folgendem Kommando zu erledigen:
////

Downloading new commits from `origin` and merging all commits referenced by the `master` there into the current branch can be done with the following command:


[subs="quotes"]
--------
$ *git pull origin master*
...
From github.com:esc/git-cheatsheet-de
   79170e8..003e3c7  master     -&gt; origin/master
Updating 79170e8..003e3c7
Fast-forward
 cheatsheet.pdf |  Bin 89792 -> 95619 bytes
 cheatsheet.tex |   19 ++++++++++++++++---
 2 files changed, 16 insertions(+), 3 deletions(-)
--------


////
In Abbildung 5.5, "Was bei einem Pull passiert" illustrieren wir den Vorgang.
Auf der linken Seite sehen Sie das Remote-Repository `origin` und daneben den aktuellen Zustand des lokalen Repositorys.
Das Repository wurde geklont, als es nur die Commits A und B enthielt, daher zeigt der Remote-Tracking-Branch `origin/master` auf B.
Mittlerweile sind sowohl im Remote (`C`) als auch im lokalen Repository (`D`) Commits hinzugekommen.
////

In <<fig.pull>> we illustrate the process.
On the left, you see the remote repository `origin` and next to it the current status of the local repository.
The repository was cloned when it only contained commits A and B, so the remote tracking branch points `origin/master` to B.
In the meantime, both the remote (`C`) and local (`D`) repositories have been added.


////
Auf der rechten Seite ist der Zustand nach `git pull origin master` abgebildet.
Commit C wurde ins lokale Repository übernommen.
Der im `pull` enthaltene `fetch`-Aufruf hat den Remote-Tracking-Branch aktualisiert, d.h. er zeigt auf denselben Commit wie der `master` in `origin` und spiegelt somit den dortigen Zustand wider.
Außerdem hat der im `pull` enthaltene `merge`-Aufruf den `master` aus `origin` in den lokalen `master` integriert, was Sie an dem Merge-Commit M sowie der aktuellen Position des lokalen `master` erkennen.
////

On the right side is the state after `git pull origin master`.
Commit C has been added to the local repository.
The `fetch` call contained in the `pull` has updated the remote tracking branch, i.e. it points to the same commit as the `master` in `origin` and thus reflects the state there.
In addition, the `merge` call contained in the `pull` has integrated the `master` from `origin` into the local `master`, as you can see from the merge commit M and the current position of the local `master`.


// .Was bei einem Pull passiert
.What happens with a pull
image::pull.svg[id="fig.pull",scaledwidth="100%",width="100%",align="center"]


////
Alternativ weist die Option `--rebase` das Pull-Kommando an, nach dem `fetch` den lokalen Branch per Rebase auf den Remote-Tracking-Branch aufzubauen:
////

Alternatively, the `--rebase` option instructs the `pull` command to rebase the local branch to the remote tracking branch after `fetch`:


[subs="quotes"]
--------
$ *git pull --rebase  origin master*
--------


////
In Abbildung 5.6, "Was bei einem Pull mit Rebase passiert" sehen Sie, was passiert, wenn Sie statt des Standard-Merge einen Rebase ausführen.
////

In <<fig.pull-rebase>> you can see what happens if you perform a rebase instead of the default merge.


// .Was bei einem Pull mit Rebase passiert
.What happens during a pull with rebase
image::pull-rebase.svg[id="fig.pull-rebase",scaledwidth="100%",width="100%",align="center"]


////
Die Ausgangssituation ist dieselbe wie in Abbildung 5.5, "Was bei einem Pull passiert".
Der im `pull` enthaltene `fetch` rückt den Remote-Tracking-Branch `origin/master` auf den Commit C.
Der `rebase` erzeugt jedoch keinen Merge-Commit; stattdessen erhält der Commit D durch einen Aufruf von `rebase` eine neue Basis, und der lokale `master` wird auf den neuen Commit D' gesetzt.
(Rebase wird ausführlich in Abschnitt 4.1, "Commits verschieben -- Rebase" beschrieben.)
////

The initial situation is the same as in <<fig.pull>>.
The `fetch` contained in the `pull` moves the remote tracking branch `origin/master` to commit C.
However, `rebase` does not create a merge commit; instead, a call to `rebase` gives the commit D a new base, and the local `master` is set to the new commit D'.
(Rebase is described in detail in <<sec.rebase>>).




[[sec.upstream]]
==== Upstream Branches
//   Upstream-Branches

////
Oft werden `git fetch`, `git pull` und `git push` ohne Argumente ausgeführt.
Git verwendet in dem Fall unter anderem die Konfiguration der Upstream-Branches, um zu entscheiden, was zu tun ist.
Aus der Config des Repositorys:
////

Often `git fetch`, `git pull` and `git push` are executed without arguments.
Git uses the configuration of the upstream branches to decide what to do, among other things.
From the repository's config:


--------
[branch "master"]
    remote = origin
    merge = refs/heads/master
--------


////
Der Eintrag besagt, dass der lokale Branch `master` mit dem Remote-Branch `master` im `origin`-Repository verknüpft ist.
////

The entry states that the local branch `master` is linked to the remote branch `master` in the `origin` repository.


////
Der Eintrag `remote` weist `git fetch` und `git pull` an, von welchem Remote aus Commits heruntergeladen werden.
Der Eintrag `merge` wiederum weist `git pull` an, dass die neuen Commits aus dem Remote-Branch `master` in den lokalen `master` gemergt werden sollen.
Das erlaubt es, beide Kommandos ohne Argumente zu verwenden, was in der Praxis sehr häufig vorkommt.
////

The `remote` entry instructs `git fetch` and `git pull`, from which remote commits are downloaded.
The `merge` entry tells `git pull` to merge the new commits from the remote branch `master` to the local `master`.
This allows both commands to be used without arguments, which is very common in practice.


[subs="quotes"]
--------
$ *git fetch*
...
From github.com:esc/git-cheatsheet-de
   79170e8..003e3c7  master     -&gt; origin/master
$ *git pull*
...
From github.com:esc/git-cheatsheet-de
   79170e8..003e3c7  master     -&gt; origin/master
Updating 79170e8..003e3c7
Fast-forward
 cheatsheet.pdf |  Bin 89792 -> 95619 bytes
 cheatsheet.tex |   19 ++++++++++++++++---
 2 files changed, 16 insertions(+), 3 deletions(-)
--------

////
Wenn kein Upstream-Branch konfiguriert ist, versucht es `git fetch` mit `origin` und bricht ansonsten ab:
////

If no upstream branch is configured, it tries `git fetch` with `origin` and otherwise aborts:

[subs="quotes"]
--------
$ *git fetch*
fatal: No remote repository specified.  Please, specify either a URL or
a remote name from which new revisions should be fetched.
--------




[TIP]
========
////
Wenn Sie möchten, dass die Änderungen aus einem Upstream-Branch bei `git pull` standardmäßig per Rebase statt mit einem Merge übernommen werden, setzen Sie den Wert der Einstellung `branch.<name>.rebase` auf `true`, z.B.:
////

If you want changes from an upstream branch on `git pull` to be applied by rebase instead of merge by default, set the value of the `branch.<name>.rebase` setting to `true`, for example

[subs="quotes"]
--------
$ *git config branch.master.rebase true*
--------
========




// @NOTE: Should we leave this title lowercase, since it's a Git command?
[[sec.fetch-vs-pull]]
=== git fetch vs. git pull

////
Git-Anfängern stellt sich häufig die Frage, ob sie nun `fetch` oder `pull` verwenden sollen.
Die Antwort hängt davon ab, wie entwickelt wird: Wie groß ist das Projekt?
Wie viele Remotes gibt es?
Wie stark werden Branches eingesetzt?
////

Git beginners often ask themselves whether they should use `fetch` or `pull`.
The answer depends on how you develop: How big is the project?
How many remotes are there?
How heavily are branches used?


[[sec.push-pull]]
==== Distributed Git for Beginners
//   Verteiltes Git für Anfänger

////
Besonders für Anfänger ist es sinnvoll, dass alle Teilnehmer auf demselben Branch arbeiten (meist `master`), sich mit demselben Repository synchronisieren (zentraler Workflow) und nur `git pull` zum Herunterladen bzw. `git push` zum Hochladen verwenden.
Das erübrigt die Auseinandersetzung mit komplexeren Aspekten wie Objektmodell, Branching und Verteilung; und die Teilnehmer können mit einigen wenigen Kommandos Verbesserungen beisteuern.
////

Especially for beginners, it makes sense that all participants work on the same branch (usually `master`), synchronize with the same repository (central workflow) and use only `git pull` for downloading and `git push` for uploading.
This eliminates the need to deal with more complex aspects such as object model, branching and distribution; and participants can contribute improvements with just a few commands.


////
Es entsteht der folgende Arbeitsablauf:
////

This results in the following workflow:


[subs="quotes"]
--------
# Repository Klonen
$ *git clone &lt;URL&gt;*
# Arbeiten und lokale Commits machen
$ *git add ...*
$ *git commit*
# Veränderungen von Anderen herunterladen
$ *git pull*
# Eigene Veränderungen hochladen
$ *git push*
# Weiter arbeiten, und Synchronisation bei Bedarf wiederholen
$ *git commit*
--------

////
Dieser Ansatz hat Vor- und Nachteile.
Von Vorteil ist sicherlich, dass nur ein geringes Verständnis von Git notwendig ist, um dem Arbeitsablauf erfolgreich zu folgen.
Die automatische Konfiguration der Upstream-Branches sorgt dafür, dass `git push` und `git pull` auch ohne Argument das "`Richtige`" tun.
Außerdem ähnelt dieser Workflow dem, was Umsteiger von Subversion gewöhnt sind.
////

This approach has advantages and disadvantages.
The advantage is certainly that only a basic understanding of Git is necessary to follow the workflow successfully.
The automatic configuration of upstream branches ensures that `git push` and `git pull` do the "`right thing`" without argument.
In addition, this workflow is similar to what Subversion users are used to.


////
Allerdings gibt es auch Nachteile, die hauptsächlich mit dem impliziten Merge zusammenhängen.
Angenommen, das Team besteht aus zwei Teilnehmern, Beatrice und Carlos.
Beide haben lokale Commits gemacht, und Beatrice hat ihre bereits hochgeladen.
Carlos führt nun `git pull` aus und erhält die Meldung `Merge made by recursive`.
Behält man den Commit-Graphen im Hinterkopf, ist das logisch: Der lokale Branch und der `master` des Remote sind auseinandergelaufen (_diverged_), darum wurden sie durch einen Merge wieder vereint.
Jedoch versteht Carlos die Meldung nicht, da er ja an einem anderen Teil des Codes gearbeitet hat als seine Kollegin und seines Erachtens kein Merge notwendig war.
Ein Problem liegt darin, dass der Term _Merge_ bei vielen, die zentrale Versionsverwaltung gewohnt sind, die Assoziation hat, Veränderungen würden an derselben Datei zusammengeführt.
Bei Git jedoch ist ein Merge in jedem Fall als Zusammenführung von Commits in einem Commit-Graphen zu verstehen.
Dies kann das Zusammenführen von Veränderungen an derselben Datei meinen, setzt das aber nicht voraus.
////

However, there are also drawbacks, mainly related to implicit merging.
Suppose the team consists of two people, Beatrice and Carlos.
Both have made local commits, and Beatrice has already uploaded hers.
Carlos now runs `git pull` and receives the message `Merge made by recursive`.
If you keep the commit graph in mind, it's logical: the local branch and the `master` of the remote have _diverged_, so they have been merged back together.
However, Carlos doesn't understand the message, since he was working on a different part of the code than his colleague, and in his opinion no merge was necessary.
One problem is that term _merge_ stores the association that many people used to have with centralized version control that changes would be merged into the same file.
With Git, however, a merge is always to be understood as the merging of commits into a commit graph.
This may mean merging changes to the same file, but it does not require it.


////
Neben der Verwirrung der Nutzer sorgt dieser Arbeitsablauf für "`unsinnige`" Commits in der Geschichte.
Im Idealfall sollen Merge-Commits ein sinnvoller Eintrag in der Geschichte sein.
Ein Außenstehender erkennt sofort, dass ein Entwicklungszweig eingeflossen ist.
Jedoch kommt bei diesem Arbeitsablauf zwangsläufig hinzu, dass der lokale `master` und dessen Pendant im Remote auseinanderlaufen und durch einen Merge wieder zusammengeführt werden.
Die dabei entstehenden Merge-Commits sind aber nicht sinnvoll -- sie sind eigentlich nur eine Nebenwirkung des Workflows und verringern die Lesbarkeit der Geschichte.
Zwar bietet die Option `--rebase` für `git pull` Abhilfe, aber die Man-Page rät explizit vom Einsatz der Option ab, sofern Sie nicht schon das Prinzip des Rebase verinnerlicht haben.
Haben Sie dieses verstanden, ist Ihnen auch die Entstehung des Commit-Graphen vertraut und wie er zu manipulieren ist -- dann lohnt es sich für Sie, als Workflow gleich die featuregetriebene Entwicklung mit Branches anzustreben.
////

Besides confusing users, this workflow creates "`nonsensical`" commits in the history.
Ideally, merge commits should be meaningful entries in the repository history.
An outsider can immediately see that a development branch has been included.
However, this workflow inevitably involves the local `master` and its remote counterpart diverging and being merged back together.
The resulting merge commits make no sense -- they are actually only a side effect of the workflow and reduce the readability of the history.
Although the `--rebase` option for `git pull` offers a remedy, the man page explicitly advises against using this option unless you have already internalized the principle of rebase.
Once you understand this, you're also familiar with how the commit graph is created and how to manipulate it -- it's worthwhile for you to go straight for feature-driven development with branches as a workflow.





[[sec.fetch-push]]
==== Distributed Git for Advanced Users
//   Verteiltes Git für Fortgeschrittene

////
Sobald Sie das Objektmodell und den Commit-Graphen verstanden haben, empfehlen wir Ihnen einen Workflow einzusetzen, der im Wesentlichen aus `git fetch`, manuellen Merges und vielen Branches besteht.
Es folgen als Anregung einige Rezepte.
////

Once you understand the object model and the commit graph, we recommend that you use a workflow that essentially consists of `git fetch`, manual merges, and many branches.
The following are some recipes as a suggestion.


////
Sofern Sie `master` als Integrationsbranch verwenden, müssen Sie nach einem Aufruf von `git fetch` Ihren lokalen `master` vorrücken.
Um genau zu sein, müssen Sie alle lokalen Branches, die eine Entsprechung auf der Remote-Seite haben, vorrücken.
Git bietet dafür die Syntax `@{upstream}` bzw. `@{u}` an, was dem für den aktuellen Branch konfigurierten Remote-Tracking-Branch entspricht.
Dies kann sehr hilfreich sein.
////

If you are using `master` as your integration branch, you will need to move your local U forward after calling `git fetch`.
To be precise, you need to advance all local branches that have a remote equivalent.
Git provides the syntax `@{upstream}` and `@{u}`, which corresponds to the remote tracking branch configured for the current branch.
This can be very helpful.



[subs="quotes"]
--------
# Veränderungen von Anderen herunterladen
$ *git remote update*
...
   79170e8..003e3c7  master     -&gt; origin/master

# Den Status der Remote-Tracking-Branches abfragen
$ *git branch -vv*
* master 79170e8 [origin/master: behind 1] Lizenz hinzugefügt

# Veränderungen einsehen
$ *git log -p ..@{u}*

# Heruntergeladene Änderungen übernehmen
$ *git merge @{u}*
Updating 79170e8..003e3c7
Fast-forward
...

# ... oder eigene Änderungen darauf neu aufbauen
$ *git rebase @{u}*

# Änderungen dann hochladen
$ *git push*
--------


[TIP]
========
////
Wenn Sie häufiger lokale Branches mit Ihrem Remote-Tracking-Branch synchronisieren, empfehlen wir Ihnen folgendes Alias:
////

If you frequently synchronize local branches with your remote tracking branch, we recommend the following alias:


[subs="quotes"]
--------
$ *git config --global alias.fft "merge --ff-only @{u}"*
--------


////
Damit können Sie ganz bequem mit `git fft` (_Fast-Forward-Tracking_) einen Branch vorrücken.
Die Option `--ff-only` verhindert, dass versehentlich Merge-Commits entstehen, wo eigentlich keine hingehören.
////

This allows you to easily move forward a branch with `git fft` (_Fast Forward Tracking_).
The `--ff-only` option prevents accidental merge commits from occurring where none should.
========

////
Hilfreich ist in diesem Kontext auch Kapitel 6, Workflows, wo beschrieben wird, wie Sie übersichtlich mit vielen Topic-Branches arbeiten.
////

In this context, <<ch.workflows>> is also helpful, where it is described how to work clearly with many Topic Branches.





[[sec.uploading-commits]]
== Uploading Commits: git push
// Commits hochladen: git push

////
Das Gegenstück zu `fetch` und `pull` bildet das Kommando `git push`.
Damit laden Sie Git-Objekte und Referenzen in ein Remote hoch -- z.B. den lokalen `master` in den Branch `master` im Remote `origin`:
////

The counterpart to `fetch` and `pull` is the command `git push`.
This is used to upload git objects and references to a remote -- e.g. the local `master` to the branch `master` in the remote `origin`:

[subs="quotes"]
--------
$ *git push origin master:master*
--------


////
Wie bei `git fetch` geben Sie die Referenzen zum Hochladen mit einem Refspec an.
Dieser hat jedoch die umgekehrte Form:
////

As with `git fetch`, you specify the references for uploading with a refspec.
However, the refspec has the opposite form:

--------
<local-refs>:<remote-refs>
--------

////
Diesmal befinden sich die lokalen Referenzen auf der linken Seite des Doppelpunktes, und die Remote-Referenzen auf der rechten.
////

This time the local references are on the left side of the colon, and the remote references on the right.


////
Lassen Sie den Doppelpunkt und die Remote-Referenz weg, wird der lokale Name auch auf der Remote-Seite verwendet und von Git erstellt, falls er nicht existiert:
////

If you omit the colon and the remote reference, the local name will also be used on the remote side, and will be created by Git if it doesn't exist:


[subs="quotes"]
--------
$ *git push origin master*
Counting objects: 73, done.
Compressing objects: 100% (33/33), done.
Writing objects: 100% (73/73), 116.22 KiB, done.
Total 73 (delta 42), reused 68 (delta 40)
Unpacking objects: 100% (73/73), done.
To git@github.com:esc/git-cheatsheet-de.git
 * [new branch]      master -&gt; master
--------

////
Den Vorgang hinter `git push` zeigt Abbildung 5.7, "Referenzen und Commits hochladen".
Die Ausgangssituation sehen Sie auf der linken Seite (es ist das Ergebnis eines `pull`-Aufrufes).
Die fehlenden Commits D und M lädt Git in das Remote `origin` hoch.
Gleichzeitig wird der Remote-Branch `master` auf den Commit M vorgerückt, so dass dieser dem lokalen Branch `master` entspricht.
Außerdem wird der Remote-Tracking-Branch `origin/master` vorgerückt, damit er den aktuellen Zustand im Remote widerspiegelt.
////

<<fig.push>> shows the process behind `git push`.
The initial situation is shown on the left (it is the result of a `pull` call).
Git uploads the missing commits D and M to the remote `origin`.
At the same time, the remote branch master is advanced to the commit M, so that it matches the local branch `master`.
In addition, the remote tracking branch `origin/master` is advanced so that it reflects the current status in the remote.


// .Referenzen und Commits hochladen
.Upload references and commits
image::push.svg[id="fig.push",scaledwidth="100%",width="100%",align="center"]


////
Analog zu `fetch` weigert sich Git, Referenzen zu aktualisieren, bei denen der Ziel-Commit kein Nachfahre des aktuellen Commits ist:
////

Like `fetch`, Git refuses to update references where the target commit is not a descendant of the current commit:


[subs="quotes"]
--------
$ *git push origin master*
...
 ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to 'git@github.com:esc/git-cheatsheet-de.git'
To prevent you from losing history, non-fast-forward updates were
rejected
Merge the remote changes before pushing again.  See the 'Note about
fast-forwards' section of 'git push --help' for details.
--------

////
Dieses Verhalten setzen Sie entweder durch ein vorangestelltes Plus (`+`) im Refspec oder durch die Option `--force` bzw. kurz `-f` außer Kraft:[72]
////

You can override this behavior either by prefixing it with a plus (`+`) in the refspec or by using the `--force` or short `-f` option:{fn72}

[subs="quotes"]
--------
$ *git push origin --force master*
$ *git push origin +master*
--------


////
Vorsicht!
Es können Commits auf der Remote-Seite verloren gehen -- zum Beispiel wenn sie per `git reset --hard` einen Branch verschoben haben und Commits nicht mehr referenziert werden.
////

Look out!
Commits may be lost on the remote side -- for example, if you have moved a branch using `git reset --hard` and commits are no longer referenced.


////
Sie erhalten die Fehlermeldung auch, wenn Sie Commits, die bereits per `git push` veröffentlicht wurden, nachträglich mit `git rebase` oder `git commit --amend` modifiziert haben.
Daher hier noch einmal die ausdrückliche Warnung: Vermeiden Sie es, Commits, die Sie bereits veröffentlicht haben, nachträglich zu verändern!
Durch die veränderten SHA-1-Summen kommt es zu Doppelungen, wenn Andere die ursprünglichen Commits bereits heruntergeladen haben.
////

You'll also get the error message if you have modified commits that have already been published via `git push` using `git rebase` or `git commit --amend`.
So here's the explicit warning again: avoid modifying commits that you have already published!
The modified SHA-1 sums will cause duplication if others have already downloaded the original commits.




[[sec.push-delete]]
=== Deleting Remote References
//  Remote-Referenzen löschen

////
Es gibt zwei Möglichkeiten, um Referenzen im Remote wieder zu löschen: Die ältere (vor Git Version 1.7.0) ist, beim Refspec die lokale Referenz wegzulassen -- diese Anweisung bedeutet, Sie möchten "`nichts`" hochladen.
Sie ersetzen also eine existierende durch die leere Referenz.
////

There are two ways to delete references in the remote: The older one (before Git version 1.7.0) is to omit the local reference in the refspec -- this statement means you want to upload "`nothing`".
So you replace an existing reference with the empty one.


[subs="quotes"]
--------
$ *git push origin :bugfix*
--------


////
In neueren Git-Versionen wird aber in der Regel das Kommando `git push` mit der Option `--delete` verwendet, was syntaktisch viel deutlicher ist:
////

However, newer git versions usually use the `git push` command with the `--delete` option, which is syntactically much clearer:


[subs="quotes"]
--------
$ *git push origin --delete bugfix*
--------


////
Beachten Sie, dass in anderen Klonen der ggf. vorhandene Remote-Tracking-Branch `origin/bugfix` dadurch _nicht_ automatisch verschwindet!
Siehe dafür den Abschnitt über _Pruning_ weiter oben (Abschnitt 5.3, "Commits herunterladen").
////

Note that in other clones, the remote tracking branch `origin/bugfix`, if present, does _not_ automatically disappear!
See the section on _pruning_ above (<<sec.downloading-commits>>).







[[sec.push-default]]
=== Pushing without Arguments: push.default
//  Push ohne Argumente: push.default

////
Im Alltag führen Sie `git push` oft ohne Angabe von Remote und Refspec aus.
In dem Fall entscheidet Git anhand der Konfigurationseinträge (Upstream-Branch und `push.default`), welche Referenzen wohin geschickt werden.
////

In everyday life you often run `git push` without specifying remote and refspec.
In this case, Git uses the configuration entries (upstream branch and `push.default`) to decide which references are sent where.

[subs="quotes"]
--------
$ *git push*
...
To git@github.com:esc/git-cheatsheet-de.git
   79170e8..003e3c7  master -&gt; master
--------

////
Git geht standardmäßig so vor:[73] Wenn Sie kein Remote angeben, dann sucht Git die Upstream-Konfiguration des aktuellen Branches heraus.
Sofern der Name des Branches auf der Remote-Seite mit dem Namen des lokalen Branches übereinstimmt, wird die entsprechende Referenz hochgeladen (dies soll Sie davor schützen, bei fehlerhafter Upstream-Konfiguration zum Beispiel Ihren Branch `devel` nach `master` hochzuladen).
Ist kein Upstream-Branch konfiguriert, bricht Git mit einer Fehlermeldung ab:
////

By default, Git proceeds like this:{fn73} If you don't specify a remote, Git will look for the upstream configuration of the current branch.
If the name of the branch on the remote side matches the name of the local branch, the corresponding reference is uploaded (this is to protect you from uploading, for example, your branch `devel` to `master` if the upstream configuration is incorrect).
If no upstream branch is configured, Git aborts with an error message:

[subs="quotes"]
--------
$ *git push*
fatal: The current branch master has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin master
--------

////
Wenn Sie mit `git push <remote>` zwar ein Remote, aber keinen Branch angeben, so versucht Git, den aktuellen Branch unter dem gleichen Namen in das Remote hochzuladen.
////

If you use `git push <remote>` to specify a remote but no branch, Git will attempt to upload the current branch to the remote under the same name.


////
Die hier beschriebene Strategie wird auch als `simple` bezeichnet.
Sie tut für die meisten Anwendungsfälle das, was der Nutzer erwartet, und schützt vor vermeidbaren Fehlern.
Die dafür zuständige Option `push.default` können Sie aber bei Bedarf auch auf einen der folgenden Werte setzen:
////

The strategy described here is also known as `simple`.
For most use cases, it does what the user expects and protects against avoidable errors.
However, you can set the `push.default` option responsible for this to one of the following values if required:


////
`nothing` ::
Nichts hochladen.
Dies ist sinnvoll, wenn Sie immer explizit angeben wollen, welchen Branch Sie wohin hochladen wollen.

`upstream` ::
Wenn der aktuelle Branch einen Upstream-Branch hat, dorthin pushen.

`current` ::
Den aktuellen Branch in einen Remote-Branch gleichen Namens pushen.

`matching` ::
Lädt alle lokal existierenden Referenzen hoch, für die es im entsprechenden Remote bereits eine Referenz gleichen Namens gibt.
Achtung: Sie laden dadurch potentiell mehrere Branches gleichzeitig hoch!
////

[horizontal]
`nothing` ::
Do not upload anything.
This is useful if you always want to explicitly specify which branch you want to upload to where.

`upstream` ::
If the current branch has an upstream branch, push there.

`current` ::
Push the current branch into a remote branch of the same name.

`matching` ::
Uploads all locally existing references for which a reference of the same name already exists in the corresponding remote.
Attention: You are potentially uploading several branches at the same time!



[[sec.upstream-config]]
=== Configuring the Upstream Branch
//  Konfiguration des Upstream-Branches

////
Git nimmt die Konfiguration von Upstream-Branches in einigen Fällen automatisch vor (zum Beispiel nach einem `git clone`).
Insbesondere für neue Branches, die Sie das erste Mal hochladen, müssen Sie dies allerdings explizit tun.
Sie können dafür entweder im Nachhinein die Option `--set-upstream-to` oder kurz `-u` von `git branch` verwenden:
////

In some cases, Git will automatically configure upstream branches (for example, after a `git clone`).
However, you need to do this explicitly, especially for new branches that you are uploading for the first time.
You can do this either afterwards using the `--set-upstream-to` option or, in short, `-u` of `git branch`:


[subs="quotes"]
--------
$ *git push origin new-feature*
$ *git branch -u origin/new-feature*
Branch new-feature set up to track remote branch new-feature from origin.
--------


////
Alternativ und wenn Sie daran denken, können Sie aber auch gleich beim Aufruf von `git push` mit der Option `-u` die Konfiguration schreiben lassen:
////

Alternatively, and if you think about it, you can also have `git push` write the configuration when you call `git push` with the `-u` option:


[subs="quotes"]
--------
$ *git push -u origin new-feature*
--------

////
Um die Upstream-Konfiguration Ihrer Branches anzuzeigen, rufen Sie `git branch -vv` auf.
In der Ausgabe wird (falls vorhanden) der Upstream-Partner eines Branches in eckigen Klammern angezeigt.
////

To view the upstream configuration of your branches, call `git branch -vv`.
The output shows the upstream partner of a branch (if any) in square brackets.




[[sec.remotes-check]]
== Examining Remotes
// Remotes untersuchen

////
In diesem Abschnitt stellen wir  Techniken vor, mit denen Sie ein Remote einsehen und Ihr lokales Repository damit vergleichen.
////

In this section, we introduce techniques for viewing a remote and comparing your local repository to it.



// @NOTE: Maybe "Anatomy of a Remote" or "Inspecting Remotes"?
[[sec.remotes-show]]
=== Overview of a Remote
//  Zusammenfassung eines Remotes

////
Das Kommando `git remote show` gibt eine prägnante Zusammenfassung des Remotes, inklusive den dort verfügbaren Branches, ob diese lokal verfolgt werden (Tracking-Status) und welche lokalen Branches für bestimmte Aufgaben konfiguriert sind.
////

The `git remote show` command gives a concise summary of the remote, including the branches available there, whether they are tracked locally (tracking status) and which local branches are configured for specific tasks.


////
Das Kommando muss beim Remote den aktuellen Stand erfragen, d.h. der Befehl scheitert, wenn das Remote nicht verfügbar ist, z.B. aufgrund fehlender Netzwerkverbindung.
Die Option `-n` unterbindet die Abfrage.
////

The command must request the current status from the remote, i.e. the command fails if the remote is not available, e.g. due to a missing network connection.
The option `-n` prevents the query.


[subs="quotes"]
--------
$ *git remote show origin*
* remote origin
  Fetch URL: git://git.kernel.org/pub/scm/git/git.git
  Push  URL: git://git.kernel.org/pub/scm/git/git.git
  HEAD branch: master
  Remote branches:
    html   tracked
    maint  tracked
    man    tracked
    master tracked
    next   tracked
    pu     tracked
    todo   tracked
  Local branches configured for 'git pull':
    master merges with remote master
    pu     merges with remote pu
  Local refs configured for 'git push':
    master pushes to master (local out of date)
    pu     pushes to pu     (up to date)
--------



[[sec.remote-branch-vv]]
=== Comparison with the Upstream
//  Vergleich mit dem Upstream

////
Haben Sie einen Upstream-Branch konfiguriert, erhalten Sie beim Wechseln des Branches (`git checkout`) und Abfragen des Status (`git status`) eine Benachrichtigung über den Zustand des Branches im Vergleich mit dem Upstream, z.B.:
////

If you have configured an upstream branch, when you change the branch (`git checkout`) and query the status (`git status`), you will receive a notification about the status of the branch compared to the upstream, for example:

[subs="quotes"]
--------
$ *git checkout master*
Your branch is behind 'origin/master' by 73 commits, and can be
fast-forwarded.
--------


////
Hier gibt es vier verschiedene Möglichkeiten:
////

Here there are four different possibilities:


////
* Die Branches zeigen auf denselben Commit.
  Git zeigt keine besondere Nachricht an.
  Dieser Zustand heißt auch _up-to-date_.
////

* The branches point to the same commit.
Git doesn't show any special message.
This state is also called _up-to-date_.


////
* Der lokale Branch hat Commits, die noch nicht im Upstream verfügbar sind:
////

* The local branch has commits that are not yet available upstream:
+
`Your branch is ahead of 'origin/master' by 16 commits.`


// @NOTE: Use Verbatim blocks instead of inline code?
//        This would be more consistent the styles used in other Git logs
//        (especially if we're going to adopt a dedicated color scheme for them).


////
* Der Remote-Tracking-Branch hat Commits, die in dem lokalen Branch noch nicht verfügbar sind:
////

* The remote tracking branch has commits that are not yet available in the local branch:
+
`Your branch is behind 'origin/master' by 73 commits, and can be fast-forwarded.`


////
* Sowohl die zweite als auch die dritte Bedingung treffen zu, ein Zustand der im Git-Jargon als _diverged_ bezeichnet wird:
////

* Both the second and third conditions apply, a state called _diverged_ in Git jargon:
+
`Your branch and 'origin/master' have diverged, and have 16 and 73 different commit(s) each, respectively.`



////
Mit der Option `-v` (nur den Vergleich) oder `-vv` (Vergleich und Upstream-Bezeichnung) zeigt `git branch` die entsprechenden Informationen für lokale Branches:
////

With the `-v` (compare only) or `-vv` (compare and upstream name) option, `git branch` displays the appropriate information for local branches:


[subs="quotes"]
--------
$ *git branch -vv*
* master      0a464e9 [origin/master: ahead 1] docs: fix grammar in
git-tags.txt
  feature     cd3065f Merge branch 'kc/gitweb-pathinfo-w-anchor'
  next        be8b495 [origin/next] Merge branch master into next
  pu          0c0c536 [origin/pu: behind 3] Merge branch
'jk/maint-merge-rename-create' into pu
--------

////
Das Kommando gibt für alle Branches das SHA-1-Präfix sowie die Commit-Message des aktuellen Commits aus.
Ist für den Branch ein Upstream konfiguriert, liefert Git sowohl den Namen als auch einen Vergleich zum Upstream.
In dem Beispiel sehen Sie vier verschiedene Branches.
`master` hat einen zusätzlichen Commit, der noch nicht ins Remote hochgeladen wurde, und ist daher _ahead_.
Der Branch `feature` wiederum hat keinen Upstream-Branch konfiguriert, ergo: er existiert momentan nur lokal.
Der Branch `next` ist auf demselben Stand wie der entsprechende Remote-Tracking-Branch (_up-to-date_).
Der Branch `pu` andererseits "`hinkt`" seinem Upstream hinterher und wird daher als `behind` angezeigt.
Der einzige Zustand, der hier fehlt, ist _diverged_ -- dann werden sowohl _ahead_ als auch _behind_ inklusive der Anzahl der "`fehlenden`" Commits angezeigt.
////

The command prints the SHA-1 prefix for all branches and the commit message of the current commit.
If an upstream is configured for the branch, Git returns both the name and a comparison to the upstream.
In the example, you see four different branches.
`master` has an additional commit that has not yet been uploaded to the remote, and is therefore _ahead_.
The branch `feature`, on the other hand, has no upstream branch configured, so it currently exists only locally.
The branch `next` is _up-to-date_ with the corresponding remote tracking branch.
The Branch `pu`, on the other hand, "`lags`" behind its upstream and is therefore displayed as `behind`.
The only state missing here is _diverged_ -- then both _ahead_ and _behind_ are shown including the number of "`missing`" commits.




[[sec.multi-remote]]
== Distributed Workflow with Multiple Remotes
// Verteilter Workflow mit mehreren Remotes

////
Git unterstützt das Arbeiten mit mehreren Remotes.
Ein beliebter Workflow, der sich diese Eigenschaft zu Nutze macht, ist der _Integration-Manager Workflow_.
Hier gibt es kein "`zentrales`" Repository im eigentlichen Sinne, das heißt eines, auf das alle aktiven Entwickler Schreibzugriff haben.
Stattdessen gibt es nur ein quasi-offizielles Repository, das _blessed_ ("`gesegnet`") genannt wird.
Es ist beispielsweise über die jeweilige Projekt-Domain erreichbar und erlaubt nur den wichtigsten Maintainern (oder gar nur einem) Schreibzugriff.
////

Git supports working with multiple remotes.
A popular workflow that takes advantage of this feature is the _Integration Manager Workflow_.
There is no "`central`" repository in the true sense of the word, that is, one that all active developers have write access to.
Instead, there is only a quasi-official repository called _blessed_.
It is accessible, for example, via the respective project domain and allows only the most important maintainers (or even only one) write access.


////
Jeder, der zu dem Projekt beitragen will, klont das Blessed Repository und beginnt mit der Arbeit.
Sobald er Fehler behoben oder ein neues Feature implementiert hat, stellt er seine Verbesserungen über ein öffentlich zugängliches Repository, einem sog. _Developer-Public_, zur Verfügung.
Danach sendet er an einen der Maintainer des offiziellen Repositorys (oder an die Mailingliste) einen sog. _Pull-Request_, also die Aufforderung, gewissen Code aus seinem öffentlichen Repository in das offizielle Repository zu übernehmen.
Die Infrastruktur für diesen Ablauf sehen Sie in  Abbildung 5.8, "Integration-Manager Workflow".
Es ist zwar theoretisch möglich, Interessenten direkten Zugriff auf die eigene Entwicklungsmaschine zu geben, das geschieht in der Praxis aber beinahe nie.
////

Everyone who wants to contribute to the project clones the blessed repository and starts working.
As soon as he has fixed bugs or implemented a new feature, he makes his improvements available via a publicly accessible repository, a so-called _developer public_.
He then sends a _pull request_ to one of the maintainers of the official repository (or to the mailing list), requesting that certain code from his public repository be transferred to the official repository.
You can see the infrastructure for this process in <<fig.developer-public-workflow>>.
Although it is theoretically possible to give interested parties direct access to your development machine, this almost never happens in practice.



// @TRANSLATE IMAGE TEXT

.Integration Manager Workflow
image::integration-manager-workflow.svg[id="fig.developer-public-workflow",scaledwidth="70%",width="70%",align="center"]


////
Einer der Maintainer, die Zugriff auf das Haupt-Repository haben, überprüft dann, ob der Code funktioniert, ob er den Qualitätsanforderungen entspricht usw.
Eventuelle Fehler oder Unklarheiten teilt er dem Autor des Codes mit, der diese dann wiederum in seinem Repository korrigiert.
Erst wenn der Maintainer zufrieden ist, übernimmt er die Änderungen in das Haupt-Repository, so dass der Code in einem der folgenden Releases mitgeliefert wird.
Maintainer, die neuen Code eingliedern, werden oft als _Integration Manager_ bezeichnet, was dem Workflow seinen Namen gegeben hat.
Oft haben solche Maintainer mehrere Remotes konfiguriert, eines für jeden Mitwirkenden.
////

One of the maintainers who have access to the master repository then checks if the code works, if it meets the quality requirements, etc.
Any errors or ambiguities are reported to the author of the code, who then corrects them in his repository.
Only when the maintainer is satisfied does he commit the changes to the master repository, so that the code is delivered in one of the following releases.
Maintainers who integrate new code are often referred to as _Integration Managers_, which gives the workflow its name.
Such maintainers often have several remotes configured, one for each contributor.


////
Einer der großen Vorteile dieses Workflows ist, dass außer den Maintainern auch interessierte User Zugriff auf die öffentlichen Entwickler-Repositories haben, etwa Kollegen oder Freunde des Entwicklers.
Diese müssen nicht warten, bis der Code seinen Weg in das offizielle Repository gefunden hat, sondern können direkt nach der Bereitstellung die Verbesserungen ausprobieren.
Insbesondere die Hosting-Plattform Github setzt sehr stark auf diesen Workflow.
Die dort eingesetzte Weboberfläche bietet eine Vielzahl von Features, um diesen Workflow zu unterstützen, z.B. eine Visualisierung, die alle verfügbaren Klons eines Projekts und die darin enthaltenen Commits anzeigt, sowie die Möglichkeit, Merges direkt im Webinterface durchzuführen.
Eine ausführliche Beschreibung dieses Dienstes finden Sie in Kapitel 11, Github.
////

One of the great advantages of this workflow is that, in addition to the maintainers, interested users, such as colleagues or friends of the developer, also have access to the public developer repositories.
They don't have to wait until the code has found its way into the official repository, but can try out the improvements immediately after deployment.
The hosting platform Github in particular relies heavily on this workflow.
The web interface used there offers a lot of features to support this workflow, e.g. a visualization that shows all available clones of a project and the commits contained in them, as well as the possibility to perform merges directly in the web interface.
For a detailed description of this service, see <<ch.github>>.






[[sec.managing-remotes]]
== Managing Remotes
// Remotes verwalten


////
Mit `git remote` verwalten Sie zusätzliche Remotes.
Um z.B. ein neues Remote eines anderen Entwicklers hinzuzufügen, verwenden Sie das Kommando `git remote add`.
Meist wollen Sie im Anschluss die Remote-Tracking-Branches initialisieren, was Sie mit `git fetch` erreichen:
////

With `git remote` you can manage additional remotes.
For example, to add a new remote from another developer, use the command `git remote add`.
Most of the time you'll want to initialize the remote tracking branches afterwards, which you can do with `git fetch`:


[subs="quotes"]
--------
$ *git remote add example git://example.com/example.git*
$ *git fetch example*
...
--------

[TIP]
========
////
Um beide Arbeitsschritte in einem Aufruf zu erledigen, verwenden Sie die Option `-f`, für _fetch_:
////

To do both steps in one call, use the `-f` option, for _fetch_:

[subs="quotes"]
--------
$ *git remote add -f example git://example.com/example.git*
--------
========

////
Brauchen Sie das Remote nicht mehr, können Sie es mit `git remote rm` aus Ihrer lokalen Konfiguration wieder entfernen.
Dadurch werden auch alle Remote-Tracking-Branches für dieses Remote wieder gelöscht:
////

If you no longer need the remote, you can remove it from your local configuration using `git remote rm`.
This will also delete all remote tracking branches for that remote:


[subs="quotes"]
--------
$ *git remote rm example*
--------


////
Remotes müssen nicht zwingend per `git remote add` konfiguriert werden.
Sie können einfach die URL auf der Kommandozeile verwenden,[74] zum Beispiel, um die Objekte und Referenzen für einen Bugfix herunterzuladen:
////

Remotes do not necessarily have to be configured via `git remote add`.
You can simply use the URL on the command line,{fn74} for example to download the objects and references for a bugfix:


[subs="quotes"]
--------
$ *git fetch git://example.com/example.git bugfix:bugfix*
--------

////
Selbstverständlich geht das auch mit `pull` und `push`.
////

Of course this also works with `pull` and `push`.


////
Arbeiten Sie mit mehreren Remotes, bietet sich das Kommando `git remote update --prune` an.
Damit führen Sie `fetch` für alle Remotes durch, wobei die Option `--prune` dafür sorgt, dass alle abgelaufenen Remote-Tracking-Branches gelöscht werden.
////

If you work with several remotes, the command `git remote update --prune` is a good choice.
This will `fetch` all remotes, and the `--prune` option will delete all expired remote tracking branches.


[TIP]
========
////
Folgendes Alias hat sich bei uns sehr bewährt, da es viele Arbeitsschritte, die in der Praxis oft hintereinander ausgeführt werden, vereint:
////

The following alias has proved to be very useful for us, as it combines many work steps that are often performed one after the other in practice:

[subs="quotes"]
--------
$ *git config --global alias.ru "remote update --prune"*
--------
========





[[sec.pull-request]]
=== Pull-Request

////
Um einen Pull-Request automatisch zu generieren, gibt es das Git-Kommando `request-pull`.
Die Syntax lautet:
////

To generate a pull request automatically, there is the git command `request-pull`.
The syntax is:


--------
git request-pull <start> <URL> [<end>]
--------


////
Als `<URL>` geben Sie Ihr öffentliches Repository an (entweder als tatsächliche URL oder als konfiguriertes Remote-Repository), und als `<Anfang>` wählen Sie die Referenz, auf die das Feature aufbaut (in vielen Fällen den Branch `master`, der mit dem Master-Branch des offiziellen Repositorys übereinstimmen sollte).
Optional können Sie ein `<Ende>` angeben; lassen Sie diese Angabe weg, so verwendet Git `HEAD`.
////

As `<URL>` you specify your public repository (either as the actual URL or as a configured remote repository), and as `<start>` you select the reference on which the feature is built (in many cases the branch `master`, which should match the master branch of the official repository).
Optionally, you can specify an `<end>`; if you omit this, Git will use `HEAD`.


////
Die Ausgabe erfolgt nach Standard-Out und enthält die URL sowie den Branch-Namen des Repositorys, die Kurzbeschreibung aller Commits nach Autor sowie ein Diff-Stat, also eine Bilanz von hinzugekommenen und gelöschten Zeilen nach Dateien.
Diese Ausgabe lässt sich bequem an ein E-Mail-Programm weiterleiten.
Fügen Sie noch die Option `-p` hinzu, wird unter den Text noch ein Patch mit allen Änderungen angehängt.
////

The output is by default STDOUT, and includes the repository's URL and branch name, a short description of all commits by author, and a diff state, i.e., a balance of added and deleted lines by file.
This output can easily be forwarded to an e-mail program.
If you add the `-p` option, a patch with all changes is appended below the text.


////
Zum Beispiel um jemanden darum zu bitten, die zwei neuesten Commits aus einem Repository herunterzuladen:
////

For example, to ask someone to download the two latest commits from a repository:


[subs="quotes"]
--------
$ *git request-pull HEAD~2 origin*
The following changes since commit d2640ac6a1a552781[...]c48e08e695d53:

  README verbessert (2010-11-20 21:27:20 +0100)

are available in the git repository at:
  git@github.com:esc/git-cheatsheet-de.git master

Valentin Haenel (2):
      Lizenz hinzugefügt
      URL hinzugefügt und Metadaten neu formatiert

 cheatsheet.pdf |  Bin 89513 -> 95619 bytes
 cheatsheet.tex |   18 ++++++++++++++++--
 2 files changed, 16 insertions(), 2 deletions(-)
--------




[[sec.remote-tags]]
== Exchanging Tags
// Tags austauschen

////
Tags werden ebenfalls mit den Remote-Kommandos `fetch` bzw. `pull` und `push` ausgetauscht.
Im Gegensatz zu Branches, die sich verändern, sind Tags jedoch "`statisch`".
Aus diesem Grund werden Remote-Tags nicht noch einmal zusätzlich lokal referenziert, es gibt also kein Äquivalent zu den Remote-Tracking-Branches für die Tags.
Tags, die Sie aus Ihren Remote-Repositories erhalten, speichert Git ganz normal unter `.git/refs/tags/` bzw. `.git/packed-refs`.
////

Tags are also exchanged with the remote commands `fetch` or `pull` and `push`.
In contrast to branches, which change, tags are "`static`".
For this reason, remote tags are not referenced locally again, so there is no equivalent to the remote tracking branches for the tags.
Tags that you get from your remote repositories are stored by Git as `.git/refs/tags/` or `.git/packed-refs`, as usual.



[[sec.tags-download]]
=== Downloading Tags
//  Tags herunterladen

////
Prinzipiell lädt Git neue Tags automatisch bei einem Aufruf von `git fetch` bzw.  `git pull` herunter.
Das heißt, wenn Sie einen Commit herunterladen, auf den ein Tag zeigt, so wird dieses Tag mitgeliefert.
Schließen Sie jedoch mit einem Refspec einzelne Branches aus, so werden Commits in diesen Branches nicht heruntergeladen -- und somit auch keine Tags, die evtl. auf diese Commits zeigen.
Fazit: Git lädt nur relevante Tags herunter.
Mit den Optionen `--no-tags` (keine Tags) und `--tags` bzw. `-t` (alle Tags) passen Sie das Standardverhalten an.
Beachten Sie aber, dass Sie mit `--tags` nicht nur die Tags herunterladen, sondern notwendigerweise auch die Commits, auf die die Tags zeigen.
////

In principle, Git automatically downloads new tags when you call `git fetch` or `git pull`.
That is, if you download a commit that has a tag pointing to it, that tag will be included.
However, if you use a refspec to exclude individual branches, then commits in those branches will not be downloaded, and thus no tags that may point to those commits will be downloaded.
Conclusion: Git only downloads relevant tags.
With the options `--no-tags` (no tags) and `--tags` or `-t` (all tags) you can adjust the default behavior.
Note, however, that `--tags` not only downloads the tags, but necessarily the commits to which they point.


////
Git benachrichtigt Sie, wenn neue Tags eintreffen:
////

Git notifies you when new tags arrive:


[subs="quotes"]
--------
$ *git fetch*
[fetch output]
From git://git.kernel.org/pub/scm/git/git
 * [new tag]         v1.7.4.2   -&gt; v1.7.4.2
--------

////
Wenn Sie wissen wollen, welche Tags auf der Remote-Seite vorhanden sind, verwenden Sie `git ls-remote` mit der Option `--tags`.
Zum Beispiel erhalten Sie alle Release-Candidates der Git-Version `1.7.1` mit folgendem Aufruf:
////

If you want to know what tags are present on the remote side, use `git ls-remote` with the `--tags` option.
For example, you can get all release candidates of git version `1.7.1` with the following call:



[subs="quotes,attributes"]
--------
$ *git ls-remote origin --tags v1.7.1-rc{asterisk}*
bdf533f9b47dc58ac452a4cc92c81dc0b2f5304f    refs/tags/v1.7.1-rc0
537f6c7fb40257776a513128043112ea43b5cdb8    refs/tags/v1.7.1-rc0^{}
d34cb027c31d8a80c5dbbf74272ecd07001952e6    refs/tags/v1.7.1-rc1
b9aa901856cee7ad16737343f6a372bb37871258    refs/tags/v1.7.1-rc1^{}
03c5bd5315930d8d88d0c6b521e998041a13bb26    refs/tags/v1.7.1-rc2
5469e2dab133a197dc2ca2fa47eb9e846ac19b66    refs/tags/v1.7.1-rc2^{}
--------

////
Git gibt die SHA-1-Summen der Tags und deren Inhalt[75] aus.
////

Git outputs the SHA-1 sums of the tags and their contents.{fn75}



[[sec.uploading-tags]]
=== Uploading Tags
//  Tags hochladen

////
Git lädt Tags nicht automatisch hoch.
Sie müssen diese, ähnlich den Branches, explizit an `git push` übergeben, z.B. um das Tag `v0.1` hochzuladen:
////

Git does not automatically upload tags.
You need to pass them explicitly to `git push`, similar to the branches, e.g. to upload the tag `v0.1`:


[subs="quotes"]
--------
$ *git push origin v0.1*
--------


////
Wenn Sie gleich alle Tags hochladen wollen, verwenden Sie die Option `--tags`.
Aber Vorsicht: Vermeiden Sie diese Option, wenn Sie, wie in Abschnitt 3.1.3, "Tags -- Wichtige Versionen markieren" beschrieben, Annotated Tags zur Kennzeichnung von Versionen verwenden und Lightweight Tags, um lokal etwas zu markieren. Denn mit der Option würden Sie, wie schon gesagt, _alle_ Tags hochladen.
////

If you want to upload all tags at once, use the `--tags` option.
But be careful: Avoid this option if you use Annotated Tags to mark versions and Lightweight Tags to mark something locally, as described in <<sec.tags>>, because with this option you would upload _all_ tags, as already mentioned.


////
Achtung: Wenn Sie ein Tag einmal hochgeladen haben, sollten Sie es auf keinen Fall verändern!
Der Grund: Angenommen, Axel verändert ein Tag, etwa `v0.7`, das er bereits veröffentlicht hat.
Zunächst zeigte es auf den Commit `5b6eef` und nun auf `bab18e`.
Beatrice hatte bereits die erste Version, die auf `5b6eef` zeigt, heruntergeladen, Carlos aber noch nicht.
Beim nächsten Mal, wenn Beatrice `git pull` aufruft, lädt Git _nicht_ die neue Version von dem Tag `v0.7` herunter; die Annahme ist, dass sich Tags nicht verändern, und darum überprüft Git die Gültigkeit des Tags nicht!
Führt Carlos nun `git pull` aus, erhält er auch das Tag `v0.7`, das aber jetzt auf `bab18e` zeigt.
Zuletzt sind zwei Versionen des Tags -- die jeweils auf unterschiedliche Commits zeigen -- im Umlauf.
Keine besonders hilfreiche Situation.
Wirklich verwirrend wird es, wenn sowohl Carlos als auch Beatrice dasselbe, öffentliche Repository verwenden und standardmäßig alle Tags hochladen.[76]
Das Tag "`springt`" quasi im öffentlichen Repository zwischen zwei Commits hin und her; welche Version Sie mit einem Klon erhalten, hängt davon ab, wer zuletzt gepusht hat.
////

Attention: Once you have uploaded a tag, you should never change it!
The reason: Let's say Axel changes a tag, like `v0.7`, that he has already released.
First it pointed to the `5b6eef` commit, and now to `bab18e`.
Beatrice had already downloaded the first version pointing to `5b6eef`, but Carlos had not yet.
The next time Beatrice calls `git pull`, Git won't download the new version from the `v0.7` tag; the assumption is that tags don't change, so Git doesn't check the validity of the tag!
When Carlos now runs `git pull`, he also gets the `v0.7` tag, but it now points to `bab18e`.
Finally, two versions of the tag -- each pointing to different commits --- are in circulation.
Not a very helpful situation.
It gets really confusing when both Carlos and Beatrice use the same public repository, and upload all tags by default.{fn76}
The tag "`jumps`" back and forth between two commits in the public repository, so to speak; which version you get with a clone depends on who pushed last.


////
Sollte Ihnen dieses Missgeschick doch einmal passieren, haben Sie zwei Möglichkeiten:
////

If you do get this mishap, you have two options:



////
. Die vernünftige Alternative: Statt das Tag zu ersetzen, erstellen Sie ein neues und laden es ebenfalls hoch.
Benennen Sie das neue Tag entsprechend den Projektkonventionen.
Heißt das alte `v0.7`, nennen Sie das neue etwa `v0.7.1`.

. Wenn Sie das Tag _wirklich_ ersetzen wollen: Geben Sie öffentlich zu (Mailingliste, Wiki, Blog), dass Sie einen Fehler gemacht haben.
Weisen Sie alle Entwickler und Nutzer darauf hin, dass sich ein Tag geändert hat, und bitten Sie darum, dass jeder dieses Tag bei sich überprüft.
Die Größe des Projekts und Ihre Risikobereitschaft entscheiden, ob diese Lösung machbar ist.
////

. The sensible alternative: Instead of replacing the tag, create a new one and upload it as well.
Name the new tag according to the project conventions.
If the old tag is `v0.7`, name the new one something like `v0.7.1`.

. If you really want to replace the tag: Admit publicly (mailing list, wiki, blog) that you made a mistake.
Let all developers and users know that a tag has changed and ask them to check the tag with you.
The size of the project and your willingness to take risks will determine whether this solution is feasible.





[[sec.patch-queue]]
== Patches via E-mail
// Patches per E-Mail

////
Eine Alternative zum Einrichten eines öffentlichen Repositorys ist es, automatisch Patches per E-Mail zu verschicken.
Das Format der E-Mail wird dabei so gewählt, dass die Maintainer die per E-Mail empfangenen Patches automatisch von Git einspielen lassen können.
Gerade für kleine Fehlerkorrekturen und sporadische Mitarbeit ist das meist weniger aufwändig und schneller.
Es gibt viele Projekte, die auf diese Art des Austauschs setzen, allen voran das Git-Projekt selbst.
////

An alternative to setting up a public repository is to automatically send patches via email.
The format of the email is chosen so that maintainers can have Git automatically apply patches received via email.
Especially for small bug fixes and sporadic collaboration, this is usually less time-consuming and faster.
There are many projects that rely on this type of exchange, most notably the Git project itself.


////
Der Großteil der Patches für Git wird über die Mailingliste beigesteuert.
Dort durchlaufen sie einen stringenten Review-Prozess, der meistens zu Korrekturen und Verbesserungen führt.
Die Patches werden vom Autor so lange verbessert und erneut an die Liste geschickt, bis ein Konsens erreicht ist.
Währenddessen speichert der Maintainer die Patches regelmäßig in einem Branch in seinem Repository, und stellt sie über den `pu`-Branch zum Testen bereit.
Sofern die Patch-Serie von den Teilnehmern auf der Liste als fertig betrachtet wird, wandert der Branch über die verschiedenen Integrations-Branches `pu` und `next`, wo die Veränderungen auf Kompatibilität und Stabilität geprüft werden.
Ist alles in Ordnung, landet der Branch schließlich im `master` und bildet von dort aus einen Teil des nächsten Releases.
////

The majority of patches for Git are contributed via the mailing list.
There they go through a stringent review process, which usually leads to corrections and improvements.
The patches are improved by the author and sent back to the list until a consensus is reached.
Meanwhile, the maintainer regularly stores the patches in a branch in his repository, and makes them available for testing via the `pu` branch.
If the patch series is considered finished by the participants on the list, the branch moves on to the different integration branches `pu` and `next`, where the changes are tested for compatibility and stability.
If everything is in order, the branch finally ends up in the `master` and from there forms part of the next release.


////
Der Ansatz _Patches per E-Mail_ wird durch folgende Git-Kommandos realisiert:
////

The approach _patches via e-mail_ is realized by the following git commands:


////
`git format-patch` ::
Commits zum Verschicken als Patches formatieren.

`git send-email` ::
Patches verschicken.

`git am` ::
Patches aus einer Mailbox in den aktuellen Branch einpflegen (__a__pply from __m__ailbox).
////

[horizontal]
`git format-patch` ::
Format commits for sending as patches.

`git send-email` ::
Send patches.

`git am` ::
Add patches from a mailbox to the current branch (__a__pply from __m__ailbox).





[[sec.exporting-patches]]
=== Exporting Patches
//  Patches exportieren

////
Das Kommando `git format-patch` exportiert einen oder mehrere Commits als Patches im Unix-Mailbox-Format und gibt pro Commit eine Datei aus.
Die Dateinamen bestehen aus einer sequenziellen Nummerierung und der Commit-Message und enden auf `.patch`.[77]
Als Argument erwartet das Kommando entweder einen einzelnen Commit oder eine Auswahl wie z.B. `A..B`.
Geben Sie einen einzelnen Commit an, wertet Git dies als die Auswahl von dem Commit bis zum `HEAD`.
////

The `git format-patch` command exports one or more commits as patches in Unix mailbox format and prints one file per commit.
The file names consist of a sequential numbering and the commit message, and end in `.patch`.{fn77}
As an argument, the command expects either a single commit or a range such as `A..B`.
If you specify a single commit, Git will evaluate this as the selection from the commit to the `HEAD`.


// @NOTE: "Formatting three commits..." or "The format of three commits..."?

// .Drei Commits nach  `master` als Patches formatieren
.Formatting three commits to 'master' as patches
image::gitk-screen-format-patch.png[id="fig.gitk-screen-format-patch",scaledwidth="70%",width="70%",align="center"]



////
Abbildung 5.9, "Drei Commits nach master als Patches formatieren" zeigt die Ausgangssituation.
Wir wollen die drei Commits in dem Branch `fix-git-svn-docs`, also alle Commits ab `master`, als Patches exportieren:
////

<<fig.gitk-screen-format-patch>> shows the initial situation.
We want to export the three commits in the `fix-git-svn-docs` branch, that is, all commits from `master`, as patches:


[subs="quotes"]
--------
$ *git format-patch master*
0001-git-svn.txt-fix-usage-of-add-author-from.patch
0002-git-svn.txt-move-option-descriptions.patch
0003-git-svn.txt-small-typeface-improvements.patch
--------


[TIP]
========
////
Um nur den `HEAD` zu exportieren, verwenden Sie die Option `-1`.
Dann erzeugt `format-patch` nur für den ersten Commit einen Patch:
////

To export only the `HEAD`, use option `-1`, and `format-patch` will create a patch for the first commit only:

[subs="quotes"]
--------
$ *git format-patch -1*
0001-git-svn.txt-small-typeface-improvements.patch
--------

////
Das geht auch für beliebige SHA-1-Summen:
////

This also works for any SHA-1 sums:


[subs="quotes"]
--------
$ *git format-patch -1 9126ce7*
0001-git-svn.txt-fix-usage-of-add-author-from.patch
--------
========


////
Die generierten Dateien enthalten unter anderem die Header-Felder `From`, `Date` und `Subject`, die zum Verschicken als E-Mail dienen.
Diese Felder werden anhand der im Commit vorhandenen Information -- Autor, Datum und Commit-Message -- vervollständigt.
Des weiteren enthalten die Dateien eine Diff-Stat-Zusammenfassung sowie die Veränderungen selbst als Patch im Unified-Diff-Format.
Den Zusatz `[PATCH m/n]`[78] in der Betreff-Zeile nutzt Git später, um die Patches in der richtigen Reihenfolge anzuwenden.
////

The generated files contain, among other things, the header fields `From`, `Date` and `Subject`, which are used for sending as e-mail.
These fields are completed using the information available in the commit -- author, date, and commit message.
The files also contain a diff-stat summary and the changes themselves as a patch in unified diff format.
The `[PATCH m/n]` suffix{fn78} in the subject line is used later by Git to apply the patches in the correct order.


////
Es folgt ein entsprechender Ausschnitt:
////

A corresponding excerpt follows:


[subs="quotes"]
--------
$ *cat 0003-git-svn.txt-small-typeface-improvements.patch*
From 6cf93e4dae1e5146242338b1b9297e6d2d8a08f4 Mon Sep 17 00:00:00 2001
From: Valentin Haenel <valentin.haenel@gmx.de>
Date: Fri, 22 Apr 2011 18:18:55 0200
Subject: [PATCH 3/3] git-svn.txt: small typeface improvements

Signed-off-by: Valentin Haenel <valentin.haenel@gmx.de>
Acked-by: Eric Wong <normalperson@yhbt.net>
---
 Documentation/git-svn.txt |    8 ++++----
 1 files changed, 4 insertions(), 4 deletions(-)

diff --git a/Documentation/git-svn.txt b/Documentation/git-svn.txt
...
--------

////
Wenn Sie vorhaben, eine Serie von Patches zu verschicken, ist es empfehlenswert, mit der Option `--cover-letter` eine Art "`Deckblatt`" zu erzeugen, in dem Sie die Serie beschreiben.
Die Datei heißt standardmäßig `0000-cover-letter.patch`.
Abgesehen von den Standard-Headern, sieht eine solche Datei wie folgt aus:
////

If you plan to send a series of patches, it is recommended that you use the `--cover-letter` option to create a kind of "`cover page`" in which you describe the series.
By default the file is called `0000-cover-letter.patch`.
Apart from the default headers, such a file looks like this:


--------
Subject: [PATCH 0/3] *** SUBJECT HERE ***

*** BLURB HERE ***

Valentin Haenel (3):
  git-svn.txt: fix usage of --add-author-from
  git-svn.txt: move option descriptions
  git-svn.txt: small typeface improvements

 Documentation/git-svn.txt |   22 +++++++++++-----------
 1 files changed, 11 insertions(+), 11 deletions(-)
--------

////
Wie Sie sehen, ist im `Subject:` noch das Präfix `[PATCH 0/3]` eingetragen; so sehen alle Empfänger sofort, dass es sich um ein Deckblatt handelt.
Außerdem enthält die Datei die Ausgabe von `git shortlog` sowie `git diff --stat`.
Ersetzen Sie `*** SUBJECT HERE ***` durch einen Betreff und `*** BLURB HERE ***` durch eine Zusammenfassung der Patch-Serie.
Verschicken Sie die Datei zusammen mit den Patch-Dateien.
////


As you can see, the `Subject:` still has the prefix `[PATCH 0/3]`; this way, all recipients can immediately see that it is a cover page.
The file also contains the output of `git shortlog` and `git diff --stat`.
Replace `*** SUBJECT HERE ***` with a subject and `*** BLURB HERE ***` with a summary of the patch series.
Send the file together with the patch files.


[TIP]
================================
////
Häufig werden Mailing-Listen, auf die Patches geschickt werden, dazu verwendet, die Patches inhaltlich und syntaktisch zu kritisieren und den Autor um Verbesserung zu bitten.
Hat der Autor die Verbesserungen vorgenommen, schickt er die korrigierte Serie als _Reroll_ erneut an die Liste.
Je nach Größe der Patch-Serie und Anforderungen des Projektes kann eine Patch-Serie durchaus mehrere Rerolls durchlaufen, bis sie angenommen wird.
////

Frequently, mailing lists to which patches are sent are used to criticize the patches in terms of content and syntax and to ask the author for improvement.
Once the author has made the improvements, he sends the corrected series back to the list as a _reroll_.
Depending on the size of the patch series and the requirements of the project, a patch series may go through several rerolls until it is accepted.


////
Wenn Sie eine Patch-Serie an eine Mailing-Liste schicken: Halten Sie die Commits auf einem eigenen Branch vor, und arbeiten Sie die Korrekturen in neuen Commits (bei fehlender Funktionalität) oder mit interaktivem Rebase (zum Anpassen bestehender Commits) ein.
Verwenden Sie anschließend das Kommando `git format-patch` mit der Option `--reroll-count=<n>` (oder kurz `-v <n>`): Sie erzeugen so Patches, die als Subject-Zeile z.B. `[PATCH v2]` tragen und machen so deutlich, dass es sich um den ersten Reroll dieser Serie handelt.
////

When you send a patch series to a mailing list: Keep the commits on a separate branch, and incorporate the fixes in new commits (for missing functionality) or with interactive rebase (to adjust existing commits).
Then use the `git format-patch` command with the `--reroll-count=<n>` option (or `-v <n>` for short): this will create patches with `[PATCH v2]` as the subject line, making it clear that this is the first reroll in the series.
================================




// @NOTE: "Sending Patches" or "Submitting Patches"??
[[sec.sending-patches]]
=== Sending Patches
//  Patches versenden

////
Versenden Sie die generierten Dateien mit `git send-email` (oder einem E-Mail-Client Ihrer Wahl).
Das Kommando erwartet als einziges zwingendes Argument entweder eine oder mehrere Patch-Dateien, ein Verzeichnis voller Patches oder aber eine Auswahl von Commits (in dem Fall ruft Git zusätzlich intern `git format-patch` auf):
////

Send the generated files with `git send-email` (or an email client of your choice).
The command expects as its only mandatory argument either one or more patch files, a directory full of patches, or a selection of commits (in which case Git also calls `git format-patch` internally):


[subs="quotes,attributes"]
--------
$ *git send-email 000{asterisk}*
0000-cover-letter.patch
0001-git-svn.txt-fix-usage-of-add-author-from.patch
0002-git-svn.txt-move-option-descriptions.patch
0003-git-svn.txt-small-typeface-improvements.patch
Who should the emails appear to be from? [Valentin Haenel
&lt;valentin.haenel@gmx.de&gt;]

$ *git send-email master*
/tmp/HMSotqIfnB/0001-git-svn.txt-fix-usage-of-add-author-from.patch
/tmp/HMSotqIfnB/0002-git-svn.txt-move-option-descriptions.patch
/tmp/HMSotqIfnB/0003-git-svn.txt-small-typeface-improvements.patch
Who should the emails appear to be from? [Valentin Haenel
&lt;valentin.haenel@gmx.de&gt;]
--------

////
Das Kommando `git send-email` setzt die Felder `Message-Id` sowie `In-Reply-To`.
Damit sehen alle E-Mails nach der ersten wie Antworten auf diese aus und werden dadurch von den meisten Mail-Programmen als zusammenhängender _Thread_ angezeigt:[79]
////

The command `git send-email` sets the fields `Message-Id` and `In-Reply-To`.
This makes all e-mails after the first one look like replies to them and thus most mail programs will display them as a continuous _thread_:{fn79}


// .Patch-Serie als Mail-Thread
.Patch series as mail thread
image::mail-thread.png[id="fig.mail-thread",scaledwidth="100%",width="100%",align="center"]


////
Das Kommando können Sie über Optionen -- beispielsweise `--to`, `--from` und `--cc` -- anpassen (siehe die Man-Page `git-send-email(1)`).
Die unbedingt benötigten Angaben werden aber, sofern nicht angegeben, interaktiv abgefragt -- vor allem wird eine Adresse benötigt, an die die Patches geschickt werden sollen.[80]
////

You can customize the command with options such as `--to`, `--from` and` --cc` (see the `git-send-email(1)` man page).
However, if not specified, the essential information is queried interactively -- most important is an address to which the patches should be sent.{fn80}


////
Bevor die E-Mails tatsächlich versendet werden, wird Ihnen der Header nochmals angezeigt; Sie sollten überprüfen, ob alles Ihren Wünschen entspricht, und anschließend die Frage `Send this email?  ([y]es|[n]o|[q]uit|[a]ll):` mit `y` für "`yes`" beantworten.
Um sich mit dem Kommando vertraut zu machen, kann man zunächst alle E-Mails nur an sich selbst schicken oder die Option `--dry-run` verwenden.
////

Before the emails are actually sent, you will see the header again; you should check if everything is as you want it, and then answer  the question` Send this email? ([y]es|[n]o|[q]uit|[a]ll):` answer with `y` for "`yes`".
To get familiar with the command, you can first send all emails only to yourself or use the `--dry-run` option.


[TIP]
========
////
Alternativ zu `git send-email` können Sie den Inhalt der Dateien in einen der vielen online _Pastebin_-Dienste, zum Beispiel _dpaste_[81] oder _gist.github_[82] einwerfen und den Verweis darauf per IRC oder Jabber verschicken.
Zum Einpflegen lädt sich der Empfänger den Inhalt in eine Datei herunter und übergibt diese an `git am` (s.u.).
////

As an alternative to `git send-email`, you can post the contents of the files to one of the many online _pastebin_ services, for example _dpaste_{fn81} or _gist.github_{fn82}, and send the reference to it via IRC or Jabber.
For pastebin, the recipient downloads the content into a file and submits it via `git am` (see below).
========

////
Wenn Sie Ihren bevorzugten _Mail User Agent_ (MUA) (z.B. Thunderbird, Kmail o.a.) verwenden wollen, um Patches zu verschicken, gibt es eventuell einiges zu beachten.
Manche MUAs sind berüchtigt, Patches so zu verstümmeln, dass sie Git nicht mehr als solche erkennt.[83]
////

If you want to use your preferred _Mail User Agent_ (MUA) (e.g. Thunderbird, Kmail or others) to send patches, there may be a few things to consider.
Some MUAs are notorious for mutilating patches so that Git won't recognize them as such.{fn83}



[[sec.applying-patches]]
=== Applying Patches
//  Patches einpflegen

////
Mit `git format-patch` exportierte Patch-E-Mails werden von dem Git-Kommando `git am` (_apply from mailbox_) wieder in Commits zurückübersetzt.
Aus jeder E-Mail wird ein neuer Commit erzeugt, dessen Meta-Informationen (Autor, Commit-Message usw.) aus den Header-Zeilen der E-Mail (`From`, `Date`) generiert werden.
Wie schon erwähnt, erkennt Git an der Nummer im Subject, in welcher Reihenfolge die Commits einzupflegen sind.
Um das Beispiel von vorhin zu vollenden: Befinden sich die E-Mails im Maildir-Verzeichnis `patches`, dann reicht:
////

Patch emails exported with `git format-patch` are translated back into commits by the git command `git am` (_apply from mailbox_).
A new commit is created from each email, and its meta-information (author, commit message, etc.) is generated from the email header lines (`From`, `Date`).
As mentioned earlier, Git uses the number in the subject to determine the order in which the commits should be entered.
To complete the example from earlier: If the emails are in the Maildir directory `patches`, then that's enough:

[subs="quotes"]
--------
$ *git am patches*
Applying: git-svn.txt: fix usage of --add-author-from
Applying: git-svn.txt: move option descriptions
Applying: git-svn.txt: small typeface improvements
--------


[TIP]
========
////
Das Kommando versteht neben den Formaten _Maildir_ und _mbox_ auch Dateien, die die Ausgabe von `git format-patch` enthalten:
////

The command understands _Maildir_ and _mbox_ formats as well as files that contain the output of `git format-patch`:

[subs="quotes"]
--------
$ *git \*
  *am 0001-git-svn.txt-fix-usage-of-add-author-from.patch*
Applying: git-svn.txt: fix usage of --add-author-from
--------
========

////
Wenn Sie Patches von Anderen mit `git am` einpflegen, unterscheiden sich die Werte von _Author_/_AuthorDate_ und _Committer_/_CommitDate_.
Somit werden sowohl der Autor des Commits als auch der, der ihn einspielt, gewürdigt.
Insbesondere bleiben die Attribuierungen erhalten; es bleibt nachvollziehbar, wer welche Codezeilen geschrieben hat.
Mit Gitk werden die Author- und Committer-Werte standardmäßig angezeigt; auf der Kommandozeile setzen Sie die Option `--format=fuller` ein, die unter anderem von `git log` und `git show` akzeptiert wird:
////

When you apply patches from others using `git am`, the values of _Author_/_AuthorDate_ and _Committer_/_CommitDate_ are different.
This means that both the author of the commit and the person who commits it are honored.
In particular, the attributes are retained; it remains traceable who wrote which lines of code.
With Gitk, the author and committer values are displayed by default; on the command line, set the `--format=fuller` option, which is accepted by `git log` and `git show`, among others:


[subs="quotes"]
--------
$ *git show --format=fuller  12d3065*
commit 12d30657d411979af3ab9ca7139b5290340e4abb
Author:     Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
AuthorDate: Mon Apr 25 23:36:15 2011 +0200
Commit:     Junio C Hamano &lt;gitster@pobox.com&gt;
CommitDate: Tue Apr 26 11:48:34 2011 -0700

    git-svn.txt: fix usage of --add-author-from
--------



////
Bei dem Workflow _Dictator and Lieutenants_ (Abschnitt 5.10, "Ein verteilter, hierarchischer Workflow") kommt es vor, dass mehr als nur zwei Personen in einen Commit involviert sind.
In dem Fall ist es sinnvoll, dass jeder, der den Patch begutachtet, ihn auch "`absegnet`", allen voran der Autor.
Zu diesem Zweck gibt es die Option `--signoff` (kurz `-s`) für die Kommandos `git commit` und `git am`, die Name und E-Mail des Committers der Commit-Message anhängt:
////

With the _Dictator and Lieutenants_ Workflow (<<sec.dictator>>), it can happen that more than two people are involved in a commit.
In this case, it makes sense that everyone who reviews the patch also "`approves`" it, especially the author.
For this purpose, there is a `--signoff` option (`-s` for short) for the `git commit` and `git am` commands, which appends the committer's name and email to the commit message:


--------
Signed-off-by: Valentin Haenel <valentin.haenel@gmx.de>
--------

////
Das Feature ist vor allem bei größeren Projekten von Vorteil, meist haben diese auch Richtlinien, wie Commits zu formatieren sind und wie sie am besten verschickt werden.[84]
////

This feature is especially useful for larger projects, which usually have guidelines on how to format commits and how best to send them.{fn84}


////
Beim Einpflegen von Patches mit `git am` kann es zu Konflikten kommen, z.B. wenn die Patches auf einer älteren Version beruhen und die betreffenden Zeilen bereits verändert wurden.
In dem Fall wird der Prozess unterbrochen und Sie haben dann mehrere Möglichkeiten, wie Sie weiter vorgehen.
Entweder Sie lösen den Konflikt, aktualisieren den Index und führen den Prozess mit `git am --continue` fort, oder Sie überspringen den Patch mit `git am --skip`.
Mit `git am --abort` brechen Sie den Prozess ab und stellen den ursprünglichen Zustand des aktuellen Branches wieder her.
////

Conflicts can occur when patches are entered with `git am`, e.g. if the patches are based on an older version and the lines concerned have already been changed.
In this case, the process is interrupted and you then have several options for how to proceed.
Either resolve the conflict, update the index and continue the process with `git am --continue`, or skip the patch with `git am --skip`.
Use `git am --abort` to abort the process and restore the current status of the branch.


////
Da die Patches meist Veränderungen von Anderen enthalten, kann es mitunter schwierig sein, die richtige Lösung für einen Konflikt zu finden.
Die beste Strategie für Patches, die sich nicht anwenden lassen, ist es, den Autor der Patches zu bitten, diese per Rebase auf eine wohldefinierte Basis, bspw. den aktuellen `master`, aufzubauen und erneut zu schicken.
////

Because patches usually contain changes made by others, it can sometimes be difficult to find the right solution to a conflict.
The best strategy for patches that cannot be applied is to ask the author of the patches to rebase them to a well-defined base, such as the current `master`, and send them again.


[TIP]
========
////
Eine Alternative zu `git am` ist das etwas rudimentäre Kommando `git apply`.
Es dient dazu, einen Patch auf den Working Tree oder Index (mit der Option `--index`) anzuwenden.
Es ähnelt so dem klassischen Unix-Kommando `patch`.
Es ist vor allem dann nützlich, wenn Sie den Patch bzw. die Metadaten vor dem Commit noch bearbeiten wollen oder auch wenn Ihnen jemand die Ausgabe von `git diff` statt `git format-patch` als Patch geschickt hat.
////

An alternative to `git am` is the somewhat rudimentary command `git apply`.
It is used to apply a patch to the working tree or index (with the `--index` option).
It is similar to the classic Unix command `patch`.
It is especially useful if you want to edit the patch or metadata before committing, or if someone has sent you the output of `git diff` instead of `git format-patch` as a patch.
========





[[sec.dictator]]
== A Distributed, Hierarchical Workflow
// Ein verteilter, hierarchischer Workflow

////
Der Integration-Manager-Workflow skaliert nicht mit der Größe des Projekts.
Bei großem Wachstum ist irgendwann der Maintainer mit der Komplexität des Projekts und der Anzahl der eingehenden Patches überfordert.
Der sog. _Dictator and Lieutenants_-Workflow, der ausgiebig bei der Entwicklung des Linux-Kerns angewandt wird, schafft hier Abhilfe.
In diesem Fall ist die Software meist in verschiedene Subsysteme unterteilt, und Beiträge werden von den _Lieutenants_ (auch _Subsystem-Maintainer_) untersucht und dann an den _Benevolent Dictator_ ("`Gütiger Diktator`") weitergeleitet.
Dieser lädt die Veränderungen schließlich in das _blessed_ ("`gesegnete`") Repository hoch, mit dem sich wiederum alle Mitstreiter synchronisieren.
////

The Integration Manager workflow does not scale with the size of the project.
With large growth, at some point the maintainer is overwhelmed by the complexity of the project and the number of incoming patches.
The so-called _Dictator and Lieutenants_ workflow, which is used extensively in the development of the Linux kernel, provides a remedy.
In this case, the software is usually divided into different subsystems, and contributions are examined by the _lieutenants_ (also _subsystem maintainers_) and then forwarded to the _Benevolent Dictator_.
The Benevolent Dictator uploads the changes to the _blessed_ repository, which in turn is synchronized with all other participants.



// @TRANSLATE IMAGE TEXT
.Workflow: _Dictator and Lieutenants_
image::patches-via-email.svg[id="fig.dictator",scaledwidth="90%",width="90%",align="center"]


////
Der Workflow basiert auf Vertrauen: Der Diktator vertraut seinen Lieutenants und übernimmt deren weitergeleitete Modifikationen meist ohne Kontrolle.
Vorteil ist, dass der Diktator entlastet wird, aber trotzdem ein Vetorecht behält, was zu dem Titel Benevolent Dictator führte.
////

The workflow is based on trust: The dictator trusts his lieutenants and usually takes over their forwarded modifications without control.
The advantage is that the dictator is exonerated, but still retains a veto right, which led to the title Benevolent Dictator.


////
Historisch bedingt ist das offizielle Repository oft nur das öffentliche Repository des aktuellen Haupt-Maintainers oder des Original-Autors.
Wichtig ist, dass dieses Repository nur aufgrund sozialer Konventionen existiert.
Sollte eines Tages ein anderer Entwickler das Projekt besser vorantreiben, kann es sein, dass sein öffentliches Repository das neue Blessed Repository wird.
Aus technischer Sicht spricht nichts dagegen.
////

For historical reasons, the official repository is often only the public repository of the current main maintainer or the original author.
It is important to note that this repository exists only because of social conventions.
Should another developer one day better advance the project, his public repository may become the new Blessed Repository.
From a technical point of view, there is no reason not to do so.


////
Die Projekte, die in der Praxis diesen Workflow einsetzen, favorisieren den Patch-Austausch per Mail.
Jedoch ist die Art des Austauschs eher zweitrangig, und die Subsystem-Maintainer könnten genauso gut Pull-Requests von den ihnen bekannten Entwicklern erhalten; oder aber die Mitstreiter mischen ganz nach Belieben öffentliche Repositories und per E-Mail verschickte Patches.
Die Flexibilität von Git -- insbesondere die Vielzahl von verschiedenen Methoden zum Austausch von Veränderungen -- unterstützen jeden erdenklichen Workflow im Sinne der freien, offenen Entwicklung.
Sicherlich eine Eigenschaft, die maßgeblich zur Beliebtheit von Git beigetragen hat.
////

The projects that use this workflow in practice prefer to exchange patches by mail.
However, the nature of the exchange is secondary, and subsystem maintainers may just as well receive pull requests from developers they know; or they may mix public repositories and patches sent by email at will.
Git's flexibility -- especially the variety of different methods for exchanging changes -- supports every conceivable workflow in the spirit of free, open development.
Certainly a feature that has contributed greatly to Git's popularity.




[[sec.subprojects]]
== Managing Subprojects
// Unterprojekte verwalten

////
Bei größeren Softwareprojekten ist es bisweilen nötig, bestimmte Teile eines Programms in eigene Projekte auszulagern.
Das ist zum Beispiel in den folgenden Situationen der Fall:
////

For larger software projects, it is sometimes necessary to outsource certain parts of a program into separate projects.
This is the case in the following situations, for example:


////
* Ihre Software hängt von einer bestimmten Version einer Bibliothek ab, die Sie mit dem Quellcode zusammen ausliefern wollen.
////

* Your software depends on a specific version of a library that you want to ship with the source code.

////
* Ihr anfänglich kleines Projekt wird mit der Zeit so groß, dass Sie die Funktionalität in eine Bibliothek auslagern wollen, die als eigenständiges Projekt verwaltet werden soll.
////

* Your initially small project grows so large over time that you want to move functionality to a library that you want to manage as a separate project.

////
* Eigenständige Teile Ihrer Software werden von anderen Entwicklergruppen verwaltet.
////

* Independent parts of your software are managed by other development groups.



////
Mit Git können Sie auf zwei verschiedene Weisen damit umgehen: Sie verwalten die Module als sogenannte _Git-Submodules_ oder als _Subtrees_ -- in beiden Fällen verwalten Sie Quellcode in einem Unterverzeichnis Ihres Projekts.
////

With Git, you can use it in two different ways: You can manage the modules as _Git submodules_ or as _subtrees_ -- in either case, you manage source code in a subdirectory of your project.


////
Als Submodule verwalten Sie ein abgekoppeltes Repository, das nichts mit Ihrem übergeordneten Repository zu tun hat.
Arbeiten Sie stattdessen mit Subtrees, dann wird die Projektgeschichte des Unterverzeichnisses untrennbar mit dem übergeordneten Projekt verbunden.
Beides hat Vor- und Nachteile.
////

As submodules, you manage an isolated repository that has nothing to do with your parent repository.
If you work with subtrees instead, the project history of the subdirectory becomes inseparable from the parent project.
Both have advantages and disadvantages.


////
Wir betrachten beide Techniken beispielhaft, indem wir ein fiktionales Projekt erstellen, das die `libgit2` benötigt.
Die Bibliothek bietet, ähnlich der `libgit.a`, eine API, um Git-Repositories zu untersuchen und zu verändern.[85]
Die in C geschriebene Bibliothek kann ihre Funktionen u.a. auch nach Lua, Ruby, Python, PHP und JavaScript herausreichen.
////

We'll look at both techniques by way of example, creating a fictional project that requires `libgit2`.
The library provides, similar to `libgit.a`, an API to examine and modify Git repositories.{fn85}
The library, written in C, can extend its functions to Lua, Ruby, Python, PHP and JavaScript, among others.





[[sec.submodules]]
=== Submodules

////
Submodules werden von Git als Unterverzeichnisse verwaltet, die einen speziellen Eintrag in der Datei `.gitmodules` besitzen.
Zuständig für den Umgang mit ihnen ist das Kommando `git submodule`.
////

Submodules are managed by Git as subdirectories that have a special entry in the `.gitmodules` file.
The command `git submodule` is responsible for handling them.

////
Zunächst müssen wir die Bibliothek importieren.
Das geschieht mit dem folgenden Kommando:
////

First we need to import the library.
This is done with the following command:


[subs="quotes"]
--------
$ *git submodule add git://github.com/libgit2/libgit2.git libgit2*
Cloning into libgit2...
remote: Counting objects: 4296, done.
remote: Compressing objects: 100% (1632/1632), done.
remote: Total 4296 (delta 3214), reused 3530 (delta 2603)
Receiving objects: 100% (4296/4296), 1.92 MiB | 788 KiB/s, done.
Resolving deltas: 100% (3214/3214), done.
--------


////
An der Ausgabe von `git status` können wir nun erkennen, dass ein neues Verzeichnis `libgit2` vorliegt, sowie die Datei `.gitmodules` mit folgendem Inhalt erstellt wurde:
////

From the output of `git status` we can now see that there is a new directory `libgit2` and that the file `.gitmodules` with the following content has been created


--------
[submodule "libgit2"]
  path = libgit2
  url = git://github.com/libgit2/libgit2.git
--------

////
Diese Datei wurde auch schon dem Index hinzugefügt, also für den Commit vorbereitet.
Das Verzeichnis `libgit2` hingegen taucht in der Ausgabe von `git diff --staged` nicht wie gewohnt auf:
////

This file has already been added to the index, prepared for committing.
The `libgit2` directory, on the other hand, does not appear in the output of `git diff --staged` as usual:


[subs="quotes"]
--------
$ *git diff --staged -- libgit2*
diff --git a/libgit2 b/libgit2
new file mode 160000
index 0000000..b64e11d
--- /dev/null
+++ b/libgit2
@@ -0,0 +1 @@
+Subproject commit 7c80c19e1dffb4421f91913bc79b9cb7596634a4
--------


////
Anstatt alle Dateien des Verzeichnisses aufzulisten, speichert Git eine "`spezielle`" Datei (erkennbar an dem unüblichen Datei-Modus `160000`), die lediglich den Commit, auf dem das Modul gerade steht, festhält.
////

Instead of listing all the files in the directory, Git saves a "`special`" file (recognizable by the unusual file mode `160000`) that simply records the commit the module is currently on.


////
Wir importieren diese Änderungen und können von nun an die `libgit2` in ihrem Unterverzeichnis kompilieren und dann gegen sie linken:
////

We import these changes, and from now on we can compile `libgit2` in its subdirectory and then link against it:


[subs="quotes"]
--------
$ *git commit -m "libgit2-submodule importiert"*
--------


////
Das übergeordnete Projekt und die `libgit2` sind nun im Working Tree zusammengeführt -- ihre Versionsgeschichte aber ist und bleibt getrennt.
In dem Git-Repository der `libgit2` können Sie sich genau so verhalten wie in einem "`echten`" Repository.
Sie können sich zum Beispiel die Ausgabe von `git log` in dem übergeordneten Projekt und nach einem `cd libgit2` in dem Submodule anschauen.
////

The parent project and `libgit2` are now merged in the working tree, but their version history is and remains separate.
In the Git repository of `libgit2` you can behave exactly the same way as in a "`real`" repository.
For example, you can look at the output of `git log` in the parent project and after a `cd libgit2` in the submodule.





[[sec.submodule-mod]]
==== Changes in Submodules
//   Änderungen im Submodule

////
Nun hat die `libgit2` als Default-Branch (also der `HEAD` auf der Serverseite) den Branch `development` ausgewählt.
Es ist möglicherweise nicht die beste Idee, diesen Entwicklungsbranch mehr oder weniger mit Ihrem Repository zu verdrahten.
////

Now `libgit2` has selected the branch development as default branch (i.e. the `HEAD` on the server side).
It may not be the best idea to more or less wire this development branch to your repository.

////
Wir wechseln also in das Verzeichnis `libgit2` und checken das neueste Tag aus, `v0.10.0`:
////

So we change to the `libgit2` directory and check out the latest tag, `v0.10.0`:


// @TRANSLATE GIT LOG?

[subs="quotes"]
--------
$ *cd libgit2*
$ *git checkout v0.10.0*
# Nachricht über "detached HEAD state"
$ *cd ..*
$ *git diff*
diff --git a/libgit2 b/libgit2
index 7c80c19..7064938 160000
--- a/libgit2
+++ b/libgit2
@@ -1 +1 @@
-Subproject commit 7c80c19e1dffb4421f91913bc79b9cb7596634a4
+Subproject commit 7064938bd5e7ef47bfd79a685a62c1e2649e2ce7
--------

////
Das übergeordnete Git-Repository sieht also einen Wechsel des `HEAD`, der durch das Kommando `git checkout v0.10.0` in `libgit2/` passiert ist, als Änderung der Pseudo-Datei `libgit2`, die nun auf den entsprechenden neuen Commit zeigt.
////

So the parent Git repository sees a change of `HEAD`, which was done by the `git checkout v0.10.0` command in `libgit2/`, as a change to the pseudo-file `libgit2`, which now points to the corresponding new commit.

////
Jetzt können wir diese Änderung dem Index hinzufügen und als Commit abspeichern:
////

Now we can add this change to the index and save it as a commit:


// @TRANSLATE GIT LOG?

[subs="quotes"]
--------
$ *git add libgit2*
$ *git commit -m "Libgit2-Version auf v0.10.0 setzen"*
--------

////
Achtung: Fügen Sie niemals _Dateien_ aus `libgit2` oder das _Verzeichnis_ `libgit2/` (endet mit Slash) hinzu -- das zerbricht das Modulkonzept von Git, Sie verwalten dann auf einmal Dateien aus dem Submodule in dem übergeordneten Projekt.
////

Attention: Never add _files_ from `libgit2` or the _directory_ `libgit2/` (ends with slash) -- this breaks the modular concept of Git, you will suddenly manage files from the submodules in the parent project.

////
Analog können Sie per `submodule update` (oder `git remote update` im Verzeichnis `libgit2/`) neue Commits runterladen und ein Update der Bibliothek entsprechend im übergeordneten Repository festhalten.
////

Similarly, you can use `submodule update` (or `git remote update` in the `libgit2/` directory) to download new commits and record a library update in the parent repository accordingly.





[[sec.submodule-userview]]
==== From a User Perspective
//   Aus Sicht eines Nutzers

////
Wie sieht das Ganze nun aus Sicht eines Nutzer aus, der das Projekt zum ersten Mal klont?
Zunächst ist offensichtlich, dass das oder die Submodules _nicht_ fest mit dem Repository verbunden sind und nicht mit ausgeliefert werden:
////

So what does it all look like from the perspective of a user cloning the project for the first time?
First, it's obvious that the submodule(s) are _not_ hard-coded into the repository and are not shipped with it:


[subs="quotes"]
--------
$ *git clone /dev/shm/super clone-super*
$ *cd clone-super*
$ *ls*
bar.c  foo.c  libgit2/
$ *ls -l libgit2*
total 0
--------

////
Das Verzeichnis `libgit2/` ist leer.
Alles, was Git also über die Submodules weiß, steckt in der Datei `.gitmodules`.
Sie müssen dieses Modul erst initialisieren und dann das Repository des Moduls herunterladen:
////

The directory `libgit2/` is empty.
So everything Git knows about the submodules is in the `.gitmodules` file.
You need to initialize this module first and then download the module's repository:


[subs="quotes"]
--------
$ *git submodule init*
Submodule 'libgit2' (git://github.com/libgit2/libgit2.git)
registered for path 'libgit2'
$ *git submodule update*
...
Submodule path 'libgit2': checked out '7064938bd5e7ef47bfd79a685a62c1e2649e2ce7'
--------

////
Wir sehen also, dass `libgit2` automatisch auf den in unserem Repository festgelegten Stand von `v0.10.0` gesetzt wird.
Prinzipiell kann nun aber der Nutzer auch in das Verzeichnis wechseln, den Branch `development` auschecken und das Projekt gegen diese Version kompilieren.
Submodules erhalten die Flexibilität des Unter-Repositorys -- der Eintrag, auf welchem Stand das Modul steht, ist also nur eine "`Empfehlung`".
////

So we see that `libgit2` is automatically set to the `v0.10.0` version  defined in our repository.
But in principle the user can now also change to the directory, check out the branch `development` and compile the project against this version.
Submodules get the flexibility of the sub-repository -- so the entry on which state the module is on is only a "`recommendation`".




[[sec.subtrees]]
=== Subtrees

////
Im Gegensatz zu Submodules, die ihren Charakter als eigenständiges Git-Repository wahren, verschmelzen Sie die Geschichte zweier Projekte direkt, wenn Sie mit Subtrees arbeiten.
Eine Gegenüberstellung beider Ansätze folgt im Anschluss.
////

Unlike submodules, which maintain their character as a standalone Git repository, when you work with Subtrees, you directly merge the history of two projects.
A comparison of the two approaches follows.


////
Im Wesentlichen basiert diese Technik auf sogenannten Subtree-Merges, auf die schon kurz in Abschnitt 3.3.3, "Merge-Strategien" über Merge-Strategien eingegangen wurde.
In unserem Beispiel erfolgt ein Subtree-Merge, indem reguläre Commits aus dem Repository der `libgit2` unterhalb des _Trees_ (Verzeichnisses) `libgit2/` gemergt werden -- eine Datei auf oberster Ebene in dem Repository der Bibliothek wird also zu einer Datei auf oberster Ebene des Trees `libgit2/`, der wiederum Teil eines Repositorys ist.
////

Essentially, this technique is based on so-called subtree-merges, which were briefly discussed in <<sec.merge-strategies>> about merge strategies.
In our example, a subtree-merge is done by merging regular commits from the `libgit2` repository under the `libgit2/` _tree_ (directory) -- a top-level file in the library repository thus becomes a top-level file in the `libgit2/` tree, which in turn is part of the repository.


////
Git verfügt über ein Kommando, um Subtree-Merges zu verwalten.[86]
Dabei müssen Sie immer explizit durch `-P <prefix>` angeben, auf welches Unterverzeichnis Sie sich beziehen.
Um die `libgit2` in Version 0.8.0 zu importieren, verwenden Sie:
////

Git has a command to manage subtree-merges.{fn86}
You must always explicitly specify which subdirectory you are referring to by using `-P <prefix>`.
To import the `libgit2` in version 0.8.0, use:



[subs="quotes"]
--------
$ *git subtree add -P libgit2 \*
  *git://github.com/libgit2/libgit2.git v0.8.0*
git fetch git://github.com/libgit2/libgit2.git v0.8.0
From git://github.com/libgit2/libgit2
 * tag               v0.8.0     -&gt; FETCH_HEAD
Added dir 'libgit2'
--------

////
Das Kommando lädt automatisch alle benötigten Commits herunter und erzeugt einen Merge-Commit, der alle Dateien der `libgit2` unterhalb des Verzeichnisses `libgit2/` erstellt.
Der Merge-Commit verknüpft nun die bisherige Versionsgeschichte mit der der `libgit2` (dadurch, dass ein Original-Commit referenziert wird und der wiederum andere Commits referenziert).
////

The command automatically downloads all required commits and creates a merge commit that creates all the files of `libgit2` under the directory `libgit2/`.
The merge commit now links the previous version history to that of `libgit2` (by referencing an original commit and then referencing other commits).


////
Dieses Vorgehen hat nun zur Folge, dass in Ihrem Repository von nun an _alle_ relevanten Commits der `libgit2` vorhanden sind.
Ihr Repository hat also nun zwei Root-Commits (siehe auch Multi-Root-Repositories in Abschnitt 4.7, "Mehrere Root-Commits").
////

The result of this procedure is that your repository now contains all relevant commits from `libgit2`.
Your repository now has two root commits (see also multi-root repositories in <<sec.multi-root>>).


////
Die Dateien liegen nun untrennbar mit dem Projekt verbunden vor.
Ein `git clone` dieses Repositorys würde auch alle Dateien unterhalb von `libgit2` übertragen.[87]
////

The files are now stored inseparably linked to the project.
A `git clone` of this repository would also transfer all files under libgit2.{fn87}


////
Was passiert nun, wenn Sie ein "`Upgrade`" auf `v0.10.0` machen wollen?
Verwenden Sie dafür das `pull`-Kommando von `git subtree`:
////

Now what happens when you want to "`upgrade`" to `v0.10.0`?
Use the `pull` command from `git subtree` for this:


[subs="quotes"]
--------
$ *git subtree -P libgit2 \*
  *pull git://github.com/libgit2/libgit2.git v0.10.0*
From git://github.com/libgit2/libgit2
 * tag               v0.10.0    -&gt; FETCH_HEAD
Merge made by the 'recursive' strategy.
...
--------


////
Beachten Sie: Da die Original-Commits der `libgit2` vorliegen, ändern diese Commits auch scheinbar Dateien auf oberster Ebene (z.B. `COPYING`, wenn Sie per `git log --name-status` die Versionsgeschichte untersuchen). Tatsächlich werden diese Änderungen aber in `libgit2` ausgeführt -- dafür ist der jeweilige Merge-Commit verantwortlich, der die Trees entsprechend ausrichtet.
////

Note: Since the original `libgit2` commits are present, these commits also seem to change top-level files (e.g., `COPYING` when you use `git log --name-status` to examine the version history).
In fact, these changes are actually made in `libgit2`, which is the responsibility of the merge commit, which aligns the trees accordingly.


[TIP]
===============================
////
Wenn Sie nicht an der Versionsgeschichte eines Unterprojektes interessiert sind, aber einen bestimmten Stand im Repository verankern wollen, können Sie die Option `--squash` verwenden.
Die Kommandos `git subtree add/pull` mergen dann nicht die entsprechenden Commits, sondern erzeugen nur _einen_ Commit, der alle Änderungen enthält.
Achtung: Verwenden Sie diese Option nicht, wenn Sie das Projekt nicht auch per `--squash` importiert haben; dies führt zu Merge-Konflikten.
////

If you're not interested in the version history of a subproject, but want to anchor a particular state in the repository, you can use the `--squash` option.
The `git subtree add`/`pull` commands then do not merge the corresponding commits, but only create a _single_ commit that contains all changes.
Note: Do not use this option unless you have also imported the project using `--squash`; this will cause merge conflicts.
===============================



[[sec.split-off-subtree]]
==== Splitting off a Subdirectory
//   Ein Unterverzeichnis abspalten

////
Möglicherweise stehen Sie irgendwann vor der Aufgabe, ein Unterverzeichnis Ihres Projektes als eigenes Repository verwalten zu wollen.
Sie möchten die Änderungen aber weiterhin in dem ursprünglichen Projekt integrieren.
////

At some point, you may be faced with the task of managing a subdirectory of your project as a separate repository.
However, you may still want to integrate the changes into the original project.


////
Beispielsweise wird die Dokumentation, die unter `doc/` lag, von nun an in einem eigenen Repository verwaltet.
Gelegentlich, das heißt alle paar Wochen, wollen Sie die neuesten Entwicklungen dann in das Haupt-Repository übernehmen.
////

For example, the documentation stored under `doc/` will be managed in a separate repository from now on.
Occasionally, that is, every few weeks, you want to transfer the latest developments to the master repository.


////
Das Kommando `git subtree` bietet dafür ein eigenes Subkommando `split` an, mit dem Sie diesen Schritt automatisieren können.
Es erstellt eine Versionsgeschichte, die alle Änderungen eines Verzeichnisses enthält, und gibt den neuesten Commit aus -- diesen können Sie dann in ein (leeres) Remote hochladen.
////

The `git sub-tree` command provides a separate sub-command `split` for this purpose, which you can use to automate this step.
It creates a version history containing all changes to a directory, and issues the latest commit -- which you can then upload to an (empty) remote.



[subs="quotes"]
--------
$ *git subtree split -P doc --rejoin*
Merge made by the 'ours' strategy.
563c68aa14375f887d104d63bf817f1357482576
$ *git push &lt;neues-doku-repo&gt; 563c68aa14375:refs/heads/master*
--------

////
Die Option `--rejoin` bewirkt, dass die so abgespaltene Versionsgeschichte direkt wieder per `git subtree merge` in das aktuelle Projekt integriert wird.
Sie können von nun an per `git subtree pull` die neuen Commits integrieren.
Wollen Sie stattdessen mit der Option `--squash` arbeiten, lassen Sie `--rejoin` weg.
////

The `--rejoin` option causes the version history split off in this way to be directly reintegrated into the current project via `git subtree merge`.
From now on you can integrate the new commits via `git subtree pull`.
If you want to use the `--squash` option instead, omit `--rejoin`.




[[sec.submodule-vs-subtree]]
=== Submodules vs. Subtrees

////
Die Frage "`Submodules oder Subtrees?`" lässt sich nicht generell, sondern nur von Fall zu Fall beantworten.
Ausschlaggebendes Kriterium sollte die Zugehörigkeit des Unterprojektes zu dem übergeordneten sein: Wenn Sie fremde Software einbinden, dann vermutlich eher als Submodule, eigene mit begrenztem Aufkommen an Commits und einer direkten Relation zum Hauptprojekt eher als Subtree.
////

The question "`Submodules or Subtrees?`" cannot be answered in general, but only on a case by case basis.
The decisive criterion should be the affiliation of the subproject to the superordinate one: If you include third-party software, it is probably more likely to be submodules, your own with limited commits and a direct relationship to the main project rather than a subtree.


////
Beispielsweise müssen Sie bei der Installation von CGit (siehe Abschnitt 7.5, "CGit .. CGI for Git") ein Submodule initialisieren und updaten, um die `libgit.a` zu kompilieren.
CGit benötigt also den Sourcecode von Git, will aber nicht die Entwicklungsgeschichte mit der von Git verschmelzen (die im Vergleich wenigen CGit-Commits würden darin auch untergehen!).
Sie können aber CGit auch gegen eine andere Git-Version kompilieren, wenn Sie das möchten -- die Flexibilität des Unter-Repositorys bleibt gewahrt.
////

For example, when you install CGit (see <<sec.cgit>>), you must initialize and update a submodule to compile `libgit.a`.
So CGit needs the source code of Git, but doesn't want to merge the development history with that of Git (the comparatively few CGit commits would be lost in this!).
You can, however, compile CGit against another version of Git if you wish -- the flexibility of the sub-repository is preserved.


////
Der grafische Repository-Browser Gitk hingegen wird als Subtree verwaltet.
Er wird in `git://ozlabs.org/~paulus/gitk` entwickelt, aber im Haupt-Git-Repository mit der Subtree-Merge-Strategie unterhalb von `gitk-git/` eingebunden.
////

The graphical repository browser Gitk, on the other hand, is managed as a subtree.
It is developed in `git://ozlabs.org/~paulus/gitk`, but is included in the main Git repository with the subtree-merge strategy under `gitk-git/`.
