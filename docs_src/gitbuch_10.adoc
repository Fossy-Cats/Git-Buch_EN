// adapted from: "shell.txt"

[[ch.shell-integration]]
= Shell Integration
// = Shell-Integration

include::gitbuch_footnotes.adoc[tag=Chapter_10]

////
Da Sie Git-Kommandos zumeist auf der Shell ausführen, sollten Sie diese um Funktionalität erweitern, um mit Git zu interagieren.
Gerade für Git-Anfänger ist ein solches Zusammenspiel zwischen Shell und Git sehr hilfreich, um nicht den Überblick zu verlieren.
////

Since you usually run Git commands on the shell, you should add functionality to them to interact with Git.
Especially for Git beginners, such interaction between shell and Git is very helpful to keep track of things.

////
In zwei Bereichen kann die Shell Ihnen besonders helfen:

* Anzeige wichtiger Informationen zu einem Repository im _Prompt_ (Eingabeaufforderung).
* So müssen Sie nicht allzu häufig `git status` und Konsorten aufrufen.

* Eine maßgeschneiderte _Completion_ (automatische Vervollständigung) hilft, Git-Kommandos direkt richtig einzugeben, auch wenn die genaue Syntax nicht bekannt ist.
////

There are two areas in which the shell can help you:

* Display important information about a repository at the _prompt_.
* This way you don't have to call `git status` and consorts too often.

* A custom _completion_ helps you to enter git commands correctly, even if you don't know the exact syntax.

////
Ein gutes Prompt sollte zusätzlich zum aktuellen Branch den Zustand des Working Tree signalisieren.
Gibt es Veränderungen, die noch nicht gespeichert sind?
Befinden sich schon Veränderungen im Index?
////

A good prompt should signal the state of the working tree in addition to the current branch.
Are there any changes that are not yet saved?
Are there already changes in the index?

////
Eine gute Completion sollte etwa bei der Eingabe von `git checkout` und dem anschließenden Drücken der Tab-Taste nur Branches aus dem Repository zur Vervollständigung anbieten.
Wenn Sie aber `git checkout --` eingeben, sollten nur Dateien vervollständigt werden.
Das spart Zeit und schützt vor Tippfehlern.
Auch andere Vervollständigungen sind sinnvoll, z.B. die vorhandenen Remotes bei `git push` und `git pull`.
////

A good completion should, for example, when entering `git checkout` and then pressing the Tab key, only offer branches from the repository for completion.
But if you type `git checkout --` only files should be completed.
This saves time and protects against typos.
Other completions are also useful, such as the existing remotes for `git push` and `git pull`.

////
In diesem Kapitel stellen wir grundlegende Rezepte für zwei beliebte Shells vor: die _Bash_ und die _Z-Shell_.
Anleitungen für andere interaktive Shells finden Sie ggf. im Internet.
////

In this chapter we will introduce basic recipes for two popular shells: the _Bash_ and the _Z-Shell_.
Instructions for other interactive shells can be found on the Internet.

////
Das Thema Shell-Integration ist sehr umfangreich, daher stellen die hier vorgestellten Anleitungen lediglich Anhaltspunkte und Ideen dar und erheben keinen Anspruch auf Vollständigkeit.
Es kommt erschwerend hinzu, dass die Git-Community die Benutzerschnittstelle -- also die vorhandenen Subkommandos und deren Optionen -- sehr schnell weiterentwickelt.
Bitte wundern Sie sich daher nicht, wenn die Completion teilweise "`hinterherhinkt`" und brandneue Subkommandos und Optionen (noch) nicht verfügbar sind.
////

The topic of shell integration is very extensive, so the tutorials presented here are only guidelines and ideas and do not claim to be complete.
To make matters worse, the git community is developing the user interface - i.e. the existing subcommands and their options - very quickly.
So please don't be surprised if the completion is "`lagging behind`" and brand new subcommands and options are not (yet) available.

[[sec.bash-integration]]
== Git and the Bash
// == Git und die Bash

////
Sowohl die Funktionalität für die Completion als auch die Status-Kommandos für das Prompt sind in einem Script namens `git-completion.bash` implementiert.
Es wird zusammen mit den Quellen für Git verwaltet.
Sie finden die Datei im Verzeichnis `contrib/completion` des Git-Projekts.
Häufig wird die Completion auch schon von Ihrer Distribution bzw. dem Git-Installer für Ihr Betriebssystem bereitgestellt.
Haben Sie bei Debian oder Ubuntu das Paket `git` installiert, sollte die Datei bereits unter `/usr/share/bash-completion/completions/git` vorliegen.
In Gentoo installieren Sie die Datei über das USE-Flag `bash-completion` von `dev-vcs/git`.
Der aktuelle Maintainer ist Shawn O. Pearce.
////

Both the functionality for completion and the status commands for the prompt are implemented in a script called `git-completion.bash`.
It is managed together with the sources for Git.
You can find the file in the `contrib/completion` directory of the Git project.
Often the completion is already provided by your distribution or the git installer for your operating system.
If you have installed the `git` package in Debian or Ubuntu, the file should already be in `/usr/share/bash-completion/completions/git`.
In Gentoo, you install the file via the USE flag `bash-completion` of `dev-vcs/git`.
The current maintainer is Shawn O. Pearce.

[[sec.bash-completion]]
=== Completion
// === Completion

////
Um die Completion zu aktivieren, laden Sie das Script mit dem Befehl `source` und übergeben als Argument die entsprechende Datei, also z.B.:
////

To activate the completion, load the script with the command `source` and pass the corresponding file as argument, e.g:

--------
source ~/Downloads/git-2.1.0/contrib/completion/git-completion.bash
--------

////
Die Completion vervollständigt unter anderem:
////

The completion completes among other things:

////
Git-Subkommandos:: Geben Sie bspw. `git pu[TAB]` ein, bietet Ihnen die Bash `pull` und `push` an:
////
Git subcommands:: For example, if you type `git pu[TAB]`, the bash will offer you `pull` and `push`:
+
[subs="macros,quotes"]
--------
$ *git pu[TAB]*
pull push
--------
+
////
Anmerkung: Nur die _Porcelain_-Kommandos sowie Benutzeraliase sind verfügbar.
Externe- und _Plumbing_-Kommandos sind nicht implementiert.
Subkommandos, die selber über weitere Subkommandos verfügen, z.B.{empty}{nbsp}`git remote` oder `git stash`, werden ebenfalls vervollständigt:
////
+
Note: Only the _porcelain_ commands and user aliases are available.
External and _plumbing_ commands are not implemented.
Subcommands that have additional subcommands themselves, e.g.{empty}{nbsp}``git remote`` or `git stash`, are also completed:
+
[subs="macros,quotes"]
--------
$ *git remote [TAB]*
add     prune     rename     rm     set-head     show     update
--------

////
Lokale Branches und Tags:: Nützlich für Subkommandos, wie `checkout` und `rebase`, die eine lokale Referenz erwarten:
////
Local Branches and Tags:: Useful for subcommands, such as `checkout` and `rebase`, that expect a local reference:
+
[subs="macros,quotes"]
--------
$ *git branch*
* master
  refactor-cmd-line
  refactor-profiling
$ *git checkout refactor-[TAB]*
refactor-cmd-line    refactor-profiling
--------

////
Konfigurierte Remotes:: Kommandos wie `git fetch` und `git remote` werden oft mit einem Remote als Argument aufgerufen.
Auch hier hilft die Completion weiter:
////
Configured Remotes:: Commands like `git fetch` and `git remote` are often called with a remote as argument.
Completion helps here too:
+
[subs="macros,quotes"]
--------
$ *git remote show [TAB]*
github        sourceforge
--------

////
Remote Branches und Tags:: Die Completion kann auch auf der Remote-Seite "`nachsehen`", welche Referenzen vorhanden sind.
Das erfolgt zum Beispiel beim Kommando `git pull`, das eine Remote-Referenz bzw. eine Refspec erwartet:
////
Remote Branches and Tags:: The Completion can also "`check`" on the remote page to see which references are available.
This is done for example with the command `git pull`, which expects a remote reference or a refspec:
+
[subs="macros,quotes"]
--------
$ *git pull origin v1.7.1[TAB]*
v1.7.1       v1.7.1.2     v1.7.1.4     v1.7.1-rc1
v1.7.1.1     v1.7.1.3     v1.7.1-rc0   v1.7.1-rc2
--------
+
////
Das funktioniert natürlich nur, wenn das Remote-Repository verfügbar ist.
In den meisten Fällen ist eine Netzwerkverbindung sowie mindestens Lesezugriff notwendig.
////
Of course this only works if the remote repository is available.
In most cases a network connection and at least read access is required.

////
Optionen:: Die meisten Subkommandos verfügen über diverse _Long Options_ wie z.B.{empty}{nbsp}`--bare`.
Die Completion kennt diese in der Regel und vervollständigt sie entsprechend:
////
Options:: Most subcommands have several _long options_ like{empty}{nbsp}``--bare``.
The completion usually knows these and completes them accordingly:
+
[subs="macros,quotes"]
--------
$ *git diff --color[TAB]*
--color         --color-words
--------
+
////
_Short Options_, wie z.B.{empty}{nbsp}`-a`, werden nicht komplettiert.
////
_Short options_, such as{empty}{nbsp}``-a``, are not completed.

////
Dateien:: Für Git-Kommandos, die Dateinamen erwarten.
Gute Beispiele sind `git add` sowie `git checkout`:
////
Files:: For Git commands that expect file names.
Good examples are `git add` and `git checkout`:
+
[subs="macros,quotes"]
--------
$ *git add [TAB]*
.git/     hello.py  README    test/
$ *git checkout -- [TAB]*
.git/     hello.py  README    test/
--------

////
Git-Konfigurationsoptionen:: Die Bash-Completion für Git vervollständigt auch Konfigurationsoptionen, die Sie mit `git config` einstellen:
////
Git configuration options:: The bash completion for Git also completes configuration options that you set with `git config`:
+
[subs="macros,quotes"]
--------
$ *git config user.[TAB]*
user.email        user.name         user.signingkey
--------

////
Wie bei der Bash-Completion üblich, wird die Eingabe automatisch vervollständigt, sobald sie eindeutig ist.
Existiert nur der Branch `feature`, führt die Eingabe von `git checkout fe[TAB]` dazu, dass `fe` vervollständigt wird; der Befehl `git checkout feature` steht dann auf der Kommandozeile -- drücken Sie auf Enter, um den Befehl auszuführen.
Nur wenn die Eingabe nicht eindeutig ist, zeigt die Bash die möglichen Vervollständigungen an.
////

As usual with bash completion, the input is automatically completed when it is unique.
If only the Branch `feature` exists, typing `git checkout fe[TAB]` will cause `fe` to be completed; the command `git checkout feature` will then appear on the command line - press Enter to execute the command.
Only when the input is ambiguous does the bash display the possible completions.

[[sec.bash-prompt]]
=== Prompt
// === Prompt

////
Neben der Completion gibt es ein weiteres Script, um Infos über das Git-Repository im Prompt anzuzeigen.
Dafür müssen Sie die Datei `contrib/completion/git-prompt.sh` laden (ggf. ist diese auch von Ihrer Distribution installiert, z.B. unter `/usr/lib/git-core/git-sh-prompt`).
Setzen Sie anschließend -- wie in folgendem Beispiel -- einen Aufruf der Funktion `__git_ps1` in die Variable `PS1` ein.
Als Argument nimmt die Funktion einen sogenannten _Format-String-Ausdruck_ entgegen -- d.h. die Zeichenfolge `%s` wird durch Git-Infos ersetzt, alle anderen Zeichen werden übernommen.
////

Beside the completion there is another script to display information about the git repository in the prompt.
For this you have to load the file `contrib/completion/git-prompt.sh` (maybe it is also installed by your distribution, e.g. under `/usr/lib/git-core/git-sh-prompt`).
Then, as in the following example, place a call to the `\__git_ps1` function in the `PS1` variable.
The function takes a so-called _format string expression_ as argument - i.e. the string `%s` is replaced by git infos, all other characters are taken over.

--------
source /usr/lib/git-core/git-sh-prompt
PS1=_\u@\h \w$(__git_ps1 " (%s)") $ _
--------

////
Die Zeichen werden wie folgt ersetzt: `\u` ist der Benutzername, `\h` der Rechnername, `\w` ist das aktuelle Arbeitsverzeichnis und `$(__git_ps1 " (%s)")` sind die Git-Infos, die ohne zusätzliche Konfiguration (s.u.) nur aus dem Branch-Namen bestehen:
////

The characters are replaced as follows: `\u` is the username, `\h` is the hostname, `\w` is the current working directory and `$(__git_ps1 " (%s)")` are the git infos, which without additional configuration (see below) consist only of the branch name:

[subs="macros,quotes"]
--------
pass:quotes[esc@creche] \~ $ *cd git-working/git*
pass:quotes[esc@creche] ~/git-working/git (master) $
--------

////
Mit dem Format-String-Ausdruck passen Sie die Darstellung der Git-Infos an, indem Sie zusätzliche Zeichen oder aber Farbcodes nutzen, z.B.  mit folgendem Prompt:
////

The format string expression allows you to customize the display of the git info by using additional characters or color codes, e.g. with the following prompt:

--------
PS1=_\u@\h \w$(__git_ps1 " (git)-[%s]") $ _
--------

////
Das sieht dann so aus:
////

This looks like this:

--------
esc@creche ~/git-working/git (git)-[master] $
--------

////
Ist der aktuelle Commit nicht durch einen Branch referenziert (Detached-HEAD), wird entweder das Tag oder die abgekürzte SHA-1-Summe angezeigt, jeweils von einem Klammerpaar umgeben:
////

If the current commit is not referenced by a branch (Detached-HEAD), either the tag or the abbreviated SHA-1 sum is displayed, each surrounded by a pair of brackets:

--------
esc@creche ~/git-working/git (git)-[(v1.7.1.4)] $
esc@creche ~/git-working/git (git)-[(e760924...)] $
--------

////
Befinden Sie sich innerhalb des `$GIT_DIR` oder in einem Bare-Repository, wird dies entsprechend signalisiert:
////

If you are inside the `$GIT_DIR` or in a bare repository, this is signaled accordingly:

--------
esc@creche ~/git-working/git/.git (git)-[GIT_DIR!] $
esc@creche ~/git-working/git.git/.git (git)-[BARE:master] $
--------

////
Außerdem wird angezeigt, wenn Sie sich mitten in einem Merge-Vorgang, einem Rebase oder einem ähnlichem Zustand befinden, bei dem nur bestimmte Operationen möglich sind:
////

It also indicates when you are in the middle of a merge, rebase or similar state where only certain operations are possible:

--------
esc@creche ~/git-working/git (git)-[master|REBASE-i] $
--------

////
Sie können die Anzeige auch erweitern, um sich den Zustand des Working Trees durch verschiedene Symbole anzeigen zu lassen.
Sie müssen dazu folgende Umgebungsvariablen auf einen _Non-Empty_-Wert setzen, also z.B. auf `1`.
////

You can also expand the display to show the status of the Working Trees using different icons.
To do this, you must set the following environment variables to a _non-empty_ value, e.g. to 1.

////
`GIT_PS1_SHOWDIRTYSTATE`:: Bei Veränderungen, die noch nicht im Index sind (_unstaged_), wird ein Sternchen (`*`) angezeigt.
Bei Veränderungen, die bereits im Index sind (_staged_), wird ein Plus (`+`) angezeigt.
Die Anzeige erfordert, dass der Working Tree gelesen wird -- dadurch verlangsamt sich die Shell evtl. bei großen
Repositories (Git muss jede Datei auf Modifikationen überprüfen).
Sie können dieses Verhalten daher mit der Git-Variable `bash.showDirtyState` für einzelne Repositories deaktivieren:
////
`GIT_PS1_SHOWDIRTYSTATE`:: For changes that are not yet in the index (_unstaged_), an asterisk (`*`) is displayed.
For changes that are already in the index (_staged_), a plus (`+`) is displayed.
The display requires the working tree to be read - this may slow down the shell for large repositories (Git has to check every file for modifications).
You can therefore disable this behavior for individual repositories with the Git variable `bash.showDirtyState`:
+
[subs="macros,quotes"]
--------
$ *git config bash.showDirtyState false*
--------

////
`GIT_PS1_SHOWSTASHSTATE`:: Sollten Sie einen oder mehrere Stashes angelegt haben, wird dies im Prompt durch das Dollar-Zeichen (`$`) signalisiert.
////

`GIT_PS1_SHOWSTASHSTATE`:: If you have created one or more stashes, this is indicated by the dollar sign (`$`) in the prompt.

////
`GIT_PS1_SHOWUNTRACKEDFILES`:: Die Existenz unbekannter Dateien (_untracked files_) wird mit Prozent-Zeichen (`%`) angezeigt.
////

`GIT_PS1_SHOWUNTRACKEDFILES`:: The existence of (_untracked files_) is indicated by a percentage sign (`%`).

////
Alle diese Zusatzinformationen können Sie wie folgt aktivieren:
////

You can activate all this additional information as follows:

--------
GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_SHOWSTASHSTATE=1
GIT_PS1_SHOWUNTRACKEDFILES=1
--------

////
Wenn im Repository nun alles zutrifft (also _unstaged_, _staged_, _stashed_ und _untracked_) werden vier zusätzliche Zeichen (`*`, `+`, `$` und `%`) im Prompt angezeigt:
////

If everything in the repository matches (i.e. _unstaged_, _staged_, _stashed_ and _untracked_), four additional characters (`*`, `+`, `$` and `%`) are displayed in the prompt:

--------
esc@creche ~/git-working/git (git)-[master *+$%] $
--------

////
In neueren Git-Versionen verfügt das Script über ein neues Feature, das die Beziehung zum Upstream-Branch (`@{upstream}`) anzeigt.
Aktivieren Sie diese Funktion durch Setzen von `GIT_PS1_SHOWUPSTREAM` auf den Wert `git`.{fn134} Das Prompt signalisiert dann alle Zustände, die in <<sec.remote-branch-vv>> beschrieben sind: _up-to-date_ mit dem Gleichheitszeichen (`=`); _ahead_ mit dem Größer-als-Zeichen (`>`); _behind_ mit dem Kleiner-als-Zeichen (`<`); _diverged_ mit sowohl einem Größer-als-Zeichen und einem Kleiner-als-Zeichen (`><`).
Zum Beispiel:
////

In newer Git versions, the script has a new feature that shows the relationship to the upstream branch (`@{upstream}`).
Enable this feature by setting `GIT_PS1_SHOWUPSTREAM` to the value `git`.{fn134} The prompt then signals all states described in Section 5.5.2, "Comparison with the Upstream": _up-to-date_ with the equal sign (`=`); _ahead_ with the greater-than sign (`>`); _behind_ with the less-than sign (`<`); _diverged_ with both a greater-than sign and a less-than sign (`><`).
For example:

--------
esc@creche ~/git-working/git (git)-[master >] $
--------

////
Diese Funktion ist mit der Option `--count` des Plumbing-Kommandos `git rev-list` implementiert, die in alten Git-Versionen, etwa 1.7.1, noch nicht existiert.
Haben Sie eine solche alte Git-Version, aber ein aktuelles Script und wollen diese Anzeige trotzdem verwenden, setzen Sie den Wert der Umgebungsvariablen auf `legacy` -- das Script verwendet dann eine alternative Implementation, die ohne die besagte Option auskommt.
Wenn Sie außerdem noch wissen wollen, wie weit der Branch vorne bzw. zurück liegt, fügen Sie den Wert `verbose` hinzu.
Das Prompt zeigt dann auch noch die Anzahl der unterschiedlichen Commits an:
////

This function is implemented with the `--count` option of the `git rev-list` plumbing command, which does not exist in old git versions, like 1.7.1.
If you have such an old git version, but a current script and want to use this display anyway, set the value of the environment variable to `legacy` - the script will then use an alternative implementation that works without the said option.
If you also want to know how far ahead or behind the branch is, add the value `verbose`.
The prompt will also show the number of different commits:

--------
esc@creche ~/git-working/git (git)-[master u+2] $
--------

////
Die gewünschten Werte sind der Umgebungsvariable als Liste zuzuweisen:
////

The desired values are to be assigned to the environment variable as a list:

--------
GIT_PS1_SHOWUPSTREAM="legacy verbose git"
--------

[[sec.zsh-integration]]
== Git and the Z-Shell
// == Git und die Z-Shell

////
Sowohl Completion- als auch Prompt-Funktionen werden bei der Z-Shell immer mitgeliefert.
////

Both completion and prompt functions are always included with the Z-Shell.

[TIP]
========

////
Die Z-Shell verfügt über ein sehr nützliches Feature, um Man-Pages aufzurufen: die `run-help` Funktion.
Sie wird im Emacs-Modus standardmäßig mit _Esc+H_ aufgerufen und zeigt für das Kommando, das bereits auf der Kommandozeile steht, die Man-Page an:

[subs="macros,quotes"]
--------
$ *man[ESC]+[h]*
#Man-Page man(1) wird angezeigt
--------
////

The Z-Shell has a very useful feature to call man pages: the `run-help` function.
It is called by default with `Esc+H` in Emacs mode and displays the man page for the command that is already on the command line:

[subs="macros,quotes"]
--------
$ *man[ESC]+[h]*
#Man-Page man(1) is displayed
--------

////
Da Git aber aus Subkommandos besteht und jedes Subkommando eine eigene Man-Page hat, funktioniert `run-help` nicht sonderlich gut -- es wird immer nur die Man-Page `git(1)` angezeigt.
Hier schafft die mitgelieferte Funktion `run-help-git` Abhilfe:

[subs="macros,quotes"]
--------
$ *git rebase[ESC]\+[h]*
#Man-Page git(1) wird angezeigt
$ *unalias run-help*
$ *autoload run-help*
$ *autoload run-help-git*
$ *git rebase[ESC]+[h]*
#Man-Page git-rebase(1) wird angezeigt
--------
////

However, since Git consists of subcommands and each subcommand has its own man page, `run-help` does not work very well - only the man page `git(1)` is displayed.
The included `run-help-git` function can help here:

[subs="macros,quotes"]
--------
$ git rebase[ESC]+[h]
#Man-Page git(1) is displayed
$ unalias run-help
$ autoload run-help
$ autoload run-help-git
$ git rebase[ESC]+[h]
#Man-Page git-rebase(1) is displayed
--------

========

[[sec.zsh-completion]]
=== Completion
// === Completion

////
Um die Completion für Git zu aktivieren, laden Sie zunächst das Completion-System:
////

To activate completion for Git, first load the completion system:

[subs="macros,quotes"]
--------
$ *autoload -Uz compinit &amp;&amp; compinit*
--------

////
Die Completion vervollständigt unter anderem:
////

The completion completes among other things:

////
Git-Subkommandos:: Subkommandos werden in der Z-Shell ebenfalls vervollständigt.
Der Unterschied zur Bash ist, dass die Z-Shell zusätzlich zum eigentlichen Kommando noch eine Kurzbeschreibung anzeigt:
////
Git subcommands:: Subcommands are also completed in the Z-Shell.
The difference to Bash is that the Z-Shell displays a short description in addition to the actual command:
+
[subs="macros,quotes"]
--------
$ *git pu[TAB]*
pull     -- fetch from and merge with a remote repository
push     -- update remote refs along with associated objects
--------
+
////
Das gleiche gilt auch für Subkommandos, die wiederum selbst Subkommandos haben:
////
The same applies to subcommands, which themselves have subcommands:
+
[subs="macros,quotes"]
--------
$ *git remote [TAB]*
add      -- add a new remote
prune    -- delete all stale tracking branches for a given remote
rename   -- rename a remote from .git/config and update all...
rm       -- remove a remote from .git/config and all...
show     -- show information about a given remote
update   -- fetch updates for a set of remotes
--------
+
////
Sowie auch Benutzeraliase:
////
As well as user aliases:
+
[subs="macros,quotes"]
--------
$ *git t[TAB]*
tag           -- create tag object signed with GPG
tree          -- alias for \_log --oneline --graph --decorate -23_
--------

////
Lokale Branches und Tags:: Die Z-Shell vervollständigt ebenfalls lokale Branches und Tags -- hier also kein Unterschied zur Bash.
////

Local Branches and Tags:: The Z-Shell also completes local branches and tags - no difference to Bash.

////
Konfigurierte Remotes:: Konfigurierte Remotes sind der Z-Shell bekannt.
Für Subkommandos, bei denen nur ein konfiguriertes Remote in Frage kommt, z.B.{empty}{nbsp}`git remote show`, werden auch nur konfigurierte Remotes angezeigt.
Sollte dies nicht eindeutig sein, wie z.B. bei `git pull`, dann greifen zusätzliche Mechanismen der Z-Shell und es wird meist eine lange Liste angezeigt, die sich unter anderem aus den Einträgen in den Dateien `.ssh/config` (die konfigurierten SSH-Hosts) und `.ssh/known_hosts` (Hosts, auf denen Sie sich schon mal eingeloggt haben) besteht.
////

Configured Remotes:: Configured remotes are known to the Z-Shell.
For subcommands where only a configured remote is possible, e.g.{empty}{nbsp}``git remote show``, only configured remotes are displayed.
If this is not clear, e.g. `git pull`, additional mechanisms of the Z-Shell take effect and usually a long list is displayed, which consists of the entries in the files `.ssh/config` (the configured SSH hosts) and `.ssh/known_hosts` (hosts you have already logged in to).

////
Optionen:: Im Gegensatz zur Bash kennt die Z-Shell sowohl lange als auch kurze Optionen und zeigt sie inklusive einer Kurzbeschreibung der Option.
Hier ein Auszug:
////
Options:: Unlike Bash, Z-Shell knows both long and short options and shows them including a short description of the option.
Here is an excerpt:
+
[subs="macros,quotes"]
--------
$ *git branch -[TAB]*
-a              -- list both remote-tracking branches and local branches
--contains      -- only list branches which contain the specified commit
--force     -f  -- force the creation of a new branch
--------

////
Dateien:: Die Z-Shell ist ebenfalls in der Lage, Dateinamen zu vervollständigen -- sie stellt sich aber etwas schlauer an als die Bash.
Zum Beispiel werden für `git add` und `git checkout` nur Dateien angeboten, die tatsächlich Veränderungen haben -- also Dateien, die entweder dem Index hinzugefügt oder zurückgesetzt werden können.
Dateien, die nicht in Betracht kommen, werden auch nicht angeboten.
////

Files:: The Z-Shell is also able to complete file names - but it is a bit smarter than Bash.
For example, for `git add` and `git checkout`, only files that actually have changes are offered - files that can either be added to the index or reset.
Files that do not qualify are not offered either.

////
Git-Konfigurationsoptionen:: Die Z-Shell-Completion für Git vervollständigt, wie die Bash auch, sämtliche Konfigurationsoptionen für Git.
Der Unterschied ist, dass auch hier eine Kurzbeschreibung der Optionen mit angezeigt wird:
////
Git configuration options:: Like Bash, the Z-Shell completion for Git completes all configuration options for Git.
The difference is that it also includes a short description of the options:
+
[subs="macros,quotes"]
--------
$ *git config user.[TAB]*
email        -- email address used for commits
name         -- full name used for commits
signingkey   -- default GPG key to use when creating signed tags
--------

////
Ein großer Unterschied bei der Z-Shell ist die Art und Weise, wie vervollständigt wird.
Die Z-Shell verwendet die sogenannte _Menu-Completion_.
Das bedeutet, dass Ihnen die Z-Shell durch erneutes Drücken der Tab-Taste jeweils die nächste mögliche Vervollständigung anbietet.{fn135}
////

A big difference with the Z-Shell is the way it is completed.
The Z-Shell uses the so-called _menu completion_.
This means that the Z-Shell offers you the next possible completion by pressing the Tab key again.{fn135}

[subs="macros,quotes"]
--------
$ *git pu[TAB]*
pull  -- fetch from and merge with another repository or local branch
push  -- update remote refs along with associated objects
$ *git pu[TAB]*
$ *git pull[TAB]*
$ git push
--------

////
Die Z-Shell ist (noch) nicht in der Lage, Referenzen auf der Remote-Seite zu vervollständigen -- dies steht jedoch auf der To-do-Liste.
Die Z-Shell ist aber heute schon in der Lage, Dateien über eine SSH-Verbindung hinweg zu vervollständigen.
Besonders nützlich ist dies im Zusammenhang mit Public-Key-Authentifizierung und vorkonfigurierten SSH-Hosts.
Angenommen, Sie haben folgenden Host in `.ssh/config` konfiguriert:
////

The Z-Shell is not (yet) able to complete references on the remote side - but this is on the to-do list.
But the Z-Shell is already able to complete files over an SSH connection.
This is especially useful in connection with public key authentication and preconfigured SSH hosts.
Assume you have configured the following host in `.ssh/config`:

--------
Host example
    HostName git.example.com
    User max
--------

////
Auf dem Server in Ihrem Home-Verzeichnis befinden sich Ihre Projekte als Bare-Repositories: `projekt1.git` und `projekt2.git`.
Außerdem haben Sie einen SSH-Schlüssel generiert und diesen in der Datei `.ssh/authorized_keys` auf dem Server abgelegt.
Sie können nun die Vervollständigung über die SSH-Verbindung hinweg nutzen.
////

On the server in your home directory your projects are located as bare repositories: `project1.git` and `project2.git`.
You also generated an SSH key and stored it in the `.ssh/authorized_keys` file on the server.
You can now use completion across the SSH connection.

[subs="macros,quotes"]
--------
$ *git clone example:[TAB]*
projekt1.git/ projekt2.git/
--------

////
Möglich wird dies durch die Completion-Funktionen der Z-Shell für `ssh`.
////

This is made possible by the completion functions of the Z-shell for `ssh`.

[[sec.zsh-prompt]]
=== Prompt
// === Prompt

////
Die Z-Shell beinhaltet Funktionen, um das Prompt mit Git-Infos zu versehen.
Die Funktionalität ist Teil des umfangreichen `vcs_info`-Systems, das neben Git circa ein Dutzend anderer Programme zur Versionsverwaltung kennt, inklusive Subversion, CVS und Mercurial.
Die ausführliche Dokumentation finden Sie in der Man-Page `zshcontrib(1)`, im Abschnitt "`Gathering Information From Version Control Systems`".
Hier stellen wir nur die für Git relevanten Einstellungen und Anpassungsmöglichkeiten vor.
////

The Z-Shell contains functions to add git info to the prompt.
The functionality is part of the extensive `vcs_info` system, which knows about a dozen other version control programs besides Git, including Subversion, CVS and Mercurial.
Detailed documentation can be found in the `zshcontrib(1)` man page, in the "`Gathering Information From Version Control Systems`" section.
Here we will only present the settings and customization options relevant to Git.

////
Zunächst müssen Sie `vcs_info` laden und das Prompt so anpassen, dass Git-Infos angezeigt werden.
Hierbei ist wichtig, dass die Z-Shell-Option `prompt_subst` gesetzt ist; sie sorgt dafür, dass Variablen im Prompt auch tatsächlich ersetzt werden, außerdem müssen Sie die Funktion `vcs_info` in der Funktion `precmd` aufrufen.
`precmd` wird direkt vor der Anzeige des Prompts aufgerufen.
Der Aufruf `vcs_info` darin sorgt dafür, dass die Git-Infos auch tatsächlich in der Variable `${vcs_info_msg_0_}` gespeichert werden.
Fügen Sie Ihrer `.zshrc` folgende Zeilen hinzu, falls sie noch nicht enthalten sind:
////

First, you need to load `vcs_info` and adjust the prompt to display Git info.
It's important that the Z-Shell option `prompt_subst` is set; it ensures that variables in the prompt are actually replaced, and you must call `vcs_info` in the `precmd` function.
`precmd` is called just before the prompt is displayed.
The call `vcs_info` in it makes sure that the git info is actually stored in the variable `${vcs_info_msg_0_}`.
Add the following lines to your `.zshrc` if they are not already included:

////
--------
# vcs_info laden
autoload -Uz vcs_info
# prompt_subst aktivieren
setopt prompt_subst
# precmd definieren
precmd () { vcs_info }
# Prompt setzten
PS1=_%n@%m %~${vcs_info_msg_0_} $ _
--------
////

--------
# load vcs_info
autoload -Uz vcs_info
# activate prompt_subst
setopt prompt_subst
# define precmd
precmd () { vcs_info }
# Set prompt
PS1=_%n@%m %~${vcs_info_msg_0_} $ _
--------

////
Das Prompt setzt sich wie folgt zusammen: `%n` ist der Benutzername, `%m` ist der Rechnername, `%~` das aktuelle Arbeitsverzeichnis und die Variable `${vcs_info_msg_0_}` enthält die Git-Infos.
Wichtig ist dabei, dass das Prompt mit einfachen Anführungszeichen (_single quotes_) angegeben wird.
Dadurch wird die _Zeichenfolge_{empty}{nbsp}`${vcs_info_msg_0_}` und nicht der Wert der Variablen abgespeichert.
Erst bei Anzeige des Prompt wird der Wert der Variablen -- also die Git-Infos -- substituiert.
////

The prompt is composed as follows: `%n` is the username, `%m` is the hostname, `%~` is the current working directory, and the variable `${vcs_info_msg_0_}` contains the git info.
It is important that the prompt is specified with single quotes.
This saves the _string_{empty}{nbsp}``${vcs_info_msg_0_}`` and not the value of the variable.
Only when the prompt is displayed is the value of the variable - i.e. the git info - substituted.

////
Die o.g.  Einstellung für `PS1` sieht so aus:
////

The above setting for `PS1` looks like this:

--------
esc@creche ~/git-working/git (git)-[master]- $
--------

////
Da `vcs_info` mit sehr vielen Versionsverwaltungssystemen funktioniert, lohnt es sich, nur diejenigen zu aktivieren, die Sie tatsächlich verwenden:[136]
////

Since `vcs_info` works with a lot of version control systems, it's worth activating only those you actually use:{fn136}

--------
zstyle _:vcs_info:*_ enable git
--------

////
Zum Anpassen von `vcs_info` verwenden Sie einen sogenannten `zstyle`, einen hierarchischen Konfigurationsmechanismus der Z-Shell, der in der Man-Page `zshmodules(1)` beschrieben ist.
////

To customize `vcs_info`, use a so-called `zstyle`, a hierarchical configuration mechanism of the z-shell described in the `zshmodules(1)` man page.

////
Besondere Zustände wie Merge- oder Rebase-Vorgänge werden entsprechend signalisiert:
////

Special states like merge or rebase operations are signaled accordingly:

--------
esc@creche ~/git-working/git (git)-[master|bisect]- $
--------

////
Auch bei einem Detached-HEAD wird entweder das Tag oder die abgekürzte SHA-1-Summe angezeigt:
////

Also in case of a Detached-HEAD either the tag or the abbreviated SHA-1 sum is displayed:

--------
esc@creche ~/git-working/git (git)-[v1.7.1.4] $
esc@creche ~/git-working/git (git)-[e760924...] $
--------

////
Die Z-Shell kann, wie die Bash auch, Zustände des Working Trees anzeigen.
Schalten Sie dies mit folgender Zeile an:
////

The Z-Shell, like the Bash, can display states of the working tree.
Switch this on with the following line:

--------
zstyle _:vcs_info:git*:*_ check-for-changes true
--------

////
So zeigt `vcs_info` für Veränderungen, die noch nicht im Index sind (_unstaged_), ein `U` an und für Veränderungen, die Sie im Index aufgenommen haben (_staged_), ein `S`:
////

For example, `vcs_info` shows a `U` for changes that are not yet in the index (_unstaged_) and an `S` for changes that you have included in the index (_staged_):

--------
esc@creche ~/git-working/git (git)-[master]US- $
--------

////
Ein großer Vorteil von `vcs_info` ist, dass es sich sehr leicht anpassen lässt.
Gefallen Ihnen etwa die Buchstaben `U` und `S` nicht, können Sie sie durch andere Zeichen z.B.{empty}{nbsp}`*` und `+` ersetzen:
////

A big advantage of `vcs_info` is that it can be adapted very easily.
For example, if you do not like the letters `U` and `S`, you can replace them with other characters, e.g.{empty}{nbsp}``*`` and `+`:

--------
zstyle _:vcs_info:git*:*_ unstagedstr _*_
zstyle _:vcs_info:git*:*_ stagedstr _+_
--------

////
Somit ähnelt das Zsh-Prompt nun immer mehr dem Beispiel aus dem Abschnitt zur Bash:
////

Thus the Zsh prompt now looks more and more like the example from the section on bash:

--------
esc@creche ~/git-working/git (git)-[master]*+- $
--------

////
Um solche noch nicht gespeicherten Informationen anzuzeigen, muss `vcs_info` immer den Working Tree untersuchen. Da dies bei großen Repositories bekanntlich Probleme bereitet, können Sie bestimmte Muster ausschließen:
////

To display such not yet stored information `vcs_info` must always examine the working tree. Since this is known to cause problems with large repositories, you can exclude certain patterns:

--------
zstyle _:vcs_info:*_ disable-patterns "/home/esc/git-working/linux-2.6(|/*)"
--------

////
Vielleicht möchten Sie nun noch die Reihenfolge der Zeichen ändern.
In dem Fall müssen Sie zwei Format-String Ausdrücke anpassen: `formats` und `actionformats`.
Der erste ist das Standardformat, der zweite das Format, wenn Sie sich mitten in einem Merge-Vorgang, Rebase oder ähnlichem befinden:
////

Maybe you want to change the order of the characters.
In this case you need to adjust two format string expressions: `formats` and `actionformats`.
The first is the default format, the second is the format when you are in the middle of a merge, rebase or similar process:

--------
zstyle _:vcs_info:git*:*_ formats " (%s)-[%b%u%c]"
zstyle _:vcs_info:git*:*_ actionformats " (%s)-[%b|%a%u%c]"
--------

////
Eine Auswahl der wichtigsten Zeichen finden Sie in der folgenden Tabelle.  Eine detaillierte Auflistung bietet die oben erwähnte Man-Page.

`%s`:: Versionsverwaltungssystem, in unserem Fall immer `git`

`%b`:: Aktueller Branch, z.B.{empty}{nbsp}`master`

`%a`:: Aktueller Vorgang, z.B.{empty}{nbsp}`merge` oder `rebase-i` (nur bei `actionformats`)

`%u`:: Zeichen zur Anzeige von Veränderungen, die noch nicht im Index sind, z.B.{empty}{nbsp}`U`

`%c`:: Zeichen zur Anzeige von Veränderungen, die schon im Index sind, z.B.{empty}{nbsp}`S`

Mit der o.g. Einstellung sieht das Prompt dann so aus:
////

A selection of the most important characters can be found in the following table.
For a detailed list, please refer to the above mentioned man page.

`%s`:: version management system, in our case always `git`

`%b`:: Current branch, e.g.{empty}{nbsp}``master``

`%a`:: Current process, e.g.{empty}{nbsp}``merge`` or `rebase-i` (only for `actionformats`)

`%u`:: Character to indicate changes that are not yet in the index, e.g.{empty}{nbsp}``U``

`%c`:: Character to indicate changes that are already in the index, e.g.{empty}{nbsp}``S``

With the above setting the prompt will look like this:

--------
esc@creche ~/git-working/git (git)-[master*+] $
--------

////
Leider kann `vcs_info` standardmäßig die Existenz unbekannter Dateien und angelegter Stashes nicht signalisieren.
Das System unterstützt aber ab Z-Shell Version 4.3.11 sogenannte _Hooks_ -- Erweiterungen, die zusätzliche Information in das Prompt einschleusen.
Wir werden nun zwei solcher Hooks vorstellen, die die beiden genannten, fehlenden Features implementieren.
////

Unfortunately `vcs_info` cannot signal the existence of unknown files and created stashes by default.
But since Z-Shell version 4.3.11 the system supports so called _hooks_ -- extensions, which inject additional information into the prompt.
We will now introduce two such hooks, which implement the two missing features mentioned above.

////
Die Hooks für `vcs_info` werden als Shell-Funktionen geschrieben.
Beachten Sie, dass der Funktionsname das Präfix `+vi-` hat, um mögliche Kollisionen zu vermeiden.
Damit ein Hook auch wirklich funktioniert, muss er einen Wert im assoziativen Array `hook_com` verändern.
In beiden Beispielen verändern wir den Wert des Eintrags `staged`, indem wir zusätzliche Zeichen anhängen, um bestimmte Zustände zu markieren.
Wir verwenden das Prozent-Zeichen (`%`), um unbekannte Dateien zu signalisieren, und das Dollar-Zeichen (`$`) für angelegte Stashes.
Das Prozentzeichen muss zweimal angegeben werden, damit die Z-Shell es nicht fälschlich als Formatierung wertet.
Bei den Hooks greifen wir auf diverse Plumbing-Kommandos zurück (siehe <<sec.scripting>>).
////

The hooks for `vcs_info` are written as shell functions.
Note that the function name has the prefix `+vi-` to avoid possible collisions.
For a hook to really work it has to change a value in the associative array `hook_com`.
In both examples we change the value of the entry `staged` by appending additional characters to mark certain states.
We use the percent sign (`%`) to indicate unknown files and the dollar sign (`$`) for created stashes.
The percent sign must be specified twice to prevent the Z-Shell from mistakenly interpreting it as formatting.
For the hooks we use various plumbing commands (see <<sec.scripting>>).

--------
+vi-untracked(){
    if [[ $(git rev-parse --is-inside-work-tree 2> /dev/null) == _true_ ]] && \
        [[ -n $(git ls-files --others --exclude-standard) ]] ; then
        hook_com[staged]+=_%%_
    fi
}
+vi-stashed(){
    if git rev-parse --verify refs/stash &> /dev/null ; then
        hook_com[staged]+=_$_
    fi
}
--------

////
Wir aktivieren die Hooks, so dass sie beim Setzen der Git-Infos ausgewertet werden (`+set-message`):
////

We activate the hooks so that they are evaluated when the git info is set (`+set-message`):

--------
zstyle _:vcs_info:git*+set-message:*_ hooks stashed untracked
--------

////
Wie beim Beispiel zu der Bash oben, werden ggf. (_unstaged_, _staged_, _stashed_ und _untracked_) vier zusätzliche Zeichen (`*`, `+`, `$` und `%`) im Prompt angezeigt:
////

As in the bash example above, four additional characters (`*`, `+`, `$` and `%`) may be displayed in the prompt (_unstaged_, _staged_, _stashed_ and _untracked_):

--------
esc@creche ~/git-working/git (git)-[master*+$%] $
--------

////
Mit solchen Hooks ist es möglich, das Prompt nach Belieben zu erweitern.
Zum Beispiel zeigt `vcs_info` standardmäßig nicht an, ob Sie sich innerhalb des `$GIT_DIR` oder aber in einem Bare-Repository befinden.
Mit einem entsprechenden Hook bauen Sie diese Signale in das Prompt ein.
////

With such hooks it is possible to extend the prompt as desired.
For example, `vcs_info` does not show by default whether you are inside the `$GIT_DIR` or in a bare repository.
With an appropriate hook you can include these signals in the prompt.

////
Weitere Beispiele finden sich in der Datei `Misc/vcs_info-examples` des Z-Shell Repositorys, unter anderem auch ein Hook, der die Beziehung zum Upstream-Branch anzeigt (Abschnitt "`Compare local changes to remote changes`").
Eine minimale Konfiguration für die Z-Shell entsprechend den Beispielen in diesem Abschnitt finden Sie in der Scriptsammlung für dieses Buch.{fn137}
////

For more examples, see the `Misc/vcs_info-examples` file in the Z-Shell repository, including a hook that indicates the upstream branch relationship (section "`Compare local changes to remote changes`").
A minimal configuration for the Z-Shell according to the examples in this section can be found in the Scripts Collection for this book.{fn137}

//////////
FIXME: Das muss hier alles ein dritter prüfen, der Ahnung von Shell hat, da kann soviel schief gehen.

EN.TRANS: Everything has to be checked by a third party who knows about Shell, so many things can go wrong.
//////////
