// adapted from: "praxis.txt"

[[ch.praxis]]
= Practical Version Control
// Praktische Versionsverwaltung

// @NOTE: Chapter title could be translated better!

include::gitbuch_footnotes.adoc[tag=Chapter_3]


////
Das folgende Kapitel stellt alle wesentlichen Techniken vor, die Sie im täglichen Umgang mit Git einsetzen werden.
Neben einer genaueren Beschreibung des Index und wie man alte Versionen wiederherstellt, liegt der Fokus auf der effektiven Arbeit mit Branches.
////

The following chapter introduces all the essential techniques you'll use in your daily work with Git.
In addition to a more detailed description of the index and how to restore old versions, the focus is on working effectively with branches.



[[sec.branches]]
== References: Branches and Tags
// Referenzen: Branches und Tags

////
"`Branch`" und "`Merge`" sind im CVS-/SVN-Umfeld für Neulinge oft ein Buch mit sieben Siegeln, für Könner regelmäßig Grund zum Haare raufen.
In Git sind das Abzweigen im Entwicklungszyklus (_Branching_) und das anschließende Wiederzusammenführen (_Merging_) alltäglich, einfach, transparent und schnell.
Es kommt häufig vor, dass ein Entwickler an einem Tag mehrere Branches erstellt und mehrere Merges durchführt.
////

// @TODO: Check translation of 2nd sentence! (something seems lost)

In the CVS/SVN environment, "`Branch`" and "`Merge`" are often a book with seven seals for newcomers, but for experts they are a regular cause for hair-raising.
In Git, _branching_ and _merging_ are commonplace, simple, transparent, and fast.
It's common for a developer to create multiple branches and perform multiple merges in one day.


////
Das Tool Gitk ist hilfreich, um bei mehreren Branches nicht den Überblick zu verlieren.
Mit `gitk --all` zeigen Sie alle Branches an.
Das Tool visualisiert den im vorigen Abschnitt erläuterten Commit-Graphen.
Jeder Commit stellt eine Zeile dar.
Branches werden als grüne Labels, Tags als gelbe Zeiger dargestellt.
Für weitere Informationen siehe Abschnitt 3.6.2, "Gitk".
////

The tool Gitk is helpful in order not to lose the overview of several branches.
With `gitk --all` you show all branches.
The tool visualizes the commit graph explained in the previous section.
Each commit represents one line.
Branches are displayed as green labels, tags as yellow pointers.
For more information, see <<sec.gitk>>.


// .Das Beispiel-Repository aus Kapitel 2, Grundlagen in Gitk. Zur Illustration wurde der zweite Commit mit  dem Tag `v0.1` versehen.
.The sample repository from <<ch.basics>>. For illustration purposes, the second commit has been tagged `v0.1`.
image::gitk-basic.png[id="fig.gitk-basic",scaledwidth="90%",width="90%"]


////
Da Branches in Git "`billig`" und Merges einfach sind, können Sie es sich leisten, Branches exzessiv zu verwenden.
Sie wollen etwas probieren, einen kleinen Bugfix vorbereiten oder mit einem experimentellen Feature beginnen?
Für all das erstellen Sie jeweils einen neuen Branch.
Sie wollen testen, ob sich ein Branch mit dem anderen verträgt?
Führen Sie die beiden zusammen, testen Sie alles, und löschen Sie danach den Merge wieder und entwickeln weiter.
Das ist gängige Praxis unter Entwicklern, die Git einsetzen.
////

Because branches in Git are "`cheap`" and merges are easy, you can afford to use branches excessively.
Want to try something, prepare a small bug fix, or start with an experimental feature?
You can create a new branch for each of these.
You want to test if one branch is compatible with the other?
Merge them together, test everything, then delete the merge again and continue developing.
This is common practice among developers using Git.


////
Zunächst wollen wir uns mit Referenzen generell auseinandersetzen.
Referenzen sind nichts weiter als symbolische Namen für die schwierig zu merkenden SHA-1-Summen von Commits.
////

First, let's look at references in general.
References are nothing more than symbolic names for the hard to remember SHA-1 sums of commits.


////
Diese Referenzen liegen in `.git/refs/`.
Der Name einer Referenz wird anhand des Dateinamens, das Ziel anhand des Inhalts der Datei bestimmt.
Der Master-Branch, auf dem Sie schon die ganze Zeit arbeiten, sieht darin zum Beispiel so aus:
////

These references are stored in `.git/refs/`.
The name of a reference is determined by the file name, and the target is determined by the contents of the file.
For example, the master branch you have been working on all along looks like this:


[subs="quotes"]
--------
$ *cat .git/refs/heads/master*
89062b72afccda5b9e8ed77bf82c38577e603251
--------


[TIP]
===================
////
Wenn Git sehr viele Referenzen verwalten muss, liegen diese nicht zwingend als Dateien unterhalb von `.git/refs/`.
Git erstellt dann stattdessen einen Container, der _gepackte Referenzen_ (_Packed Refs_) enthält: Eine Zeile pro Referenz mit Name und SHA-1-Summe.
Das sequentielle Auflösen vieler Referenzen geht dann schneller.
Git-Kommandos suchen Branches und Tags in der Datei `.git/packed-refs`, wenn die entsprechende Datei `.git/refs/<name>` nicht existiert.
////

If Git needs to manage a lot of references, they may not be stored as files under `.git/refs/`.
Instead, Git creates a container that contains packed references (_Packed Refs_): One line per reference with name and SHA-1 sum.
This makes sequential resolution of many references faster.
Git commands search for branches and tags in the `.git/packed-refs` file if the corresponding `.git/refs/<name>` file does not exist.
===================


////
Unterhalb von `.git/refs/` gibt es verschiedene Verzeichnisse, die für die "`Art`" von Referenz stehen.
Fundamental unterscheiden sich diese Referenzen aber nicht, lediglich darin, wann und wie sie angewendet werden.
Die Referenzen, die Sie am häufigsten verwenden werden, sind Branches.
Sie sind unter `.git/refs/heads/` gespeichert.
_Heads_ bezeichnet das, was in anderen Systemen zuweilen auch "`Tip`" genannt wird: Den neuesten Commit auf einem Entwicklungsstrang.[29]
Branches rücken weiter, wenn Sie Commits auf einem Branch erstellen -- sie bleiben also an der Spitze der Versionsgeschichte.
////

Under `.git/refs/` there are several directories that represent the "`type`" of reference.
There is no fundamental difference between these references, only when and how they are used.
The references you will use most often are branches.
They are stored under `.git/refs/heads/`.
_Heads_ refers to what is sometimes called a "`tip`" in other systems: The latest commit on a development branch.{fn29}
Branches move up when you make commits on a branch, so they remain at the top of the version history.


// .Der Branch referenziert immer den aktuellsten Commit
.A branch always references the most recent commit
image::commit.png[id="fig.commit",scaledwidth="80%",width="80%"]


////
Branches in Repositories anderer Entwickler (z.B. der Master-Branch des offiziellen Repositorys), sog. Remote-Tracking-Branches, werden unter `.git/refs/remotes/` abgelegt (siehe Abschnitt 5.2.2, "Remote-Tracking-Branches").
Tags, statische Referenzen, die meist der Versionierung dienen, liegen unter `.git/refs/tags/` (siehe Abschnitt 3.1.3, "Tags -- Wichtige Versionen markieren").
////

Branches in other developers' repositories (e.g. the master branch of the official repository), so-called remote tracking branches, are stored under `.git/refs/remotes/` (see <<sec.remote_tracking_branches>>).
Tags, static references, which are mostly used for versioning, are stored under `.git/refs/tags/` (see <<sec.tags>>).



[[sec.branch-refs]]
=== HEAD and Other Symbolic References
//  HEAD und andere symbolische Referenzen

Eine Referenz, die Sie selten explizit, aber ständig implizit benutzen, ist `HEAD`.
Sie referenziert meist den gerade ausgecheckten Branch, hier `master`:

One reference that you rarely use explicitly, but always implicitly, is `HEAD`.
It usually refers to the branch you just checked out, in this case `master`:


[subs="quotes"]
--------
$ *cat .git/HEAD*
ref: refs/heads/master
--------



////
`HEAD` kann auch direkt auf einen Commit zeigen, wenn Sie `git checkout <commit-id>` eingeben.
Sie sind dann allerdings im sogenannten _Detached-Head_-Modus, in dem Commits möglicherweise verlorengehen, siehe auch Abschnitt 3.2.1, "Detached HEAD".
////

`HEAD` can also point directly to a commit if you type `git checkout <commit-id>`.
However, you are then in so-called _detached-head_ mode, in which commits may get lost, see also <<sec.detached-head>>.


////
Der `HEAD` bestimmt, welche Dateien im Working Tree zu finden sind, welcher Commit Vorgänger bei der Erstellung eines neuen wird, welcher Commit per `git show` angezeigt wird etc.
Wenn wir hier von "`dem aktuellen Branch`" sprechen, dann ist damit technisch korrekt der `HEAD` gemeint.
////

The `HEAD` determines which files are found in the working tree, which commit becomes the predecessor when a new one is created, which commit is displayed by `git show`, and so on.
When we speak of "`the current branch`", we mean the `HEAD` in a technically correct sense.


////
Die simplen Kommandos `log`, `show` und `diff` nehmen ohne weitere Argumente `HEAD` als erstes Argument an.
Die Ausgabe von `git log` ist gleich der von `git log HEAD` usw. -- dies gilt für die meisten Kommandos, die auf einem Commit operieren, wenn Sie keinen explizit angeben.
`HEAD` ist somit vergleichbar mit der Shell-Variable `PWD`, die angibt "`wo man ist`".
////

The simple commands `log`, `show`, and `diff` take `HEAD` as their first argument, without any further arguments.
The output of `git log` is the same as the output of `git log HEAD`, and so on -- this applies to most commands that operate on a commit if you don't specify one explicitly.
`HEAD` is thus similar to the shell variable `PWD`, which specifies "`where you are`".


////
Wenn wir von einem Commit sprechen, dann ist es einem Kommando in der Regel egal, ob man die Commit-ID komplett oder verkürzt angibt oder den Commit über eine Referenz, wie z.B. ein Tag oder Branch, ansteuert.
Eine solche Referenz muss aber nicht immer eindeutig sein.
Was passiert, wenn es einen Branch `master` gibt und ein Tag gleichen Namens?
Git überprüft, ob die folgenden Referenzen existieren:
////

When we talk about a commit, a command usually doesn't care whether you specify the commit ID in full or in abbreviated form, or whether you access the commit by reference, such as a tag or branch.
However, such a reference may not always be unique.
What happens if there is a branch `master` and a tag with the same name?
Git checks if the following references exist:


////
* `.git/<name>` (meist nur sinnvoll für `HEAD` o.ä.)
////

* `.git/<name>` (mostly only useful for `HEAD` or similar)
* `.git/refs/<name>`
* `.git/refs/tags/<name>`
* `.git/refs/heads/<name>`
* `.git/refs/remotes/<name>`
* `.git/refs/remotes/<name>/HEAD`


////
Die erste gefundene Referenz nimmt Git als Treffer an.
Sie sollten also Tags immer ein eindeutiges Schema geben, um sie nicht mit Branches zu verwechseln.
So können Sie Branches direkt über den Namen statt über `heads/<name>` ansprechen.
////

Git will take the first matching reference it finds.
So you should always give tags a unique scheme so that they don't get confused with branches.
This way you can address branches directly by name instead of `heads/<name>`.


////
Besonders wichtig sind dafür die Suffixe `^` und `~<n>`.
Die Syntax `<ref>^` bezeichnet den direkten Vorfahren von `<ref>`.
Dieser muss aber nicht immer eindeutig sein: Wenn zwei oder mehr Branches zusammengeführt wurden, hat der Merge-Commit mehrere direkte Vorfahren.
`<ref>^` bzw. `<ref>^1` bezeichnen dann den ersten _direkten_ Vorfahren, `<ref>^2` den zweiten usw.[30]
Die Syntax `HEAD^^` bedeutet also "`der zwei Ebenen vorher liegende direkte Vorfahre des aktuellen Commits`".
Achten Sie darauf, dass `^` in Ihrer Shell möglicherweise eine spezielle Bedeutung hat und Sie es durch Anführungszeichen oder mit einem Backslash schützen müssen.
////

Especially important are the suffixes `^` and `~<n>`.
The syntax `<ref>^` indicates the direct ancestor of `<ref>`.
This does not always have to be unique: If two or more branches were merged, the merge commit has several direct ancestors.
`<ref>^` or `<ref>^1` then denotes the first direct ancestor, `<ref>^2` the second, and so on.{fn30}
So the syntax `HEAD^^` means "`the two-level previous direct ancestor of the current commit`".
Note that `^` may have a special meaning in your shell and you may need to protect it with quotes or a backslash.



// .Relative-Referenzen, `^` und `~<n>`
.Relative References, `^` and `~<n>`
image::relative-refs.png[id="fig.relative-refs",scaledwidth="65%",width="65%"]


////
Die Syntax `<ref>~<n>` kommt einer _n_-fachen Wiederholung von `^` gleich: `HEAD~10` bezeichnet also den zehnten direkten Vorgänger des aktuellen Commits.
Achtung: Das heißt nicht, dass zwischen `HEAD` und `HEAD~10` nur elf Commits liegen: Da `^` bei einem etwaigen Merge nur dem ersten Strang folgt, liegen zwischen den beiden Referenzen die elf und alle durch einen Merge integrierten weiteren Commits.
Die Syntax ist übrigens in der Man-Page `git-rev-parse(1)` im Abschnitt "`Specifying Revisions`" dokumentiert.
////

// @NOTE: I've actually checked the "Specifying Revisions" section title at the
//        'git-rev-parse(1)' man page, so it's correct!

The syntax `<ref>~<n>` is equivalent to repeating `^` _n_ times: `HEAD~10` thus denotes the tenth direct predecessor of the current commit.
Note: This does not mean that only eleven commits are stored between `HEAD` and `HEAD~10`: Since `^` only follows the first string in any merge, the eleven commits stored between the two references, and all the other commits integrated by a merge, are the same.
The syntax is documented in the `git-rev-parse(1)` man page in the "`Specifying Revisions`" section.



[[sec.branch-management]]
=== Managing Branches
//  Branches verwalten

////
Ein Branch ist in Git im Nu erstellt.
Git muss lediglich den aktuell ausgecheckten Commit identifizieren und die SHA-1-Summe in der Datei `.git/refs/heads/<branch-name>` ablegen.
////

A branch is created in Git in no time.
All Git needs to do is identify the currently checked out commit and store the SHA-1 sum in the `.git/refs/heads/<branch-name>` file.


[subs="quotes"]
--------
$ *time git branch neuer-branch*
git branch neuer-branch  0.00s user 0.00s system 100% cpu 0.008 total
--------


////
Das Kommando ist so schnell, weil (im Gegensatz zu anderen Systemen) keine Dateien kopiert und keine weiteren Metadaten abgelegt werden müssen.
Informationen über die Struktur der Versionsgeschichte sind immer aus dem Commit, den ein Branch referenziert, und seinen Vorfahren ableitbar.
////

The command is so fast because (unlike other systems) no files need to be copied and no additional metadata needs to be stored.
Information about the structure of the version history can always be derived from the commit that a branch references and its ancestors.


////
Hier eine Übersicht der wichtigsten Optionen:
////

Here is an overview of the most important options:


////
`git branch [-v]` ::
Listet lokale Branches auf.
Dabei ist der aktuell ausgecheckte Branch mit einem Sternchen markiert.
Mit `-v` werden außerdem die Commit-IDs, auf die die Branches zeigen, sowie die erste Zeile der Beschreibung der entsprechenden Commits angezeigt.
////

`git branch [-v]` ::
Lists local branches.
The currently checked-out branch is marked with an asterisk.
You can also use `-v` to display the commit IDs to which the branches point and the first line of the description of the corresponding commits.
+
[subs="quotes"]
--------
$ *git branch -v*
  maint  65f13f2 Start 1.7.5.1 maintenance track
* master 791a765 Update draft release notes to 1.7.6
  next   b503560 Merge branch \_master_ into next
  pu     d7a491c Merge branch \_js/info-man-path_ into pu
--------

////
`git branch <branch> [<ref>]` ::
Erstellt einen neuen Branch `<branch>`, der auf Commit `<ref>` zeigt (`<ref>` kann die SHA-1-Summe eines Commits sein, ein anderer Branch usw.).
Wenn Sie keine Referenz angeben, ist dies `HEAD`, der aktuelle Branch.
////

`git branch <branch> [<ref>]` ::
Creates a new branch `<branch>` pointing to commit `<ref>` (`<ref>` can be the SHA-1 sum of a commit, another branch, etc.).
If you do not specify a reference, this is HEAD, the current branch.

////
`git branch -m  <neuer-name>`::
`git branch -m  <alter-name> <neuer-name>`
+
In der ersten Form wird der aktuelle Branch in `<neuer-name>` umbenannt.
In der zweiten Form wird `<alter-name>` in `<neuer-name>` umbenannt.
Das Kommando schlägt fehl, wenn dadurch ein anderer Branch überschrieben würde.
////


`git branch -m  <new-name>` :: {empty}

`git branch -m  <old-name> <new-name>` ::
In the first form the current branch is renamed to `<new-name>`.
In the second form `<old-name>` is renamed to `<new-name>`.
The command fails if this would overwrite another branch.
+
[subs="quotes"]
--------
$ *git branch -m master*
fatal: A branch named 'master' already exists.
--------
+
////
Wenn Sie einen Branch umbenennen, gibt Git keine Meldung aus.
Sie können also hinterher überprüfen, dass die Umbenennung erfolgreich war:
////
If you rename a branch, Git will not display a message.
So you can check afterwards to make sure the renaming was successful:
+
[subs="quotes"]
--------
$ *git branch*
* master
  test
$ *git branch -m test pu/feature*
$ *git branch*
* master
  pu/feature
--------



////
`git branch -M ...` ::
Wie `-m`, nur dass ein Branch auch umbenannt wird, wenn dadurch ein anderer überschrieben wird.
Achtung: Dabei können Commits des überschriebenen Branches verlorengehen!
////

`git branch -M ...` ::
Like `-m`, except that a branch is also renamed if it overwrites another branch.
Attention: Commits of the overwritten branch may be lost!


////
`git branch -d <branch>` ::
Löscht `<branch>`.
Sie können mehrere Branches gleichzeitig angeben.
Git weigert sich, einen Branch zu löschen, wenn er noch nicht komplett in seinen Upstream-Branch, oder, falls dieser nicht existiert, in `HEAD`, also den aktuellen Branch, integriert ist.
(Mehr über Upstream-Branches finden Sie in Abschnitt 5.3.2, "git pull".)
////

`git branch -d <branch>` ::
Delete `<branch>`.
You can specify several branches at once.
Git refuses to delete a branch if it is not yet fully integrated into its upstream branch, or, if it does not exist, into `HEAD`, the current branch.
(For more on upstream branches, see <<sec.pull>>).



////
`git branch -D ...` ::
Löscht einen Branch, auch wenn er Commits enthält, die noch nicht in den Upstream- oder aktuellen Branch integriert wurden.
Achtung: Diese Commits können möglicherweise verlorengehen, wenn sie nicht anders referenziert werden.
////

`git branch -D ...` ::
Deletes a branch, even if it contains commits that have not yet been integrated into the upstream or current branch.
Note: These commits may be lost unless they are referenced differently.




[[sec.branch-checkout]]
==== Changing Branches: checkout
//   Branches wechseln: checkout

////
Branches wechseln Sie mit `git checkout <branch>`.
Wenn Sie einen Branch erstellen und direkt darauf wechseln wollen, verwenden Sie `git checkout -b <branch>`.
Das Kommando ist äquivalent zu `git branch <branch> && git checkout <branch>`.
////

You can change branches with `git checkout <branch>`.
If you create a Branch and want to switch directly to it, use `git checkout -b <branch>`.
The command is equivalent to `git branch <branch> && git checkout <branch>`.



////
Was passiert bei einem Checkout?
Jeder Branch referenziert einen Commit, der wiederum einen Tree referenziert, also das Abbild einer Verzeichnisstruktur.
Ein `git checkout <branch>` löst nun die Referenz `<branch>` auf einen Commit auf und repliziert den Tree des Commits auf den Index und auf den Working Tree (d.h.  auf das Dateisystem).
////

What happens during a checkout?
Each branch references a commit, which in turn references a tree, that is, the image of a directory structure.
A `git checkout <branch>` now resolves the reference `<branch>` to a commit and replicates the commit's tree to the index and to the working tree (i.e., the filesystem).


////
Da Git weiß, in welcher Version Dateien aktuell in Index und Working Tree vorliegen, müssen nur die Dateien, die sich auf dem aktuellen und dem neuen Branch unterscheiden, ausgecheckt werden.
////

Since Git knows which version of files are currently in the index and working tree, only the files that differ on the current and new branches need to be checked out.

Git macht es Anwendern schwer, Informationen zu verlieren.
Daher wird ein Checkout eher fehlschlagen als eventuell nicht abgespeicherte Änderungen in einer Datei überschreiben.
Das passiert in den folgenden beiden Fällen:

Git makes it hard for users to lose information.
Therefore, a checkout is more likely to fail than overwrite any unsaved changes in a file.
This happens in the following two cases:



////
* Der Checkout würde eine Datei im Working Tree überschreiben, in der sich Änderungen befinden.
  Git gibt folgende Fehlermeldung aus: `error: Your local changes to the following files
  would be overwritten by checkout: datei`.
////

* The checkout would overwrite a file in the working tree that contains changes.
  Git will display the following error message: `error: Your local changes to the following files would be overwritten by checkout: file`.

////
* Der Checkout würde eine ungetrackte Datei überschreiben, d.h. eine Datei, die nicht von Git verwaltet wird.
  Git bricht dann mit der Fehlermeldung ab: `error: The following untracked working tree files would be overwritten by checkout: datei`.
////

* The checkout would overwrite an untracked file, i.e. a file that is not managed by Git.
  Git then aborts with the error message: error: `The following untracked working tree files would be overwritten by checkout: file.`


////
Liegen allerdings Änderungen im Working Tree oder Index vor, die mit beiden Branches verträglich sind, übernimmt ein Checkout diese Änderungen.
Das sieht dann z.B. so aus:
////

If, however, changes are stored in the working tree or index that are compatible with both branches, a checkout takes over these changes.
This would look like this, for example:

// @TRANSLATE GIT LOG?
// @NOTE: Why "master" is in italics?
[subs="quotes"]
--------
$ *git checkout master*
A   neue-datei.txt
Switched to branch _master_
--------


////
Das bedeutet, dass die Datei `neue-datei.txt` hinzugefügt wurde, die auf keinem der beiden Branches existiert.
Da hier also keine Informationen verlorengehen können, wird die Datei einfach übernommen.
Die Meldung: `A neue-datei.txt` erinnert Sie, um welche Dateien Sie sich noch kümmern sollten.
Dabei steht `A` für hinzugefügt (_added_), `D` für gelöscht (_deleted_) und `M` für geändert (_modified_).
////

This means that the file `new-file.txt` was added, which does not exist on either branch.
So since no information can be lost here, the file is simply transferred.
The message: `A new-file.txt` reminds you which files you should still take care of.
`A` stands for _added_, `D` for _deleted_ and `M` for _modified_.


////
Wenn Sie ganz sicher sind, dass Sie Ihre Änderungen nicht mehr brauchen, können Sie per `git checkout -f` die Fehlermeldungen ignorieren und den Checkout trotzdem ausführen.
////

If you're sure you don't need your changes anymore, you can use `git checkout -f` to ignore the error messages and run the checkout anyway.


////
Wenn Sie sowohl die Änderungen behalten als auch den Branch wechseln wollen (Beispiel: Arbeit unterbrechen und auf einem anderen Branch einen Fehler korrigieren), dann hilft `git stash` (Abschnitt 4.5, "Veränderungen auslagern -- git stash").
////

If you want to keep the changes and change the branch (e.g., interrupt your work and fix a bug on another branch), `git stash` will help (<<sec.stash>>).




[[sec.branch-naming]]
====  Conventions for Naming Branches
//    Konventionen zur Benennung von Branches

////
Sie können Branches prinzipiell fast beliebig benennen.
Ausnahmen sind aber Leerzeichen, einige Sonderzeichen mit spezieller Bedeutung für Git (z.B.``{asterisk}``, `^`, `:`, `~`), sowie zwei aufeinanderfolgende Punkte (`..`) oder ein Punkt am Anfang des Namens.[31]
////

In principle, you can name branches almost arbitrarily.
Exceptions are spaces, some special characters with special meaning for Git (e.g. ``{asterisk}``, `^`, `:`, `~`), as well as two consecutive dots (`..`) or a dot at the beginning of the name.{fn31}


////
Sinnvollerweise sollten Sie Branch-Namen immer komplett in Kleinbuchstaben angeben.
Da Git Branch-Namen unter `.git/refs/heads/` als Dateien verwaltet, ist die Groß- und Kleinschreibung wesentlich.
////

It makes sense to always enter branch names completely in lower case letters.
Since Git manages branch names under `.git/refs/heads/` as files, it is essential that you use upper and lower case.


////
Sie können Branches in "`Namespaces`" gruppieren, indem Sie als Separator einen `/` verwenden.
Branches, die mit der Übersetzung einer Software zu tun haben, können Sie dann z.B. `i18n/german`, `i18n/english` etc. nennen.
Auch können Sie, wenn sich mehrere Entwickler ein Repository teilen, "`private`" Branches unter `<username>/<topic>` anlegen.
Diese Namespaces werden durch eine Verzeichnisstruktur abgebildet, so dass dann unter `.git/refs/heads/` ein Verzeichnis `<username>/` mit der Branch-Datei `<topic>` erstellt wird.
////

You can group branches into "`namespaces`" by using a `/` as a separator.
Branches that are related to the translation of a software can then be named e.g. `i18n/german`, `i18n/english` etc.
If several developers share a repository, you can also create "`private`" branches under `<username>/<topic>`.
These namespaces are represented by a directory structure, so that a directory `<username>/` with the branch file `<topic>` is created under `.git/refs/heads/`.


////
Der Hauptentwicklungszweig Ihres Projekts sollte immer `master` heißen.
Bugfixes werden häufig auf einem Branch `maint` (kurz für "`maintenance`") verwaltet.
Das nächste Release wird meist auf `next` vorbereitet.
Features, die sich noch in einem experimentellen Zustand befinden, sollten in `pu` (für "`proposed updates`") entwickelt werden oder in `pu/<feature>`.
Eine detailliertere Beschreibung, wie Sie mit Branches die Entwicklung strukturieren und Release-Zyklen organisieren, finden Sie in Kapitel 6, _Workflows_ über Workflows.
////

The main development branch of your project should always be called `master`.
Bugfixes are often managed on a branch `maint` (short for "`maintenance`").
The next release is usually prepared for `next`.
Features that are still in an experimental state should be developed in `pu` (for "`proposed updates`") or in `pu/<feature>`.
For a more detailed description of how to use branches to structure development and organize release cycles, see <<ch.workflows>> on Workflows.




[[sec.no-ref-commits]]
==== Deleted Branches and "`Lost`" Commits
//   Gelöschte Branches und "`verlorene`" Commits

////
Commits kennen jeweils einen oder mehrere Vorgänger.
Daher kann man den Commit-Graphen "`gerichtet`", d.h. von neueren zu älteren Commits, durchlaufen, bis man an einem Wurzel-Commit ankommt.
////

Commits each have one or more predecessors.
Therefore, you can walk through the commit graph "`directed`", that is, from newer to older commits, until you reach a root commit.


////
Andersherum geht das nicht: Wenn ein Commit seinen Nachfolger kennen würde, müsste diese Version irgendwo gespeichert werden.
Dadurch würde sich die SHA-1-Summe des Commits ändern, worauf der Nachfolger den entsprechend neuen Commit referenzieren müsste, dadurch eine neue SHA-1-Summe erhielte, so dass wiederum der Vorgänger geändert werden müsste usw.
Git kann also die Commits nur von einer benannten Referenz aus (z.B.  ein Branch oder `HEAD`) in Richtung früherer Commits durchgehen.
////

It's not the other way around: if a commit knew its successor, that version would have to be stored somewhere.
This would change the SHA-1 sum of the commit, and the successor would have to reference the corresponding new commit, which would give it a new SHA-1 sum, so the predecessor would have to be changed, and so on.
So Git can only go through the commits from a named reference (such as a branch or `HEAD`) in the direction of earlier commits.


////
Wenn daher die "`Spitze`" eines Branches gelöscht wird, wird der oberste Commit nicht mehr referenziert (im Git-Jargon: _unreachable_).
Dadurch wird der Vorgänger nicht mehr referenziert usw. -- bis der nächste Commit auftaucht, der irgendwie referenziert wird (sei es von einem Branch oder dadurch, dass er einen Nachfolger hat, der wiederum von einem Branch referenziert wird).
////

Therefore, if the "`top`" of a branch is deleted, the topmost commit is no longer referenced (in Git jargon: _unreachable_).
As a result, the predecessor is no longer referenced, and so on, until the next commit comes along that is referenced in some way (either by a branch, or by having a successor that is itself referenced by a branch).


////
Wenn Sie einen Branch löschen, werden die Commits auf diesem Branch also nicht gelöscht, sie gehen nur "`verloren`".
Git findet sie einfach nicht mehr.
////

So when you delete a branch, the commits on that branch are not deleted, they are just "`lost`".
Git simply doesn't find them anymore.


////
In der Objektdatenbank sind sie allerdings noch eine Weile lang vorhanden.{fn32} Sie können also einen Branch ohne weiteres wiederherstellen, indem Sie den vorherigen (und vermeintlich gelöschten) Commit explizit als Referenz angeben:
////

However, they will still be present in the object database for a while, so you can easily restore a branch by explicitly specifying the previous (and supposedly deleted) commit as a reference:



[subs="quotes"]
--------
$ *git branch -D test*
Deleted branch test (was e32bf29).
$ *git branch test e32bf29*
--------


////
Eine weitere Möglichkeit, gelöschte Commits wiederzufinden, ist das
_Reflog_ (siehe dafür Abschnitt 3.7, "Reflog").
////

Another way to retrieve deleted commits is the _reflog_ (see <<sec.reflog>>).




[[sec.tags]]
=== Tags -- Marking Important Versions
//  Tags -- Wichtige Versionen markieren

////
SHA-1-Summen sind zwar eine sehr elegante Lösung, um Versionen dezentral zu beschreiben, aber semantikarm und für Menschen unhandlich.
Im Gegensatz zu linearen Revisionsnummern sagen uns Commit-IDs allein nichts über die Reihenfolge der Versionen.
////

SHA-1 sums are a very elegant solution to describe versions decentrally, but they are semantically poor and unwieldy for humans.
Unlike linear revision numbers, commit IDs alone tell us nothing about the order of versions.


////
Während der Entwicklung von Softwareprojekten müssen verschiedene "`wichtige`" Versionen so markiert werden, dass sie leicht in dem Repository zu finden sind.
Die wichtigsten sind meist solche, die veröffentlicht werden, die sogenannten _Releases_.
Auch _Release Candidates_ werden häufig auf diese Weise markiert, also Versionen, die die Basis für die nächste Version bilden und im Zuge der Qualitätssicherung auf kritische Fehler untersucht werden, ohne dass neue Features hinzugefügt werden.
Je nach Projekt und Entwicklungsmodell gibt es verschiedene Konventionen, um Releases zu bezeichnen, und Abläufe, wie sie vorbereitet und publiziert werden.
////

During the development of software projects, different "`important`" versions need to be marked so that they can be easily found in the repository.
The most important ones are usually those that are released, called _releases_.
_Release candidates_ are also often marked in this way, i.e. versions that form the basis for the next version and are checked for critical bugs in the course of quality assurance without adding new features.
Depending on the project and development model, there are different conventions for marking releases and procedures for preparing and publishing them.


////
Im Open-Source-Bereich haben sich zwei Versionierungsschemata durchgesetzt: die klassische _Major/Minor/Micro-Versionierung_ und neuerdings auch die _datumsbasierte Versionierung_.
Bei der Major/Minor/Micro-Versionierung, welche z.B. beim Linux-Kernel und auch Git eingesetzt wird, ist eine Version durch drei (oft auch vier) Zahlen gekennzeichnet: `2.6.39` oder `1.7.1`.
Bei der datumsbasierten Versionierung hingegen ist die Bezeichnung aus dem Zeitpunkt des Releases abgeleitet, z.B.: `2011.05` oder `2011-05-19`.
Das hat den großen Vorteil, dass das Alter einer Version leicht ersichtlich ist.[33]
////

In the open source area, two versioning schemes have become established: the classic _major_/_minor_/_micro versioning_ scheme and, more recently, _date-based versioning_.
With major/minor/micro versioning, which is used e.g. with the Linux kernel and also Git, a version is identified by three (often four) numbers: `2.6.39` or `1.7.1`.
With date-based versioning, on the other hand, the designation is derived from the time of the release, e.g.: `2011.05` or `2011-05-19`.
This has the great advantage that the age of a version is easily identifiable.{fn33}


////
Git bietet Ihnen mit _Tags_ ("`Etiketten`") die Möglichkeit, beliebige Git-Objekte -- meist Commits -- zu markieren, um markante Zustände in der Entwicklungsgeschichte hervorzuheben.
Tags sind, wie Branches auch, als Referenzen auf Objekte implementiert.
Im Gegensatz zu Branches jedoch sind Tags statisch, das heißt, sie werden nicht verschoben, wenn neue Commits hinzukommen, und zeigen stets auf dasselbe Objekt.
Es gibt zwei Arten von Tags: _Annotated_ (mit Anmerkungen versehen) und _Lightweight_ ("`leichtgewichtig`", d.h. ohne Anmerkungen).
Annotated Tags sind mit Metadaten -- z.B. Autor, Beschreibung oder GPG-Signatur -- versehen.
Lightweight Tags zeigen hingegen "`einfach nur`" auf ein bestimmtes Git-Objekt.
Für beide Arten von Tags legt Git unter `.git/refs/tags/` bzw. `.git/packed-refs` Referenzen an.
Der Unterschied ist, dass Git für jedes Annotated Tag ein spezielles Git-Objekt -- und zwar ein _Tag-Objekt_ -- in der Objektdatenbank anlegt, um die Metadaten sowie die SHA-1-Summe des markierten Objekts zu speichern, während ein Lightweight Tag direkt auf das markierte Objekt zeigt.
Abbildung 3.4, "Das Tag-Objekt" zeigt den Inhalt eines Tag-Objekts; vergleichen Sie auch die anderen Git-Objekte, Abbildung 2.4, "Git-Objekte".
////

Git offers _tags_ ("`labels`") that can be used to mark any Git object -- usually commits -- to highlight prominent states in its development history.
Like branches, tags are implemented as references to objects.
Unlike branches, however, tags are static, meaning that they are not moved when new commits are added, and always point to the same object.
There are two types of tags: _annotated_ and _lightweight_.
Annotated tags are tagged with metadata, such as author, description, or GPG signature.
Lightweight tags, on the other hand, "`simply`" point to a specific Git object.
For both types of tags, Git creates references under `.git/refs/tags/` or `.git/packed-refs`.
The difference is that for each annotated tag, Git creates a special Git object -- a _tag object_ -- in the Object Database to store the metadata and SHA-1 sum of the selected object, while a Lightweight tag points directly to the selected object.
<<fig.tag-object>> shows the contents of a tag object; compare also the other git objects, <<fig.objekte>>.


// @TRANSLATE IMAGE TEXT?

// .Das Tag-Objekt
.The Tag Object
image::tags.png[id="fig.tag-object",scaledwidth="90%",width="90%"]


////
Das gezeigte Tag-Objekt hat sowohl eine Größe (158 Byte) als auch eine SHA-1-Summe.
Es enthält die Bezeichnung (`0.1`), den Objekt-Typ und die SHA-1-Summe des referenzierten Objekts sowie den Namen und E-Mail des Autors, der im Git-Jargon _Tagger_ heißt.
Außerdem enthält das Tag eine Tag-Message, die zum Beispiel die Version beschreibt, sowie optional eine GPG-Signatur.
Im Git-Projekt etwa besteht eine Tag-Message aus der aktuellen Versionsbezeichnung und der Signatur des Maintainers.
////

The tag object shown has both a size (158 bytes) and a SHA-1 sum.
It contains the name (`0.1`), the object type and the SHA-1 sum of the referenced object as well as the name and e-mail of the author, which is called _tagger_ in Git jargon.
In addition, the tag contains a tag message that describes the version, for example, and optionally a GPG signature.
In the Git project, for example, a tag message consists of the current version designation and the signature of the maintainer.


////
Schauen wir im Folgenden zunächst, wie Sie Tags lokal verwalten.
Wie Sie Tags zwischen Repositories austauschen, beschreibt Abschnitt 5.8, "Tags austauschen".
////

In the following, let's first look at how you manage tags locally.
<<sec.remote-tags>> describes how you exchange tags between repositories.




[[sec.tags-verwalten]]
==== Managing Tags
//   Tags verwalten

////
Tags verwalten Sie mit dem Kommando `git tag`.
Ohne Argumente zeigt es alle vorhandenen Tags an.
Je nach Projektgröße lohnt es sich, die Ausgabe mit der Option `-l` und einem entsprechenden Muster einzuschränken.
Mit folgendem Befehl zeigen Sie alle Varianten der Version `1.7.1` des Git-Projekts an, also sowohl die Release-Candidates mit dem Zusatz `-rc*` sowie die (vierstelligen) Maintenance-Releases:
////

You can manage tags with the command `git tag`.
Without arguments it shows all existing tags.
Depending on the size of the project, it is worth limiting the output with the `-l` option and a corresponding pattern.
With the following command you display all variants of version 1.7.1 of the git project, i.e. both the release candidates with the addition `-rc*` and the (four-digit) maintenance releases:


[subs="quotes,attributes"]
--------
$ *git tag -l v1.7.1{asterisk}*
v1.7.1
v1.7.1-rc0
v1.7.1-rc1
v1.7.1-rc2
v1.7.1.1
v1.7.1.2
v1.7.1.3
v1.7.1.4
--------



////
Den Inhalt eines Tags liefert Ihnen `git show`:
////

The content of a tag is provided by `git show`:


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git show 0.1 | head*
tag 0.1
Tagger: Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
Date:   Wed Mar 23 16:52:03 2011 +0100

Erste Veröffentlichung

commit e2c67ebb6d2db2aab831f477306baa44036af635
Author: Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
Date:   Sat Jan 8 20:30:58 2011 +0100
--------


////
Gitk stellt Tags als gelbe, pfeilartige Kästchen dar, die sich
deutlich von den grünen, rechteckigen Branches unterscheiden:
////

Gitk presents tags as yellow, arrow-like boxes that are clearly distinguishable from the green, rectangular branches:

.Tags in Gitk
image::tag-screenshot.png[id="fig.tag-gitk",scaledwidth="90%",width="90%"]





[[sec.lightweight-tags]]
==== Lightweight Tags

////
Um den `HEAD` mit einem Lightweight Tag zu versehen, übergeben
Sie den gewünschten Namen an das Kommando (in diesem Beispiel, um einen
wichtigen Commit zu markieren):
////

To add a lightweight tag to the `HEAD`, pass the desired name to the command (in this example, to mark an important commit)


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git tag api-aenderung*
$ *git tag*
api-aenderung
--------


////
Sie können aber auch die SHA-1-Summe eines Objekts oder eine valide Revisionsbezeichnung (z.B.{empty}{nbsp}`master` oder `HEAD~23`) angeben, um ein Objekt nachträglich zu markieren.
////

To add a lightweight tag to the `HEAD`, pass the desired name to the command (in this example, to mark an important commit)


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git tag pre-regression HEAD~23*
$ *git tag*
api-aenderung
pre-regression
--------


////
Tags sind einzigartig -- sollten Sie versuchen, ein Tag erneut zu erzeugen, bricht Git mit einer Fehlermeldung ab:
////

Tags are unique -- if you try to recreate a tag, Git will abort with an error message:


[subs="quotes"]
--------
$ *git tag pre-regression*
fatal: tag 'pre-regression' already exists
--------





[[sec.annotated-tags]]
==== Annotated Tags

////
Annotated Tags erzeugen Sie mit der Option `-a`.
Wie bei `git commit` öffnet sich ein Editor, mit dem Sie die Tag-Message verfassen.
Oder Sie übergeben die Tag-Message mit der Option `-m` -- dann ist die Option `-a` redundant:
////

Annotated tags are created with the `-a` option.
As with `git commit`, an editor will open and allow you to write the tag message.
Or you can pass the tag message with the option `-m` -- in which case the option `-a` is redundant:


[subs="quotes"]
--------
$ *git tag -m "Zweite Veröffentlichung" 0.2*
--------




[[sec.signierte-tags]]
==== Signed Tags
//   Signierte Tags

Um ein signiertes Tag zu überprüfen, verwenden Sie die Option `-v` (_verify_):

To verify a signed tag, use the `-v` (_verify_) option:

[subs="quotes"]
--------
$ *git tag -v v1.7.1*
object d599e0484f8ebac8cc50e9557a4c3d246826843d
type commit
tag v1.7.1
tagger Junio C Hamano &lt;gitster@pobox.com&gt; 1272072587 -0700

Git 1.7.1
gpg: Signature made Sat Apr 24 03:29:47 2010 CEST using DSA key ID F3119B9A
gpg: Good signature from "Junio C Hamano &lt;junkio@cox.net&gt;"
...
--------


////
Das setzt natürlich voraus, dass Sie sowohl GnuPG installiert als auch den Schlüssel des Signierenden bereits importiert haben.
////

Of course, this assumes that you have both GnuPG installed and that you have already imported the signer's key.

////
Um selbst Tags zu signieren, müssen Sie zunächst den dafür bevorzugten Key einstellen:
////

In order to sign tags yourself, you must first set the preferred key:


[subs="quotes"]
--------
$ *git config --global user.signingkey &lt;GPG-Key-ID&gt;*
--------

////
Nun können Sie signierte Tags mit der Option `-s` (_sign_) erstellen:
////

Now you can create signed tags with the `-s` (_sign_) option:


[subs="quotes"]
--------
$ *git tag -s -m "Dritte Veröffentlichung" 3.0*
--------




[[sec.tags-loeschen]]
==== Deleting and Overwriting Tags
//   Tags löschen und überschreiben

////
Mit den Optionen `-d` und `-f` löschen Sie Tags bzw. überschreiben sie:
////

Use the `-d` and `-f` options to delete or overwrite tags:

[subs="quotes"]
--------
$ *git tag -d 0.2*
Deleted tag '0.2' (was 4773c73)
--------


////
Die Optionen sind mit Vorsicht zu genießen, besonders wenn Sie die Tags nicht nur lokal verwenden, sondern auch veröffentlichen.
Unter bestimmten Umständen kann es dazu kommen, dass Tags unterschiedliche Commits bezeichnen -- Version `1.0` im Repository X zeigt auf einen anderen Commit als Version `1.0` im Repository Y.
Aber sehen Sie hierzu auch Abschnitt 5.8, "Tags austauschen".
////

The options should be used with caution, especially if you use the tags not only locally, but also publish them.
Under certain circumstances, tags may indicate different commits -- version `1.0` in repository X points to a different commit than version `1.0` in repository Y.
But see also <<sec.remote-tags>>.




[[sec.tags-lightweight-vs-heavyweight]]
==== Lightweight vs. Annotated Tags

////
Für die öffentliche Versionierung von Software sind allgemein Annotated Tags sinnvoller.
Sie enthalten im Gegensatz zu Lightweight Tags Metainformationen, aus denen zu ersehen ist, wer wann ein Tag erstellt hat -- der Ansprechpartner ist eindeutig.
Auch erfahren Benutzer einer Software so, wer eine bestimmte Version abgesegnet hat.
Zum Beispiel ist klar, dass Junio C. Hamano die Git-Version 1.7.1 getaggt hat -- sie hat also quasi sein "`Gütesiegel`".
Die Aussage bestätigt natürlich auch die kryptographische Signatur.
Lightweight Tags hingegen eignen sich vor allem, um lokal Markierungen anzubringen, zum Beispiel um bestimmte, für die aktuelle Aufgabe relevante Commits zu kennzeichnen.
Achten Sie aber darauf, solche Tags nicht in ein öffentliches Repository hochzuladen (siehe  Abschnitt 5.8, "Tags austauschen"), da diese sich sonst verbreiten könnten.
Sofern Sie die Tags nur lokal verwenden, können Sie sie auch löschen, wenn sie ihren Dienst erfüllt haben (s.o.).
////

For public versioning of software, annotated tags are generally more useful.
Unlike lightweight tags, they contain meta-information that shows who created a tag and when -- the person contact is unique.
Users of software can also find out who has approved a particular version.
For example, it's clear that Junio C. Hamano has tagged Git version 1.7.1 -- so it has his "`seal of approval`".
The statement also confirms the cryptographic signature, of course.
Lightweight tags, on the other hand, are particularly suitable for applying local markers, for example to identify certain commits relevant to the current task.
However, make sure not to upload such tags to a public repository (see <<sec.remote-tags>>), as they might spread.
If you only use the tags locally, you can also delete them once they have fulfilled their service (see above).



[[sec.non-commit-tags]]
==== Non-Commit Tags

////
Mit Tags markieren Sie beliebige Git-Objekte, also nicht nur Commits, sondern auch Tree-, Blob- und sogar Tag-Objekte selbst!
Das klassische Beispiel ist, den öffentlichen GPG-Schlüssel, der von dem Maintainer eines Projekts zum Signieren von Tags verwendet wird, in einem Blob zu hinterlegen.
////

With tags you can mark any Git object, not only commits, but also trees, blobs and even tag objects themselves!
The classic example is to put the GPG public key used by the maintainer of a project to sign tags in a blob.

////
So zeigt das Tag `junio-gpg-pub` im Git-Repository von Git auf den Schlüssel von Junio C. Hamano:
////

For example, the tag `junio-gpg-pub` in the Git repository of Git points to the key of Junio C. Hamano:


[subs="quotes"]
--------
$ *git show junio-gpg-pub | head -5*
tag junio-gpg-pub
Tagger: Junio C Hamano &lt;junkio@cox.net&gt;
Date:   Tue Dec 13 16:33:29 2005 -0800

GPG key to sign git.git archive.
--------



////
Weil dieses Blob-Objekt von keinem Tree referenziert wird, ist die Datei quasi getrennt vom eigentlichen Code, aber dennoch im Repository vorhanden.
Außerdem ist ein Tag auf einen "`einsamen`" Blob notwendig, damit dieser nicht als _unreachable_ gilt und im Zuge der Repository-Wartung gelöscht wird.[34]
////

Because this blob object is not referenced by any tree, the file is virtually separate from the actual code, but still exists in the repository.
In addition, a tag on a "`lonely`" blob is necessary so that it is not considered unreachable and is deleted during repository maintenance.{fn34}

////
Um den Schlüssel zu verwenden, gehen Sie wie folgt vor:
////

To use the key, proceed as follows:


[subs="quotes"]
--------
$ *git cat-file blob junio-gpg-pub | gpg --import*
gpg: key F3119B9A: public key "Junio C Hamano &lt;junkio@cox.net&gt;" imported
gpg: Total number processed: 1
gpg:               imported: 1
--------


////
Sie können dann, wie oben beschrieben, alle Tags im Git-via-Git-Repository verifizieren.
////

You can then verify all tags in the Git-via-Git repository, as described above.



[[sec.git-describe]]
==== Describing Commits
//   Commits beschreiben

Tags sind sehr nützlich, um beliebige Commits "`besser`" zu beschreiben.
Das Kommando `git describe` gibt eine Beschreibung, die aus dem aktuellsten Tag und dessen relativer Position im Commit-Graphen besteht.
Hier ein Beispiel aus dem Git-Projekt: Wir beschreiben einen Commit mit dem SHA-1-Präfix `28ba96a`, der sich im Commit-Graphen sieben Commits nach der Version `1.7.1` befindet:

Tags are very useful for describing any commit "`better`".
The `git describe` command gives a description consisting of the most recent tag and its relative position in the commit graph.
Here's an example from the git project: we describe a commit with the SHA-1 prefix `28ba96a`, which is located in the commit graph seven commits after version `1.7.1`:


// .Der zu beschreibende Commit in Grau hervorgehoben
.The commit to be described highlighted in gray
image::describe-screenshot.png[id="fig.describe",scaledwidth="90%",width="90%"]


[subs="quotes"]
--------
$ *git describe --tags*
v1.7.1-7-g28ba96a
--------


////
Die Ausgabe von `git describe` ist wie folgt formatiert:
////

The output of `git describe` is formatted as follows:


--------
<tag>-<position>-g<SHA-1>
--------


////
Das Tag ist `v1.7.1`; die Position besagt, dass sich sieben neue Commits zwischen dem Tag und dem beschriebenen Commit befinden.[35]
Das Kürzel `g` vor der ID besagt, dass die Beschreibung aus einem Git-Repository abgeleitet ist, was in Umgebungen mit mehreren Versionsverwaltungssystemen nützlich ist.
Standardmäßig sucht `git describe` nur nach Annotated Tags, mit der Option `--tags` erweitern Sie die Suche auch auf Lightweight Tags.
////

The tag is `v1.7.1`; the position indicates that there are seven new commits between the tag and the described commit.{fn35}
The `g` before the ID indicates that the description is derived from a Git repository, which is useful in environments with multiple version control systems.
By default, `git describe` only searches for annotated tags, but the `--tags` option extends the search to include lightweight tags.

////
Das Kommando ist sehr nützlich, weil es einen inhaltsbasierten Bezeichner in etwas für Menschen Sinnvolles übersetzt: `v1.7.1-7-g28ba96a` ist deutlich näher an `v1.7.1` als `v1.7.1-213-g3183286`.
Dadurch können Sie die Ausgaben sinnvoll -- wie im Git-Projekt auch -- direkt in die Software einkompilieren:
////

The command is very useful because it translates a content-based identifier into something useful for humans: `v1.7.1-7-g28ba96a` is much closer to `v1.7.1` than `v1.7.1-213-g3183286`.
This allows you to compile the output directly into the software in a way that makes sense, just like in the Git project:



[subs="quotes"]
--------
$ *git describe*
v1.7.5-rc2-8-g0e73bb4
$ *make*
GIT_VERSION = 1.7.5.rc2.8.g0e73bb
...
$ *./git --version*
git version 1.7.5.rc2.8.g0e73bb
--------


////
Somit weiß ein Benutzer ungefähr, welche Version er hat, und kann nachvollziehen, aus welchem Commit die Version kompiliert wurde.
////

This way a user knows roughly what version he has, and can track which commit the version was compiled from.




[[sec.undo]]
== Restoring Versions
// Versionen wiederherstellen

////
Ziel einer Versionskontrollsoftware ist es nicht nur, Änderungen zwischen Commits zu untersuchen.
Wichtig ist vor allem auch, ältere Versionen einer Datei oder ganzer Verzeichnisbäume wiederherzustellen oder Änderungen rückgängig zu machen.
Dafür sind in Git insbesondere die Kommandos `checkout`, `reset` und `revert` zuständig.
////

The goal of version control software is not just to examine changes between commits.
Above all, it is also important to restore older versions of a file or entire directory trees, or to undo changes.
In Git, the commands `checkout`, `reset`, and `revert` are particularly useful for this.

//\label{sec:checkout}

////
Das Git-Kommando `checkout` kann nicht nur Branches wechseln, sondern auch Dateien aus früheren Commits wiederherstellen.
Die Syntax lautet allgemein:
////

The Git command `checkout` can not only change branches, but also restore files from previous commits.
The syntax is general:


--------
git checkout [-f] <referenz> -- <muster>
--------


////
`checkout` löst die angegebene Referenz (und wenn diese fehlt, `HEAD`) auf einen Commit auf und extrahiert alle Dateien, die auf `<muster>` passen, in den Working Tree.
Ist `<muster>` ein Verzeichnis, bezieht sich das auf alle darin enthaltenen Dateien und Unterverzeichnisse.
Sofern Sie kein Muster explizit angeben, werden alle Dateien ausgecheckt.
Dabei werden Änderungen an einer Datei nicht einfach überschrieben, es sei denn, Sie geben die Option `-f` an (s.o.).
Außerdem wird `HEAD` auf den entsprechenden Commit (bzw. Branch) gesetzt.
////

`checkout` resolves the given reference (and `HEAD` if missing) to a commit and extracts all files matching `<pattern>` to the working tree.
If `<pattern>` is a directory, it refers to all files and subdirectories in it.
Unless you explicitly specify a pattern, all files are checked out.
Changes to a file are not simply overwritten, unless you specify the `-f` option (see above).
`HEAD` is also set to the corresponding commit (or branch).


////
Wenn Sie allerdings ein Muster angeben, dann überschreibt `checkout` diese Datei(en) ohne Nachfrage.
Um also alle Änderungen an `<datei>` zu verwerfen, geben Sie `git checkout -- <datei>` ein: Git ersetzt dann `<datei>` durch die Version im aktuellen Branch.
Auf diese Weise können Sie auch den älteren Zustand einer Datei rekonstruieren:
////

However, if you specify a pattern, `checkout` overwrites this file(s) without prompting.
So to discard all changes to `<file>`, enter `git checkout -- <file>`: Git then replaces `<file>` with the version in the current branch.
This way, you can also reconstruct the older state of a file:


[subs="quotes"]
--------
$ *git checkout ce66692 -- &lt;datei&gt;*
--------


Das doppelte Minus trennt die Muster von den Optionen bzw. Argumenten. Es ist allerdings nicht notwendig: Gibt es keine Branches oder andere Referenzen mit dem Namen, versucht Git, eine solche Datei zu finden. Die Separierung macht also nur eindeutig, dass Sie die entsprechende(n) Datei(en) wiederherstellen möchten.

Um den Inhalt einer Datei aus einem bestimmten Commit anzuschauen, ohne sie auszuchecken, nutzen Sie das folgende Kommando:


[subs="quotes"]
--------
$ *git show ce66692:&lt;file&gt;*
--------


[TIP]
==================
////
Mit `--patch` bzw. `-p` rufen Sie `git checkout` im interaktiven Modus auf.
Der Ablauf ist der gleiche wie bei `git add -p` (siehe Abschnitt 2.1.2, "Commits schrittweise erstellen"), jedoch können Sie hier Hunks einer Datei schrittweise zurücksetzen.
////

Use `--patch` or `-p` to call `git checkout` in interactive mode.
The procedure is the same as for `git add -p` (see <<sec.add-p>>), but here you can reset hunks of a file step-by-step.
==================




[[sec.detached-head]]
=== Detached HEAD

Wenn Sie einen Commit auschecken, der nicht durch einen Branch referenziert wird, befinden Sie sich im sogenannten _Detached-HEAD_-Modus:

If you check out a commit that is not referenced by a branch, you are in _detached-HEAD_ mode:


[subs="quotes"]
--------
$ *git checkout 3329661*
Note: checking out '3329661'.

You are in 'detached HEAD' state. You can look around, make
experimental changes and commit them, and you can discard any
commits you make in this state without impacting any branches
by performing another checkout.

If you want to create a new branch to retain commits you create,
you may do so (now or later) by using -b with the checkout command
again. Example:

  git checkout -b new_branch_name

HEAD is now at 3329661... Add LICENSE file
--------


////
Wie die Erklärung, die Sie durch setzen der Option `advice.detachedHead` auf `false` ausblenden können, schon warnt, werden Änderungen, die Sie nun tätigen, im Zweifel verlorengehen: Da Ihr `HEAD` danach die einzige direkte Referenz auf den Commit ist, werden weitere Commits nicht direkt von einem Branch referenziert (sie sind _unreachable_, s.o.).
////

As the explanation, which you can hide by setting the option `advice.detachedHead` to `false`, already warns you, changes you make now will be lost in case of doubt: Since your `HEAD` is the only direct reference to the commit after that, further commits are not directly referenced by a branch (they are _unreachable_, see above).


////
Im Detached-HEAD-Modus zu arbeiten bietet sich also vor allem dann an, wenn Sie schnell etwas probieren wollen: Ist der Fehler eigentlich schon im Commit `3329661` aufgetaucht? Gab es zum Zeitpunkt von `3329661` eigentlich schon die Datei `README`?
////

So working in detached HEAD mode is especially useful if you want to try something quickly: Has the bug actually already appeared in commit `3329661`? Was there actually a `README` file at the time of `3329661`?


[TIP]
============
////
Wenn Sie von dem ausgecheckten Commit aus mehr machen wollen als sich bloß umzuschauen und beispielsweise testen möchten, ob Ihre Software schon damals einen bestimmten Bug hatte, sollten Sie einen Branch erstellen:
////

If you want to do more than just look around from the commit you checked out, for example, to see if your software already had a particular bug at the time, you should create a branch:

[subs="quotes"]
--------
$ *git checkout -b &lt;temp-branch&gt;*
--------

////
Dann können Sie wie gewohnt Commits machen, ohne befürchten zu müssen, dass diese verlorengehen.
////

Then you can make commits as usual without fear of losing them.
============



[[sec.revert]]
=== Rolling Back Commits
//  Commits rückgängig machen

////
Wenn Sie alle Änderungen, die ein Commit einbringt, rückgängig machen wollen, hilft das Kommando `revert`.
Es löscht aber keinen Commit, sondern erstellt einen neuen, dessen Änderungen genau dem Gegenteil des anderen Commits entsprechen: Gelöschte Zeilen werden zu hinzugefügten und umgekehrt.
////

If you want to undo all the changes a commit makes, the `revert` command helps.
However, it does not delete a commit, but creates a new one whose changes are exactly the opposite of the other commit: Deleted lines become added lines, and vice versa.


////
Angenommen, Sie haben einen Commit, der eine Datei `LICENSE` erstellt.
Der Patch des entsprechenden Commits sieht so aus:
////

Suppose you have a commit that creates a `LICENSE` file.
The patch of the corresponding commit looks like this:


--------
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1 @@
+This software is released under the GNU GPL version 3 or newer.
--------


////
Nun können Sie die Änderungen rückgängig machen:
////

Now you can undo the changes:


[subs="quotes"]
--------
$ *git revert 3329661*
Finished one revert.
[master a68ad2d] Revert "Add LICENSE file"
 1 files changed, 0 insertions(+), 1 deletions(-)
 delete mode 100644 LICENSE
--------

Git erstellt einen neuen Commit auf dem aktuellen Branch -- sofern Sie nichts anderes angeben -- mit der Beschreibung `Revert "<Alte Commit-Nachricht>"`.
Dieser Commit sieht so aus:

Git creates a new commit on the current branch -- unless you specify otherwise -- with the description `Revert "<Old commit message>"`.
This commit looks like this:


[subs="quotes"]
--------
$ *git show*
commit a68ad2d41e9219383449d703521573477ee7da48
Author: Julius Plenz &lt;feh@mali&gt;
Date:   Mon Mar 7 05:28:47 2011 +0100

    Revert "Add LICENSE file"

    This reverts commit 3329661775af3c52e6b2ad7e9e7e7d789ba62712.

diff --git a/LICENSE b/LICENSE
deleted file mode 100644
index 3fd9c20..0000000
--- a/LICENSE
+++ /dev/null
@@ -1 +0,0 @@
-This software is released under the GNU GPL version 3 or newer.
--------


////
Beachten Sie also, dass in der Versionsgeschichte eines Projekts ab nun sowohl der Commit als auch der Revert auftauchen.
Sie machen also nur die _Änderungen_ rückgängig, löschen aber keine Informationen aus der Versionsgeschichte.
////

Note that from now on, both the commit and the revert will appear in the version history of a project.
You therefore only undo the _changes_, but do not delete any information from the version history.


////
Sie sollten daher `revert` nur einsetzen, wenn Sie eine Änderung, die bereits veröffentlicht wurde, rückgängig machen müssen.
Entwickeln Sie allerdings lokal in einem eigenen Branch, ist es sinnvoller, diese Commits komplett zu löschen (siehe dafür den folgenden Abschnitt über `reset` sowie das Thema _Rebase_, Abschnitt 4.1, "Commits verschieben – Rebase").
////

You should therefore only use `revert` if you need to undo a change that has already been published.
However, if you are developing locally in a separate branch, it makes more sense to delete these commits completely (see the following section on `reset` and the topic _Rebase_, <<sec.rebase>>).


////
Sofern Sie einen Revert durchführen wollen, allerdings nicht für sämtliche Änderungen des Commits, sondern nur für die einer Datei, können Sie sich zum Beispiel so behelfen:
////

If you want to perform a rebase, but not for all changes to the commit, but only for those to a file, you can use this procedure:



[subs="quotes"]
--------
$ *git show -R 3329661 -- LICENSE | git apply --index*
$ *git commit -m 'Revert change to LICENSE from 3329661'*
--------


////
Das Kommando `git show` gibt die Änderungen von Commit `3329661` aus, die sich auf die Datei `LICENSE` beziehen.
Die Option `-R` sorgt dafür, dass das Unified-Diff-Format "`andersherum`" angezeigt wird (_reverse_).
Die Ausgabe wird an `git apply` weitergeleitet, um die Änderungen an der Datei und dem Index vorzunehmen.
Anschließend werden die Änderungen eingecheckt.
////

The `git show` command prints the changes from commit `3329661` that apply to the `LICENSE` file.
The `-R` option causes the unified-diff format to be displayed "`the other way around`" (_reverse_).
The output is passed to `git apply` to make the changes to the file and index.
The changes are then checked in.


////
Eine weitere Möglichkeit, eine Änderung rückgängig zu machen, besteht darin, eine Datei aus einem vorherigen Commit auszuchecken, sie dem Index hinzuzufügen und neu einzuchecken:
////

Another way to undo a change is to check out a file from a previous commit, add it to the index, and check it in again:


[subs="quotes"]
--------
$ *git checkout 3329661 -- &lt;datei&gt;*
$ *git add &lt;datei&gt;*
$ *git commit -m 'Reverting &lt;datei&gt; to resemble 3329661'*
--------




[[sec.reset]]
=== Reset and the Index
//  Reset und der Index

////
Wenn Sie einen Commit gänzlich löschen, also nicht nur rückgängig machen, dann verwenden Sie `git reset`.
Das Reset-Kommando setzt den `HEAD` (und damit auch den aktuellen Branch) sowie wahlweise auch Index und Working Tree auf einen bestimmten Commit.
Die Syntax lautet `git reset [<option>] [<commit>]`.
////

If you are deleting a commit completely, not just undoing it, use `git reset`.
The reset command sets the `HEAD` (and thus the current branch), and optionally the index and working tree, to a particular commit.
The syntax is `git reset [<option>] [<commit>]`.


////
Die wichtigsten Reset-Typen sind die folgenden:
////

The most important types of resets are the following:




////
`--soft` ::
Setzt nur den `HEAD` zurück; Index und Working Tree bleiben unberührt.

`--mixed` ::
Voreinstellung, wenn Sie keine Option angeben.
Setzt `HEAD` und Index auf den angegebenen Commit, die Dateien im Working Tree bleiben aber unberührt.

`--hard` ::
Synchronisiert `HEAD`, Index und Working Tree und setzt sie auf den gleichen Commit.
Dabei gehen möglicherweise Änderungen im Working Tree verloren!
////

[horizontal]
`-{wj}-{wj}soft` ::
Resets only the `HEAD`; index and working tree remain unaffected.

`-{wj}-{wj}mixed` ::
Default setting if you do not specify an option.
Sets `HEAD` and index to the specified commit, but the files in the working tree are not affected.

`-{wj}-{wj}hard` ::
Synchronizes `HEAD`, Index and Working Tree and sets them to the same commit.
Changes in the working tree may be lost!



////
Wenn Sie `git reset` ohne Optionen aufrufen, entspricht dies einem `git reset --mixed HEAD`.
Das Kommando haben wir schon kennengelernt: Git setzt den aktuellen `HEAD` auf `HEAD` (verändert ihn also nicht) und den Index auf `HEAD` -- dabei gehen die vorher hinzugefügten Änderungen verloren.
////

If you call `git reset` without any options, this is equivalent to a `git reset --mixed HEAD`.
We've already seen this command: Git sets the current `HEAD` to `HEAD` (so it doesn't change it) and the index to `HEAD` -- in this case, the changes you added before are lost.


////
Die Anwendungsmöglichkeiten dieses Kommandos sind vielfältig und werden in den verschiedenen Kommandosequenzen wieder auftauchen.
Daher ist es wichtig, die Funktionalität zu verstehen, auch wenn es teilweise alternative Kommandos gibt, die den gleichen Effekt haben.
////

The possible uses of this command are many and varied and will reappear in the various command sequences.
Therefore it is important to understand the functionality, even if there are sometimes alternative commands that have the same effect.


////
Angenommen, Sie haben auf `master` zwei Commits gemacht, die Sie eigentlich auf einen neuen Branch verschieben wollen, um noch weiter daran zu arbeiten.
Die folgende Kommandosequenz erstellt einen neuen Branch, der auf den `HEAD` zeigt, und setzt anschließend `HEAD` und damit den aktuellen Branch `master` zwei Commits zurück.
Dann checken Sie den neuen Branch `<neues-feature>` aus.
////

Suppose you have made two commits to `master` that you actually want to move to a new branch to work on further.
The following command sequence creates a new branch pointing to `HEAD`, and then resets `HEAD` and the current branch `master` two commits.
Then check out the new branch `<new-feature>`.


[subs="quotes"]
--------
$ *git branch &lt;neues-feature&gt;*
$ *git reset --hard HEAD^^*
$ *git checkout &lt;neues-feature&gt;*
--------


////
Alternativ hat die folgende Sequenz den gleichen Effekt: Sie erstellen einen Branch `<neues-feature>`, der auf den aktuellen Commit zeigt.
Dann löschen Sie `master` und erstellen ihn neu, so dass er auf den zweiten Vorgänger des aktuellen Commits zeigt.
////

Alternatively, the following sequence has the same effect: you create a Branch `<new-feature>` that points to the current commit.
Then you delete `master` and re-create it so that it points to the second predecessor of the current commit.


[subs="quotes"]
--------
$ *git checkout -b &lt;new-feature&gt;*
$ *git branch -D master*
$ *git branch master HEAD^^*
--------




[[sec.reset-usage]]
==== Using reset
//   reset benutzen

////
Mit `reset` löschen Sie nicht beliebige Commits, sondern verschieben immer nur Referenzen.
Dadurch gehen die nicht mehr referenzierten Commits verloren, werden also quasi gelöscht (_unreachable_).
Sie können also mit `reset` nur die obersten Commits auf einem Branch löschen, nicht beliebige Commits "`irgendwo aus der Mitte`", da dies den Commit-Graphen zerstören würde.
(Für das etwas kompliziertere Löschen von Commits "`mittendrin`" siehe Rebase, Abschnitt 4.1, "Commits verschieben -- Rebase".)
////

With `reset` you do not delete any commits, but only move references.
As a result, the commits that are no longer referenced are lost, and are therefore deleted (_unreachable_).
So you can use `reset` to delete only the topmost commits on a branch, not arbitrary commits "`somewhere in the middle,`" as this would destroy the commit graph.
(For the somewhat more complicated deletion of commits "`in the middle,`" see _rebase_, <<sec.rebase>>).


////
Git speichert den ursprünglichen `HEAD` immer unter `ORIG_HEAD` ab.
Falls Sie also fälschlicherweise einen Reset durchgeführt haben, machen Sie diesen mit `git reset --hard ORIG_HEAD` rückgängig (auch wenn der Commit vermeintlich gelöscht wurde).
Das betrifft allerdings _nicht_ die verlorengegangenen Änderungen am Working Tree (die Sie noch nicht eingecheckt haben) -- diese werden unwiderruflich gelöscht.
////

Git always stores the original `HEAD` under `ORIG_HEAD`.
So if you have performed a reset by mistake, use `git reset --hard ORIG_HEAD` to undo it (even if the commit was supposedly deleted).
However, this _does not_ affect lost changes to the working tree (which you have not yet checked in) -- they are deleted irrevocably.


////
Das Resultat von oben (zwei Commits auf einen neuen Branch verschieben) erreichen Sie also alternativ auch so:
////

The result from above (moving two commits to a new branch) can also be achieved this way:



[subs="quotes"]
--------
$ *git reset --hard HEAD^^*
$ *git checkout -b &lt;new-feature&gt; ORIG_HEAD*
--------


////
Eine häufige Anwendung von `reset` ist, testweise Änderungen zu verwerfen.
Sie wollen einen Patch probieren?
Ein bisschen Debugging-Output einbauen?
Ein paar Konstanten ändern?
Gefällt das Ergebnis nicht, löscht ein `git reset --hard` alle Änderungen am Working Tree.
////

A common use of `reset` is to discard changes on a test basis.
You want to try a patch?
Add some debugging output?
Change a few constants?
If you don't like the result, a `git reset --hard` deletes all changes to the working tree.


////
Auch können Sie mit Hilfe von `reset` Ihre Versionsgeschichte "`schön machen`".
Wenn Sie beispielsweise ein paar Commits auf einem auf `master` aufbauenden Branch `<feature>` haben, die aber nicht  sinnvoll gegliedert (oder viel zu groß) sind, können Sie einen Branch `<reorder-feature>` erstellen und _alle_ Änderungen in neue Commits verpacken:
////

You can also use `reset` to "`make your version history nice.`"
For example, if you have a few commits on a branch `<feature>` based on `master`, but they are not well structured (or much too large), you can create a branch `<reorder-feature>` and pack all changes into new commits:


[subs="quotes"]
--------
$ *git checkout -b &lt;reorder-feature&gt; &lt;feature&gt;*
$ *git reset master*
$ *git add -p*
$ *git commit*
$ ...
--------


////
Das Kommando `git reset master` setzt Index und `HEAD` auf den Stand von `master`.
Ihre Änderungen im Working Tree bleiben aber erhalten, d.h. alle Änderungen, die den Branch `<feature>` von `master` unterscheiden, sind nun lediglich in den Dateien im Working Tree enthalten.
Jetzt können Sie die Änderungen _schrittweise_ per `git add -p` hinzufügen und in (mehrere) handliche Commits verpacken.[36]
////

The command `git reset master` sets index and `HEAD` to the state of `master`.
However, your changes in the working tree are preserved, i.e. all changes that distinguish the branch `<feature>` from `master` are now only contained in the files in the working tree.
Now you can add the changes _incrementally_ using `git add -p` and package them into (several) handy commits.{fn36}


////
Angenommen, Sie arbeiten an einer Änderung und wollen diese temporär einchecken (um später daran weiterzuarbeiten).
Dann können Sie folgende Kommandos verwenden:
////

Suppose you are working on a change and want to check it in temporarily (to continue working on it later).
You can then use the following commands:


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git commit -m 'feature (noch unfertig)'*
(später)
$ *git reset --soft HEAD^*
(weiterarbeiten)
--------


////
Das Kommando `git reset --soft HEAD^` setzt den `HEAD` einen Commit zurück, lässt allerdings den Index sowie den Working Tree unberührt.
Alle Änderungen aus Ihrem temporären Commit sind also nach wie vor im Index und Working Tree, aber der eigentliche Commit geht verloren.
Sie können nun weitere Änderungen machen und später einen neuen Commit erstellen.
Eine ähnliche Funktionalität stellt die Option `--amend` für `git commit` sowie auch das Kommando `git stash` (dt. "`verstauen`") bereit, das in Abschnitt 4.5, "Veränderungen auslagern -- git stash" erklärt wird.
////

The command `git reset --soft HEAD^` resets the `HEAD` one commit, but leaves the index and the working tree untouched.
So all changes from your temporary commit are still in the index and working tree, but the actual commit is lost.
You can now make further changes and create a new commit later.
Similar functionality is provided by the `--amend` option for `git commit`, as well as the `git stash` command, which is explained in <<sec.stash>>.



[[sec.merge]]
== Merging Branches
// Branches zusammenführen: Merges

////
Das Zusammenführen von Branches nennt man in Git _mergen_; der Commit, der zwei oder mehr Branches miteinander verbindet, heißt entsprechend _Merge-Commit_.
////

Merging branches is called _merging_ in Git; the commit that merges two or more branches together is called a _merge commit_.


////
Git stellt das Subkommando `merge` bereit, mit dem Sie einen Branch in einen anderen integrieren.
Das bedeutet, dass alle Änderungen, die Sie auf dem Branch getätigt haben, in den aktuellen einfließen.
////

Git provides the `merge` subcommand, which allows you to merge one branch into another.
This means that any changes you make to the branch will be reflected in the current one.


////
Beachten Sie, dass das Kommando den angegebenen Branch in den _aktuell ausgecheckten Branch_ (d.h. `HEAD`) integriert.
Das Kommando benötigt also nur ein Argument:
////

Note that the command integrates the specified branch into the _currently checked-out branch_ (i.e., `HEAD`).
The command therefore only needs one argument:


[subs="quotes"]
--------
$ *git merge &lt;branch-name&gt;*
--------


////
Wenn Sie wohlüberlegt mit Ihren Branches hantieren, dürfte es keine Probleme beim Mergen geben.
Wenn doch, dann stellen wir in diesem Abschnitt auch Strategien vor, wie Sie Merge-Konflikte lösen.
////

If you handle your branches carefully, there should be no problems with merging.
If there are, then this section also presents strategies for resolving merge conflicts.


////
Zunächst schauen wir uns einen Merge-Vorgang auf Objektebene an.
////

First, we will look at an object-level merge process.



[[sec.merge-detail]]
=== Two-Branches Merge
//  Zwei Branches verschmelzen

////
Die zwei Branches `topic` und `master`, die Sie mergen wollen, referenzieren jeweils den aktuellsten Commit in einer Kette von Commits (F und D), und diese beiden Commits wiederum einen Tree (entspricht dem obersten Verzeichnis Ihres Projekts).
////

The two branches, `topic` and `master`, that you want to merge, each reference the most recent commit in a chain of commits (F and D), and these two commits in turn reference a tree (corresponding to the top-level directory of your project).


////
Zunächst berechnet Git eine sogenannte _Merge-Basis_, also einen Commit, den beide zu verschmelzenden Commits als gemeinsamen Vorfahren haben.
In der Regel gibt es mehrere solcher Basen -- im untenstehenden Diagramm A und B -- , dann wird die neueste (die also die anderen Basen als Vorfahren hat) verwendet.[37]
Anschaulich gesprochen, ist dies für einfache Fälle der Commit, an dem die Branches divergiert haben (also B).
////

First, Git calculates a so-called _merge base_, that is, a commit that both of the commits to be merged have as common ancestors.
Usually there are several such bases -- in the diagram below, A and B -- and then the most recent one (which has the other bases as ancestors) is used.{fn37}
In simple terms, this is the commit where the branches diverged (i.e., B).


////
Wenn Sie nun zwei Commits miteinander verschmelzen wollen (D und F zu M), dann müssen also die von den Commits referenzierten Trees verschmolzen werden.
////

Now, if you want to merge two commits (D and F to M), then the trees referenced by the commits must be merged.



// .Merge-Basis und Merge-Commit
.Merge base and merge commit
image::merge-base-commit.png[id="fig.merge-base-commit",scaledwidth="70%",width="70%"]



////
Dafür geht Git so vor:[38] Wenn ein Tree-Eintrag (ein weiterer Tree oder ein Blob) in beiden Commits gleich ist, wird genau dieser Tree-Eintrag auch im Merge-Commit übernommen.
Das passiert in zwei Fällen:
////

Git does this as follows:{fn38} If a tree entry (another tree or a blob) is the same in both commits, then that very tree entry will be taken over in the merge commit.
This happens in two cases:

////
. Eine Datei wurde von keinem der beiden Commits geändert, oder ein Unterverzeichnis enthält keine geänderte Datei: Im ersten Fall ist die Blob-SHA-1-Summe dieser Datei in beiden Commits gleich, im zweiten Fall wird von beiden Commits das gleiche Tree-Objekt referenziert.
Der referenzierte Blob bzw. Tree ist also derselbe wie der in der Merge-Basis referenzierte.

. Eine Datei wurde _auf beiden Seiten_ und _äquivalent_ geändert (gleiche Blobs).
Das passiert zum Beispiel, wenn aus dem einen Branch alle Änderungen an einer Datei per `git cherry-pick` (siehe Abschnitt 3.5, "Einzelne Commits übernehmen: Cherry-Pick") übernommen wurden.
Der referenzierte Blob ist dann _nicht_ derselbe wie in der Merge-Basis.
////

. A file has not been changed by either commit, or a subdirectory does not contain a changed file: In the first case, the blob SHA 1 sum of this file is the same in both commits.
In the second case, the same tree object is referenced by both commits.
The referenced blob or tree is therefore the same as the one referenced in the merge base.

. A file was changed _on both sides_ and _equivalently_ (same blobs).
This happens, for example, if all changes to a file were copied from one branch using `git cherry-pick` (see <<sec.cherry-pick>>).
The referenced blob is then _not_ the same as in the merge base.



////
Wenn ein Tree-Eintrag in einem der Commits verschwindet, im anderen aber noch vorhanden ist und 'der gleiche ist wie in der Merge-Basis', dann wird er nicht übernommen.
Das entspricht dem Löschen einer Datei oder eines Verzeichnisses, wenn an der Datei auf der anderen Seite keine Änderungen vorgenommen wurden.
Analog, wenn ein Commit einen neuen Tree-Eintrag mitbringt, wird dieser in den Merge-Tree übernommen.
////

If a tree entry disappears in one of the commits, but is still present in the other, and is the same as in the merge base, then it is not taken over.
This is equivalent to deleting a file or directory if no changes have been made to the file on the other side.
Similarly, if a commit brings a new tree entry, it is copied to the merge tree.


////
Was passiert nun, wenn eine Datei aus den Commits verschiedene Blobs aufweist, die Datei also zumindest auf der einen Seite verändert wurde?
Im Falle, dass einer der Blobs der gleiche ist wie in der Merge-Basis, wurden nur auf einer Seite Änderungen an der Datei durchgeführt -- Git kann diese Änderungen also einfach übernehmen.
////

Now what happens if a file from the commits has different blobs, that is, the file has been changed at least on one side?
In the event that one of the blobs is the same as in the merge base, only one side of the file has been changed, so Git can simply adopt those changes.


////
Wenn sich aber _beide_ Blobs von der Merge-Basis unterscheiden, könnte es möglicherweise zu Problemen kommen.
Zunächst versucht Git, die Änderungen beider Seiten zu übernehmen.
////

However, if _both_ blobs are different from the merge base, you might run into problems.
First, Git tries to apply the changes on both sides.


////
Dafür wird in der Regel ein _3-Wege-Merge_-Algorithmus verwendet.
Im Gegensatz zum klassischen 2-Wege-Merge-Algorithmus, der eingesetzt wird, wenn Sie zwei unterschiedliche Versionen A und B einer Datei haben und diese zusammenführen wollen, bezieht dieser 3-Wege-Algorithmus eine dritte Version C der Datei ein, extrahiert aus obiger Merge-Basis.
Der Algorithmus kann daher, weil ein gemeinsamer Vorgänger der Datei bekannt ist, in vielen Fällen besser (d.h. nicht nur anhand der Zeilennummer bzw. des Kontextes) entscheiden, wie Änderungen zusammengeführt werden.
In der Praxis werden so viele trivial lösbare Merge-Konflikte schon automatisch ohne Zutun des Nutzers gelöst.
////

A _3-way merge_ algorithm is usually employed for this purpose.
Unlike the classic 2-way merge algorithm, which is used when you have two different versions A and B of a file and want to merge them, this 3-way algorithm involves a third version C of the file, extracted from the above merge base.
Therefore, because a common ancestor of the file is known, the algorithm can in many cases better (that is, not only based on the line number or context) decide how to merge changes.
In practice, so many trivial merge conflicts are already solved automatically without user intervention.


////
Es gibt allerdings Konflikte, die kein noch so guter Merge-Algorithmus zusammenführen kann.
Das passiert zum Beispiel, wenn in Version A der Datei der Kontext direkt vor einer Änderung in Datei B geändert wurde, oder, schlimmer noch, Version A und B und C unterschiedliche Versionen einer Zeile aufweisen.
////

However, there are conflicts that no merge algorithm, no matter how good, can merge.
This happens, for example, if the context in version A of the file was changed just before a change in file B, or, worse still, version A and B and C have different versions of a line.


////
Einen solchen Fall nennt man _Merge-Konflikt_.
Git führt alle Dateien so gut es geht zusammen und präsentiert dem Nutzer dann die in Konflikt stehenden Änderungen, damit dieser sie manuell verschmelzen (und damit den Konflikt lösen) kann (siehe dafür Abschnitt 3.4, "Merge-Konflikte lösen").

////
Such a case is called a _merge conflict_.
Git merges all the files as best it can, and then presents the conflicting changes to the user so they can manually merge them (and thus resolve the conflict) (see <<sec.merge-conflicts>>).


////
Zwar ist es grundsätzlich möglich, mit einem speziell auf die jeweilige Programmiersprache ausgerichteten Algorithmus eine syntaktisch korrekte Auflösung zu erzeugen -- allerdings kann ein Algorithmus nicht hinter die _Semantik_ des Codes schauen, also die Bedeutung des Codes erfassen.
Daher wäre eine so generierte Lösung in der Regel nicht sinnvoll.
////

Although it is basically possible to generate a syntactically correct resolution with an algorithm that is specially designed for the respective programming language, an algorithm cannot look beyond the _semantics_ of the code, i.e., cannot grasp the meaning of the code.
Therefore, a solution generated in this way would usually not make sense.



// ********** ARRIVED HERE!!! **********


[[sec.merge-ff]]
=== Fast-Forward-Merges: Einen Branch vorspulen

Das Kommando `git merge` erzeugt nicht immer einen
Merge-Commit. Ein trivialer Fall, der aber häufig vorkommt, ist der
sogenannte _Fast-Forward-Merge_, also ein Vorspulen des Branches.

Ein Fast-Forward-Merge tritt dann auf, wenn ein Branch, z.B.{empty}{nbsp}`topic`, Kind eines zweiten Branches, `master`,
ist:

.Vor dem _Fast-Forward_-Merge
image::ff-vorher.png[id="fig.merge-ff-before",scaledwidth="90%",width="90%"]

Ein einfaches `git merge topic` im Branch `master` führt
nun dazu, dass `master` einfach weitergerückt wird -- es wird
kein Merge-Commit erzeugt.

.Nach dem _Fast-Forward_-Merge – es wurde kein Merge-Commit erzeugt
image::ff-nachher.png[id="fig.merge-ff-after",scaledwidth="90%",width="90%"]

Ein solches Verhalten geht natürlich nur dann, wenn die beiden
Branches nicht divergiert haben, wenn also die Merge-Basis beider
Branches einer der beiden Branches selbst ist, in diesem Falle
`master`.

Dieses Verhalten ist häufig wünschenswert:


. Sie wollen Upstream-Änderungen, also Änderungen aus einem
  anderen Git-Repository, integrieren. Dafür verwenden Sie
  typischerweise ein Kommando wie `git merge origin/master`.
  Auch ein `git pull` wird einen Merge ausführen. Wie Sie
  Änderungen zwischen Git-Repositories austauschen, behandeln wir in
  <<ch.distributed-git>>.

. Sie wollen einen experimentellen Branch einpflegen. Da Sie
  besonders einfach und schnell Branches in Git erstellen, empfiehlt
  es sich, für jedes Feature einen neuen Branch anzufangen.  Wenn Sie
  nun etwas Experimentelles auf einem Branch ausprobiert haben und
  dies integrieren wollen, ohne dass man einen ``Zeitpunkt der
  Integration__ erkennen kann, dann geschieht das per
  _Fast-Forward_.


[TIP]
===============
Mit den Optionen `--ff-only` und `--no-ff` können
Sie das Merge-Verhalten anpassen. Wenn Sie die erste Option verwenden
und die Branches können nicht per Fast-Forward zusammengeführt
werden, wird Git mit einer Fehlermeldung abbrechen. Die zweite
Option zwingt Git dazu, einen Merge-Commit zu erstellen, obwohl ein
Fast-Forward möglich gewesen wäre.
===============

Es gibt verschiedene Meinungen, ob man Änderungen immer per
Fast-Forward integrieren sollte oder lieber einen Merge-Commit
erstellt, obwohl dies nicht unbedingt nötig ist. Die Resultate sind in
beiden Fällen gleich: Die Änderungen aus einem Branch werden in
einen anderen integriert.

Wenn Sie allerdings einen Merge-Commit erstellen, dann wird die
_Integration_ eines Features deutlich. Betrachten Sie die beiden
folgenden Ausschnitte aus der Versionsgeschichte eines Projekts:



.Integration eines Features mit und ohne Fast-Forward
image::ff-no-ff-vergleich.png[id="fig.ff-vergleich",scaledwidth="80%",width="80%"]

Im oberen Fall können Sie nicht ohne weiteres erkennen, welche
Commits ehemals im Branch `sha1-caching` entwickelt wurden,
also mit einem spezifischen Feature der Software zu tun haben.

In der unteren Version jedoch können Sie auf den ersten Blick
erkennen, dass es genau vier Commits auf diesem Branch gab und er
dann integriert wurde. Da parallel nichts entwickelt wurde, wäre der
Merge-Commit prinzipiell unnötig, allerdings macht er die Integration
des Features deutlich.


[TIP]
===============
Es bietet sich daher an, statt auf die Magie von `git merge` zu
vertrauen, zwei Aliase (siehe auch <<sec.git-alias>>) zu kreieren, die
einen Fast-Forward-Merge forcieren oder verbieten:

--------
nfm = merge --no-ff     # no-ff-merge
ffm = merge --ff-only   #    ff-merge
--------
===============



Ein expliziter Merge-Commit ist auch hilfreich, weil Sie diesen mit
einem einzigen Kommando rückgängig machen können.
Dies ist beispielsweise dann sinnvoll, wenn Sie einen Branch integriert
haben, der aber Fehler aufweist: Wenn der Code in Produktion läuft, ist
es häufig wünschenswert, die gesamte Änderung vorerst wieder auszubauen,
bis der Fehler korrigiert ist. Verwenden Sie dafür:

------
git revert -m 1 <merge-commit>
------

Git produziert dann einen neuen Commit, der alle Änderungen rückgängig
macht, die durch den Merge verursacht wurden. Die Option `-m 1` gibt
hier an, welche "`Seite`" des Merges als _Mainline_, also stabile
Entwicklungslinie, gelten soll: deren Änderungen bleiben bestehen.
Im obigen Beispiel würde `-m 1` dazu führen, dass die Änderungen der
vier Commits aus dem Branch `sha1-caching`, also dem zweiten Strang des
Merges, rückgängig gemacht würden.

[[sec.merge-strategies]]
=== Merge-Strategien

Git kennt fünf verschiedene Merge-Strategien, deren Verhalten
teilweise noch durch Strategie-Optionen weiter angepasst werden
kann. Die Strategie bestimmen Sie per `-s`, so dass ein
Merge-Aufruf  wie folgt lautet:

--------
git merge -s <strategie> <branch>
--------

Manche dieser Strategien können nur zwei Branches zusammenführen,
andere eine beliebige Anzahl.



`resolve`:: Die `resolve`-Strategie kann
    zwei Branches mit Hilfe einer 3-Wege-Merge-Technik zusammenführen.
    Als Merge-Basis wird dafür die neueste (beste) aller
    möglichen Basen verwendet. Diese Strategie ist schnell und erzeugt
    generell gute Ergebnisse.

`recursive`:: Dies ist die Standard-Strategie, die
    Git einsetzt, um zwei Branches zu verschmelzen. Auch hier wird ein
    3-Wege-Merge-Algorithmus eingesetzt. Allerdings geht diese
    Strategie geschickter vor als `resolve`: Existieren mehrere
    Merge-Basen, die allesamt "`gleiche Berechtigung`"
    haben,{fn39}
    dann führt Git zunächst diese Basen zusammen, um das Ergebnis dann
    als Merge-Basis für den 3-Wege-Merge-Algorithmus zu verwenden.
    Neben der Tatsache, dass dadurch auch Merges mit
    Dateiumbenennungen besser verarbeitet werden können, hat ein
    Testlauf auf der Versionsgeschichte des Linux-Kernels gezeigt,
    dass durch diese Strategien weniger Merge-Konflikte auftreten als
    mit der `resolve`-Strategie. Die Strategie kann durch
    diverse Optionen angepasst werden (s.u.).

`octopus`:: Standard-Strategie, wenn drei oder
    mehr Branches zusammengeführt werden. Die Octopus-Strategie kann
    im Gegensatz zu den beiden vorher genannten Strategien nur dann
    Merges durchführen, wenn kein Fehler auftritt, also keine manuelle
    Konfliktauflösung notwendig ist. Die Strategie ist besonders
    dafür gedacht, viele Topic-Branches, von denen bekannt ist, dass
    sie sich mit der Mainline (Haupt-Entwicklungsstrang) vertragen, zu
    integrieren.

`ours`:: Kann beliebig viele Branches
    verschmelzen, nutzt aber keinen Merge-Algorithmus. Stattdessen
    werden immer die Blobs bzw. Trees des aktuellen Branch (d.h.
    von dem Branch, von dem aus Sie `git merge` eingegeben
    haben) übernommen. Die Strategie wird vor allem dann verwendet,
    wenn Sie alte Entwicklungen mit dem aktuellen Stand der Dinge
    überschreiben wollen.

`subtree`:: Funktioniert wie `recursive`,
allerdings vergleicht die Strategie die Trees nicht ``auf
gleicher Augenhöhe__, sondern bemüht sich, den Tree der einen
Seite als Subtree der anderen Seite zu finden und erst dann zu
verschmelzen. Diese Strategie ist zum Beispiel dann sinnvoll, wenn
Sie das Unterverzeichnis `Documentation/` Ihres Projekts
in einem separaten Repository verwalten. Dann können Sie die
Änderungen aus diesem Repository in das Haupt-Repository
übernehmen, indem Sie über  `git pull -s subtree
<documentation-repo>` die `subtree`-Strategie bemühen,
die die Inhalte von `<documentation-repo>` als
Unterverzeichnis des Haupt-Repositorys erkennt und den
Merge-Vorgang nur auf das entsprechende Unterverzeichnis anwendet.
Dieses Thema wird eingehender in <<sec.subprojects>> behandelt.


[[sec.recursive-options]]
=== Optionen für die recursive-Strategie

Die Default-Strategie `recursive` kennt mehrere Optionen, die das
Verhalten besonders bezüglich der Konfliktlösung anpassen. Sie
bestimmen sie über die Option `-X`; die Syntax lautet also:

--------
git merge -s recursive -X <option> <branch>
--------

Sofern Sie nur zwei Branches mergen, müssen Sie die
`recursive`-Strategie nicht explizit per `-s recursive`
angeben.

Da die Strategie nur zwei Branches zusammenführen kann, ist es
möglich, von _unserer_ (engl. _our_) und _deren_ (engl.
_theirs_) Version zu sprechen: _unsere_ Version ist dabei
der ausgecheckte Branch beim Merge-Vorgang, während _deren_
Version den Branch, den Sie integrieren wollen, referenziert.


`ours`:: Wenn ein Merge-Konflikt auftritt, der
    normalerweise manuell gelöst werden müsste, wird stattdessen
    _unsere_ Version verwendet. Die Strategie-_Option_
    unterscheidet sich allerdings von der _Strategie_{empty}{nbsp}`ours`, denn dort werden jegliche Änderungen der
    Gegenseite(n) ignoriert. Die `ours`-Option hingegen
    übernimmt alle Änderungen unserer sowie der Gegenseite und gibt
    nur im Konfliktfall und nur an den Konfliktstellen
    _unserer_ Seite Vorrang.

`theirs`:: Wie `ours`, nur dass genau
    gegenteilig vorgegangen wird: bei Konflikten wird _deren_
    Version bevorzugt.

`ignore-space-change`, `ignore-all-space`, `ignore-space-at-eol`:: Da Whitespace in den meisten Sprachen keine syntaktische Rolle spielt, können Sie mit diesen Optionen Git anweisen, im Falle eines Merge-Konfliktes zu probieren, ob dieser automatisch lösbar ist, wenn Whitespace keine Rolle spielt. Ein häufiger Anwendungsfall ist, dass ein Editor oder eine IDE Quellcode automatisch umformatiert hat.
+
Die Option `ignore-space-at-eol` ignoriert Whitespace am Ende der
Zeile, was insbesondere dann hilfreich ist, wenn beide Seiten
verschiedene Zeilenende-Konventionen (LF/CRLF) verwenden. Geben
Sie `ignore-space-change` an, wird _außerdem_ Whitespace als reiner    Trenner betrachtet: Für den Vergleich einer Zeile ist also
unwesentlich, wie viele Leerzeichen oder Tabs an einer Stelle stehen --
eingerückte Zeilen bleiben eingerückt, und getrennte Wörter
bleiben getrennt. Die Option `ignore-all-space` ignoriert jeglichen
Whitespace.
+
Generell geht die Strategie so vor: Falls _deren_ Version nur durch
die angegebene Option abgedeckte Whitespace-Änderungen hineinbringt,
werden diese ignoriert und _unsere_ Version verwendet; bringt sie
weitere Änderungen mit, und _unsere_ Version hat nur
Whitespace-Änderungen, so wird _deren_ Version verwendet. Wenn aber
auf beiden Seiten nicht nur Whitespace geändert wurde, so gibt es
weiterhin einen Merge-Konflikt.
+
Generell empfiehlt es sich nach einem Merge, den Sie nur mit Hilfe
einer dieser Optionen lösen konnten, die entsprechenden Dateien noch
einmal zu normalisieren, also die Zeilenenden und Einrückungen
einheitlich zu machen.

`subtree=<tree>`:: Ähnlich wie die
`subtree`-_Strategie_, allerdings wird hier ein
expliziter Pfad angegeben. Analog zum obigen Beispiel würden Sie
+
------------
git pull -Xsubtree=Documentation <documentation-repo>
------------
+
verwenden.




[[sec.merge-conflicts]]
== Merge-Konflikte lösen

Wie bereits beschrieben, sind manche Konflikte nicht durch Algorithmen
aufzulösen -- hier ist manuelle Nachbesserung nötig.  Gute
Team-Koordination sowie schnelle Integrationszyklen können größere
Merge-Konflikte minimieren. Aber gerade in der frühen Entwicklung,
wenn möglicherweise die Interna einer Software geändert werden, statt
neue Features hinzuzufügen, kann es zu Konflikten kommen.

Wenn Sie in einem größeren Team arbeiten, dann ist in der Regel der
Entwickler, der maßgeblich am konfliktbehafteten Code gearbeitet hat,
dafür verantwortlich, eine Lösung zu finden. Eine solche
Konfliktlösung ist aber meist nicht schwierig, wenn der Entwickler
einen guten Überblick über die Software allgemein und insbesondere
über sein Stück Code und dessen Interaktion mit anderen Teilen
hat.

Wir werden die Lösung eines Merge-Konflikts anhand eines einfachen
Beispiels in C durchgehen. Betrachten Sie die folgende Datei `output.c`:

--------
int i;

for(i = 0; i < nr_of_lines(); i++)
    output_line(i);

print_stats();
--------

Das Stück Code geht alle Zeilen einer Ausgabe durch und gibt diese
nacheinander aus. Zuletzt liefert es eine kleine Statistik.

Nun ändern zwei Entwickler etwas an diesem Code. Der erste,
Axel, schreibt eine Funktion, die die Zeilen umbricht, bevor sie
ausgegeben werden, und ersetzt im obigen Codestück
`output_line` durch seine verbesserte Version
`output_wrapped_line`:

--------
int i;
int tw = 72;

for(i = 0; i < nr_of_lines(); i++)
    output_wrapped_line(i, tw);

print_stats();
--------

Die zweite Entwicklerin, Beatrice, modifiziert den Code, damit ihre
neu eingeführte Konfigurationseinstellung `max_output_lines`
honoriert wird, und nicht zu viele Zeilen ausgegeben werden:

--------
int i;

for(i = 0; i < nr_of_lines(); i++) {
    if(i > config_get("max_output_lines"))
        break;
    output_line(i);
}

print_stats();
--------

Beatrice verwendet also die "`veraltete`" Version
`output_line`, und Axel hat noch nicht das Konstrukt, das die
Konfigurationseinstellung überprüft.

Nun versucht Beatrice, ihre Änderungen auf Branch B in den
Branch `master` zu übernehmen, auf dem Axel seine Änderungen
 schon integriert hat:

[subs="quotes"]
--------
$ *git checkout master*
$ *git merge B*
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
Automatic merge failed; fix conflicts and then commit the result.
--------

In der Datei `output.c` platziert Git nun sogenannte
_Konflikt-Marker_, unten halbfett hervorgehoben, die anzeigen, wo
sich Änderungen überschneiden. Es gibt zwei Seiten: Zum einen
`HEAD`, d.h. der Branch, in den Beatrice die Änderungen
übernehmen will -- in diesem Falle `master`. Die andere Seite ist
der zu integrierende Branch -- B. Die beiden Seiten werden
durch eine Reihe von Gleichheitszeichen voneinander getrennt:

[subs="quotes"]
--------
int i;
int tw = 72;

*&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD*
for(i = 0; i &lt; nr_of_lines(); pass:quotes[i++])
    output_wrapped_line(i, tw);
*=======*
for(i = 0; i &lt; nr_of_lines(); pass:quotes[i++]) {
    if(i &gt; config_get("max_output_lines"))
        break;
    output_line(i);
}
*&gt;&gt;&gt;&gt;&gt;&gt;&gt;*

print_stats();
--------

Zu beachten ist hier, dass nur die wirklich _konfliktbehafteten_
Änderungen von Beatrice beanstandet werden. Axels Definition von
`tw` weiter oben wird, obwohl bei Beatrice noch nicht
vorhanden, anstandslos übernommen.

Beatrice muss nun den Konflikt lösen. Das passiert, indem sie zunächst
die Datei direkt editiert, den Code so abwandelt, wie er sein soll,
und anschließend die Konflikt-Marker entfernt. Wenn Axel in seiner
Commit-Nachricht entsprechend ausführlich dokumentiert hat{fn40}
wie seine neue Funktion arbeitet, sollte das schnell gehen:

--------
int i;
int tw = 72;

for(i = 0; i < nr_of_lines(); i++) {
    if(i > config_get("max_output_lines"))
        break;
    output_wrapped_line(i, tw);
}

print_stats();
--------

Anschließend muss Beatrice die Änderungen per `git add`
hinzufügen. Sofern keine Konflikt-Marker mehr in der Datei verbleiben,
ist dies für Git das Zeichen, dass ein Konflikt gelöst wurde.
Schließlich muss das Resultat noch eingecheckt werden:

[subs="quotes"]
--------
$ *git add output.c*
$ *git commit*
--------

In der Commit-Nachricht sollte unbedingt stehen, wie dieser Konflikt
gelöst wurde. Auch mögliche Seiteneffekte auf andere Teile des
Programms sollten nicht unerwähnt bleiben.

Normalerweise sind Merge-Commits "`leer`", d.h. in
`git show` erscheint keine Diff-Ausgabe (weil die Änderungen ja
von anderen Commits verursacht wurden). Im Falle eines Merge-Commits,
der einen Konflikt löst, ist dies aber anders:

[subs="quotes"]
--------
$ *git show*
commit 6e6c55810c884356402c078f30e45a997047058e
Merge: f894659 256329f
Author: Beatrice &lt;pass:quotes[beatrice@gitbu.ch]&gt;
Date:   Mon Feb 28 05:59:36 2011 +0100

    Merge branch \_B_

    * B:
      honor max_output_lines config option

    Conflicts:
        output.c

diff --cc output.c
index a2bd8ed,f4c8bec..e39e39d
--- a/output.c
pass:quotes[\+++ b/output.c]
@@@ -1,7 -1,9 +1,10 @@@
  int i;
 pass:quotes[*+*]int tw = 72;

pass:quotes[*-*] for(i = 0; i &lt; nr_of_lines(); pass:quotes[i++])
pass:quotes[*+*] for(i = 0; i &lt; nr_of_lines(); pass:quotes[i++]) {
pass:quotes[*+*]     if(i &gt; config_get("max_output_lines"))
pass:quotes[*+*]         break;
 pass:quotes[*-*]    output_line(i);
 pass:quotes[*+*]    output_wrapped_line(i, tw);
pass:quotes[*+*] }

  print_stats();
--------




Diese _kombinierte_ Diff-Ausgabe unterscheidet sich vom üblichen
Unidiff-Format: Es gibt nicht nur _eine_ Spalte mit den Markern für
hinzugefügt (`+`), entfernt (`-`) und Kontext bzw.
ungeändert (&#x2423;), sondern zwei. Git vergleicht also
das Resultat mit _beiden_ Vorfahren. Die in der zweiten Spalte
geänderten Zeilen entsprechen genau denen des Commits von Axel; die
(halbfett markierten) Änderungen in der ersten Spalte sind der Commit
von Beatrice inklusive Konfliktlösung.

//\label{sec:merge-conflicts-detailed}

Der Standard-Weg, wie oben gesehen, ist der folgende:


. konfliktbehaftete Datei öffnen

. Konflikt lösen, Marker entfernen

. Datei per `git add` als "`gelöst`" markieren

. Schritt eins bis drei für alle Dateien wiederholen, in denen
  Konflikte auftraten

. Konfliktlösungen per `git commit` einchecken


Wenn Sie ad hoc nicht wissen, wie der Konflikt zu lösen ist (und zum
Beispiel den ursprünglichen Entwickler damit beauftragen wollen, eine
konfliktfreie Version des Codes zu produzieren), können Sie per
`git merge --abort` den Merge-Vorgang abbrechen -- also den
Zustand Ihres Working Trees wieder auf den Stand bringen, auf dem er
war, bevor Sie den Merge-Vorgang angestoßen haben. Dieses Kommando
bricht auch einen Merge ab, den Sie schon teilweise gelöst haben.
Achtung: Dabei gehen alle nicht eingecheckten Änderungen verloren.


[TIP]
=====================
Um einen Überblick zu erhalten, welche Commits für den
Merge-Konflikt relevante Änderungen an Ihrer Datei verursacht haben,
können Sie das Kommando

--------
git log --merge -p -- <datei>
--------

verwenden.  Git listet dann die Diffs von Commits auf, die seit der
Merge-Basis Änderungen an `<datei>` vorgenommen haben.
=====================

Wenn Sie sich in einem Merge-Konflikt befinden, liegt eine Datei mit
Konflikten in drei Stufen (_Stages_) vor: Stufe eins enthält die
Version der Datei in der Merge-Basis (also die gemeinsame
Ursprungsversion der Datei), Stufe zwei enthält die Version aus dem
`HEAD` (also die Version aus dem Branch, _in den_ Sie
mergen). Stufe drei enthält schließlich die Datei in der Version des
zu integrierenden Branches (dieser hat die symbolische Referenz
`MERGE_HEAD`). Im Working Tree befindet sich die Kombination
dieser drei Stufen mit Konflikt-Markern. Sie können diese Versionen
aber jeweils mit `git show :<n>:<datei>` anzeigen:

[subs="quotes"]
--------
$ *git show :1:output.c*
$ *git show :2:output.c*
$ *git show :3:output.c*
--------

Mit einem speziell für 3-Wege-Merges entwickelten Programm behalten
Sie allerdings wesentlich leichter den Überblick. Das Programm
betrachtet die drei Stufen einer Datei, visualisiert sie entsprechend
und bietet Ihnen Möglichkeiten an, Änderungen hin- und herzuschieben.

[[sec.mergetool]]
=== Hilfe beim Merge: mergetool

Bei nicht-trivialen Merge-Konflikten empfiehlt sich ein Merge-Tool,
das die drei Stufen einer Datei entsprechend visualisiert und dadurch
die Lösung des Konflikts erleichtert.


Gängige IDEs und Editoren wie z.B. Vim und Emacs bieten einen
solchen Modus an. Außerdem gibt es externe Tools, wie zum Beispiel
_KDiff3_{empty}{fn41}
und
_Meld_{empty}{fn42}.
Letzteres visualisiert besonders gut, wie sich eine Datei zwischen den
Commits verändert hat.

.Der Beispiel-Merge-Konflikt, im Merge-Tool "`Meld`" visualisiert
image::meld-example.png[id="fig.meld",scaledwidth="100%",width="100%"]

Sie starten ein solches Merge-Tool über `git mergetool`. Git wird alle
Dateien, die Konflikte enthalten, durchgehen und jeweils (wenn Sie
Eingabe drücken) in einem Merge-Tool anzeigen.  Per Default ist das
Vimdiff{empty}{fn43}.



Ein solches Programm wird in der Regel die drei Versionen einer Datei
-- _unsere_ Seite, _deren_ Seite sowie die soweit wie
möglich zusammengeführte Datei inklusive Konflikt-Markern -- in drei
Spalten nebeneinander anzeigen, letztere sinnvollerweise in der Mitte.
Wesentlich ist immer, dass Sie die Änderung (Konfliktlösung) in der
mittleren Datei machen, also auf der Working-Copy. Die anderen Dateien
sind temporär und werden wieder gelöscht, wenn das Merge-Tool beendet
wurde.

Prinzipiell können Sie ein beliebiges anderes Tool verwenden. Das
`mergetool`-Script legt lediglich die drei Stufen der Datei mit
entsprechendem Dateinamen ab und startet das Diff-Tool auf diesen
drei Dateien. Beendet sich das Programm wieder, überprüft Git, ob noch
Konflikt-Marker in der Datei enthalten sind -- wenn nicht, wird Git
annehmen, dass der Konflikt erfolgreich gelöst wurde, und die Datei
automatisch per `git add` dem Index hinzufügen. Wenn Sie also
alle Dateien abarbeiten, müssen Sie schließlich nur noch einen
Commit-Aufruf ausführen, um die Konfliktlösung zu besiegeln.

Welches Tool Git auf der Datei startet, regelt die Option
`merge.tool`. Die folgenden Kommandos sind bereits
vorkonfiguriert, d.h. Git weiß bereits, in welcher Reihenfolge das
Programm die Argumente erwartet und welche Zusatzoptionen angegeben
werden müssen:

-------------------
araxis bc3 codecompare deltawalker diffmerge diffuse
ecmerge emerge gvimdiff gvimdiff2 gvimdiff3 kdiff3
meld opendiff p4merge tkdiff tortoisemerge
vimdiff vimdiff2 vimdiff3 xxdiff
-------------------

Um Ihr eigenes Merge-Tool zu verwenden, müssen Sie
`merge.tool` auf einen geeigneten Namen setzen, zum Beispiel
`mymerge`, und anschließend zumindest die Option
`mergetool.mymerge.cmd` angeben. Den darin gespeicherten
Ausdruck wertet die Shell aus, und die Variablen
`BASE`, `LOCAL`, `REMOTE` sowie `MERGED`,
die die Datei mit den Konflikt-Markern enthält, sind auf die
entsprechend erzeugten temporären Dateien gesetzt. Sie können die
Eigenschaften Ihres Merge-Kommandos weiter konfigurieren, siehe
dafür die Man-Page `git-config(1)` im Abschnitt der
`mergetool`-Konfiguration.

[TIP]
================
Wenn Sie sich zeitweise (nicht dauerhaft) für ein
anderes Merge-Programm entscheiden, geben Sie dieses über die
Option `-t <tool>` an. Um also Meld auszuprobieren,
geben Sie während eines Merge-Konflikts einfach `git
mergetool -t meld` ein -- dafür muss Meld natürlich installiert
sein.
================



[[sec.rerere]]
=== rerere: Reuse Recorded Resolution

Git besitzt ein relativ unbekanntes (und schlecht dokumentiertes),
aber sehr hilfreiches Feature: Rerere, kurz für 'Reuse Recorded
  Resolution' (``gespeicherte Konfliktlösung
wiederverwenden__). Sie müssen die Option
`rerere.enabled` auf `true` setzen, damit das Kommando
automatisch aufgerufen wird (beachten Sie das `d` am Ende von
`enabled`).

Die Idee hinter Rerere ist simpel, aber effektiv: Sobald ein
Merge-Konflikt auftritt, nimmt Rerere automatisch ein _Preimage_
auf, ein Abbild der Konfliktdatei inklusive Markern. Im Falle des
obigen Beispiels sähe das so aus:

[subs="quotes"]
--------
$ *git merge B*
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
*Recorded preimage for \_output.c_*
Automatic merge failed; fix conflicts and then commit the result.
--------

Wird der Konflikt wie oben gelöst und die Lösung eingecheckt,
speichert Rerere die Konfliktlösung ab:

[subs="quotes"]
--------
$ *vim output.c*
$ *git add output.c*
$ *git commit*
*Recorded resolution for \_output.c_.*
[master 681acc2] Merge branch \_B_
--------

Bisher hat Rerere noch nicht wirklich geholfen. Jetzt aber können wir
den Merge-Commit komplett löschen (und sind wieder in der
Ausgangssituation vor dem Merge). Dann führen wir den Merge noch
einmal aus:

[subs="quotes"]
--------
$ *git reset --hard HEAD^*
HEAD is now at f894659 wrap output at 72 chars
$ *git merge B*
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
*Resolved \_output.c_ using previous resolution.*
Automatic merge failed; fix conflicts and then commit the result.
--------

Rerere bemerkt, dass der Konflikt bekannt ist und dass bereits eine
Lösung gefunden wurde.{fn44}
Also berechnet Rerere einen 3-Wege-Merge zwischen dem gespeicherten
Preimage, der gespeicherten Lösung und der im Working Tree
vorliegenden Version der Datei. So kann Rerere nicht nur dieselben
Konflikte lösen, sondern auch _ähnliche_ (wenn zwischenzeitlich
weitere Zeilen außerhalb des Konfliktbereichs geändert wurden).

Das Ergebnis wird _nicht_ direkt dem Index hinzugefügt. Die
Lösung wird lediglich in die Datei übernommen. Sie können dann per
`git diff` nachschauen, ob die Lösung sinnvoll aussieht,
eventuell Tests laufen lassen etc. Wenn alles gut aussieht, übernehmen
Sie wie üblich die automatische Lösung per `git add`.

[[sec.rerere-explained]]
==== Warum Rerere sinnvoll ist

Man könnte einwenden: Wer geht denn freiwillig das Risiko ein, einen
bereits (möglicherweise aufwendig) gelösten Merge-Konflikt zu löschen,
um ihn irgendwann wiederholen zu wollen?

Das Vorgehen ist allerdings wünschenswert: Zunächst ist es
_nicht_ sinnvoll, einfach periodisch und aus Gewohnheit die
Mainline -- also den Hauptentwicklungsstrang, z.B.{empty}{nbsp}`master`
-- in den Topic-Branch zu mergen (wir werden noch darauf
zurückkommen). Wenn Sie aber einen langlebigen Topic-Branch haben und
diesen gelegentlich darauf testen wollen, ob er sich mit der Mainline
verträgt, dann wollen Sie nicht jedes Mal die Konflikte von Hand
auflösen -- einmal gelöste Konflikte wird Rerere dann automatisch
auflösen. Sie können so sukzessive Ihr Feature weiterentwickeln,
wohlwissend, dass es mit der Mainline in Konflikt steht.  Zum
Zeitpunkt der Integration des Features sind die Konflikte aber alle
automatisch lösbar (weil Sie gelegentlich Konfliktlösungen mit Rerere
abgespeichert haben).

Außerdem wird Rerere auch automatisch in Konfliktfällen aufgerufen,
die in einem Rebase-Prozess (siehe <<sec.rebase>>) entstehen.
Auch hier gilt wieder: Einmal gelöste Konflikte können automatisch
wieder gelöst werden. Wenn Sie einen Branch einmal testweise per Merge
in die Mainline integriert und einen Konflikt gelöst haben, wird diese
Lösung automatisch angewendet, wenn Sie diesen Branch per Rebase auf
die Mainline neu aufbauen.

[[sec.rerere-usage]]
==== Rerere benutzen

Damit die Rerere-Funktionalität verwendet wird, müssen Sie, wie schon
erwähnt, die Option `rerere.enabled` auf `true` setzen.
Rerere wird dann automatisch aufgerufen, wenn ein Merge-Konflikt
auftritt (um das Preimage aufzunehmen, möglicherweise auch um den
Konflikt zu lösen) und wenn eine Konfliktlösung eingecheckt wird (um
die Lösung abzuspeichern).

Rerere legt Informationen wie Preimage und Lösung in
`.git/rr-cache/` ab, eindeutig identifiziert durch eine
SHA-1-Summe. Das Subkommando `git rerere` müssen Sie fast nie
aufrufen, da es von `merge` und `commit` schon erledigt
wird. Sie können analog zu `git gc` auch `git rerere gc`
verwenden, um sehr alte Lösungen zu löschen.

Was passiert, wenn eine falsche Konfliktlösung eingecheckt wurde?
Dann sollten Sie die Konfliktlösung löschen, andernfalls wird Rerere
die Lösung, wenn Sie den konfliktbehafteten Merge wiederholen, erneut
anwenden. Dafür gibt es das Kommando `git rerere forget
  <datei>` -- direkt nachdem Rerere eine falsche Lösung eingespielt
hat, können Sie auf diese Weise die falsche Lösung löschen und den
Ursprungszustand der Datei wiederherstellen (d.h.  mit
Konflikt-Markern). Wollen Sie nur Letzteres bewirken, hilft auch ein
`git checkout -m <datei>`.



[[sec.avoid-conflicts]]
=== Konflikte vermeiden

Dezentrale Versionskontrollsysteme verwalten Merges generell
wesentlich besser als zentrale. Das liegt vor allem daran,
dass es bei dezentralen Systemen Usus ist, viele kleine Änderungen
zunächst _lokal_ einzuchecken. Dadurch entstehen keine
"`Monster-Commits`", die wesentlich mehr
Konfliktpotential bieten. Diese feiner granulierte
Entwicklungsgeschichte und der Umstand, dass Merges in der Regel
wiederum Daten in der Versionsgeschichte sind (im Gegensatz zu einem
simplen Kopieren der Codezeilen), führen dazu, dass dezentrale Systeme
bei einem Merge nicht nur auf den bloßen Inhalt von Dateien schauen
müssen.


Um Merge-Konflikte zu minimieren, ist Vorbeugung das beste Mittel.
Machen Sie kleine Commits! Fassen Sie Ihre Änderungen so zusammen,
dass der resultierende Commit als Einheit Sinn ergibt. Bauen Sie
Topic-Branches immer auf dem neuesten Release auf. Mergen Sie von
Topic-Branches in "`Sammel-Branches`" oder direkt in den
`master`, nicht anders
herum.{fn45}
Der
Einsatz von Rerere erlaubt es, dass bereits gelöste Konflikte nicht
ständig erneut auftreten.

Offensichtlich zählt zur Vorbeugung auch gute Kommunikation unter den
Entwicklern: Wenn mehrere Entwickler an der gleichen Funktion
unterschiedliche und sich gegenseitig beeinflussende Änderungen
implementieren, wird das früher oder später sicher zu Konflikten
führen.

Ein weiterer Faktor, der leider häufig zu unnötigen(!) Konflikten
führt, sind autogenerierte Inhalte. Angenommen, Sie schreiben die
Dokumentation einer Software in
_AsciiDoc_{empty}{fn46}
oder arbeiten an einem
LaTeX-Projekt mit mehreren Mitstreitern: Fügen Sie keinesfalls die
kompilierten Man-Pages oder das kompilierte DVI/PS/PDF im Repository
ein! In den autogenerierten Formaten können kleine Änderungen am
Plaintext (d.h. in der Ascii- bzw. LaTeX-Version) große (und
unvorhersehbare) Änderungen an den kompilierten Formaten hervorrufen,
die Git nicht adäquat auflösen wird. Sinnvoll ist es stattdessen,
entsprechende Makefile-Targets oder Scripte bereitzustellen, um die
Dateien zu generieren, und möglicherweise die kompilierte
Version auf einem separaten Branch vorzuhalten.{fn47}


[[sec.cherry-pick]]
== Einzelne Commits übernehmen: Cherry-Pick

Es wird vorkommen, dass Sie nicht direkt einen ganzen Branch
integrieren wollen, sondern zunächst Teile, also einzelne Commits.
Dafür ist das Git-Kommando `cherry-pick` (``die guten
Kirschen herauspicken__) zuständig.

Das Kommando erwartet einen oder mehrere Commits, die auf den aktuellen
Branch kopiert werden sollen. Zum Beispiel:

[subs="quotes"]
--------
$ *git cherry-pick d0c915d*
$ *git cherry-pick topic\~5 topic\~1*
$ *git cherry-pick topic\~5..topic~1*
--------

Das mittlere Kommando kopiert zwei explizit angegebene Commits; das
letzte Kommando hingegen kopiert alle zu der angegebenen Commit-Range
gehörigen Commits.

Im Gegensatz zu einem Merge werden aber nur die Änderungen integriert,
nicht der Commit selbst. Dafür müsste er nämlich seinen Vorgänger
referenzieren, so dass dieser auch integriert werden müsste usw. --
was einem Merge gleichkommt. Wenn Sie Commits mit `cherry-pick`
übernehmen, entstehen dabei also _neue_ Commits mit neuer
Commit-ID. Git kann danach _nicht_ ohne weiteres wissen, dass
diese Commits eigentlich die gleichen sind.

Daher kann es, wenn Sie zwei Branches mergen, zwischen denen Sie
Änderungen per Cherry-Pick ausgetauscht haben, zu Konflikten kommen.{fn48}
Diese
sind meist trivial zu lösen, möglicherweise sind auch die
Strategie-Optionen `ours` bzw. `theirs` hilfreich
(siehe <<sec.recursive-options>>).
Das Rebase-Kommando hingegen erkennt solche Commit-Doppelungen,{fn49}
und lässt die gedoppelten Commits aus. So können Sie einige Commits
"`aus der Mitte`" übernehmen und dann den Branch, aus dem die
Commits stammten, neu aufbauen.

Das `cherry-pick`-Kommando versteht außerdem selbst diese
Merge-Strategie-Optionen: Wenn Sie einen Commit in den aktuellen Branch
kopieren wollen, und im Konfliktfall dem neuen Commit recht geben
wollen, verwenden Sie:

------
git cherry-pick -Xtheirs <commit>
------


[TIP]
========
Über die Option `-n` bzw. `--no-commit` veranlassen
Sie Git, die Änderungen eines Commits zwar in den Index zu
übernehmen, aber noch keinen Commit daraus zu machen. So können Sie
mehrere kleine Commits erst im Index "`aggregieren`" und
dann als _einen_ Commit verpacken:

[subs="quotes"]
--------
$ *git cherry-pick -n 785aa39 512f3e9 4e4a063*
Finished one cherry-pick.
Finished one cherry-pick.
Finished one cherry-pick.
$ *git commit -m "Diverse kleine Änderungen"*
--------
========



[[sec.visualization]]
== Visualisierung von Repositories

Wenn Sie einige Branches erstellt und wieder zusammengeführt haben,
werden Sie gemerkt haben: Man verliert leicht den Überblick.

Die Anordnung der Commits und ihre Beziehungen untereinander
bezeichnet man als _Topologie_ eines Repositorys. Im Folgenden
werden wir unter anderem das grafische Programm `gitk`
vorstellen, um diese Topologien zu untersuchen.

Rufen Sie bei kleinen Repositories zunächst ganz einfach `gitk
  --all` auf, das das komplette Repository als Graphen darstellt. Ein
Klick auf die einzelnen Commits zeigt die Metainformationen sowie den
erzeugten Patch an.

[[rev-list]]
=== Revision Parameters

Da die Auflistung mehrerer Commits kaum zu überblicken ist,
untersuchen wir ein kleines Beispiel-Repository mit mehreren Branches,
die untereinander gemergt wurden:

.Der Graph der Commits, wie er in `gitk` dargestellt wird
image::revision-list-commit-graph-gitk.png[id="fig.rev-list-graph",scaledwidth="90%",width="90%"]

Wir erkennen vier Branches (A-D) sowie einen Tag `release`.
Diesen Baum können wir mit geeigneten Kommandozeilenoptionen auch per
`log`-Kommando auf der Konsole anzeigen lassen (Branch- und
Tag-Namen sind zur besseren Unterscheidung halbfett gedruckt):

[subs="quotes"]
--------
$ *git log --decorate --pretty=oneline --abbrev-commit --graph --all*
* c937566 (*HEAD*, *D*) commit on branch D
| *   b0b30ef (*release*, *A*) Merge branch \_C_ into A
| |\
| | * 807db47 (*C*) commit on branch C
| | * 996a53b commit on branch C
| |/
|/|
| * 83f6bf3 commit on branch A
| *   5b2c291 Merge branch \_B_ into A
| |\
| | * 2417cf7 (*B*) commit on branch B
| |/
|/|
| * 0bf1433 commit on branch A
|/
* 4783886 initial commit
--------


[TIP]
========
Die Ausgabe des `log`-Kommandos ist äquivalent zu der Ansicht
in Gitk. Allerdings ist `git log` sehr viel schneller als
Gitk und kommt ohne ein weiteres Programmfenster aus.

Für eine schnelle Übersicht ist es also viel praktischer, ein
Alias einzurichten, das die vielen langen Optionen automatisch
hinzufügt. Die Autoren verwenden dafür das Alias `tree`, das
Sie wie folgt definieren können:

[subs="quotes"]
--------
$ *git config --global alias.tree \'log --decorate \*
   *--pretty=oneline --abbrev-commit --graph'*
--------

Per `git tree --all` erhalten Sie eine ASCII-Version des
Graphen des Git-Repositorys. Im Folgenden nutzen wir dieses Alias, um
die Topologie darzustellen.
========

Nun verändern wir obiges Kommando: Statt der Option `--all`,
die alle Commits im Baum unterbringt, geben wir nun `B` an (den
Namen des Branch):

[subs="quotes"]
--------
$ *git tree B*
* 2417cf7 (*B*) commit on branch B
* 4783886 initial commit
--------

Wir erhalten alle Commits, die von B aus erreichbar sind. Ein
Commit kennt jeweils nur seinen bzw. seine Vorgänger (mehrere dann,
wenn Branches zusammengeführt werden).  ``Alle von B erreichbaren
Commits__ bezeichnet also die Liste der Commits von B an weiter
bis zu einem Commit, der keinen Vorgänger hat (genannt
_Root-Commit_).

Statt einer kann das Kommando auch mehrere Referenzen entgegennehmen.
Um also die gleiche Ausgabe wie mit der Option `--all` zu
erhalten, müssen Sie die Referenzen A, B und D angeben. C kann
ausgelassen werden, weil der Commit auf dem Weg von A zum Root-Commit
bereits "`eingesammelt`" wird.

Natürlich können Sie statt symbolischer Referenzen auch direkt eine
SHA-1-Summe angeben:

[subs="quotes"]
--------
$ *git tree 5b2c291*
*   5b2c291 Merge branch \_B_ into A
|\
| * 2417cf7 (*B*) commit on branch B
* | 0bf1433 commit on branch A
|/
* 4783886 initial commit
--------

Wird einer Referenz ein Caret (`^`) vorangestellt, so negiert das
die Bedeutung.{fn50}
Die Notation `^A` bedeutet also: _nicht_ die Commits,
die von A aus erreichbar sind. Allerdings schließt dieser Schalter
lediglich diese Commits aus, nicht jedoch die anderen ein.  Obiges
`log`-Kommando mit dem Argument `^A` wird also nichts ausgeben, da Git
nur weiß, welche Commits _nicht_ angezeigt werden sollen. Wir fügen
also wieder `--all` hinzu, um alle Commits aufzulisten, abzüglich
derer, die von A erreichbar sind:

[subs="quotes"]
--------
$ *git tree --all ^A*
* c937566 (*HEAD*, *D*) commit on branch D
--------

Eine alternative Notation ist mit `--not` verfügbar: Statt
`^A` kann man auch `--not A` schreiben.

Besonders hilfreich sind solche Kommandos, um den _Unterschied_
zwischen zwei Branches zu untersuchen: Welche Commits sind in Branch
D, die nicht in A sind?  Die Antwort liefert das Kommando:

[subs="quotes"]
--------
$ *git tree D ^A*
* c937566 (*HEAD*, *D*) commit on branch D
--------

Weil sich diese Frage häufig stellt, gibt es dafür eine andere,
intuitivere Notation: `A..D` ist gleichbedeutend mit `D ^A`:

[subs="quotes"]
--------
$ *git tree A..D*
* c937566 (*HEAD*, *D*) commit on branch D
--------

Natürlich ist hier die Reihenfolge wichtig: "`D ohne A`" ist
eine andere Menge von Commits als "`A ohne D`"! (Vergleiche
auch den vollständigen Graphen.)

Im unserem Beispiel gibt es einen Tag `release`. Um zu
überprüfen, welche Commits aus dem Branch D (der für
"`Development`" stehen könnte) noch nicht im aktuellen Release
enthalten sind, genügt die Angabe `release..D`.



//\label{sec:rev-symmetric}


[TIP]
========
Die Syntax `A..B` kann man sich als Idiom ``von
A bis B__ merken. Diese "`Differenz`"
ist aber nicht symmetrisch, d.h.{empty}{nbsp}`A..B` sind in der Regel
nicht die gleichen Commits wie `B..A`.

Alternativ stellt Git die _symmetrische Differenz_{empty}{nbsp}`A...B` bereit. Sie entspricht dem Argument `A B
    --not $(git merge-base A B)`, bezieht also alle Commits ein,
  die von A _oder_ von B erreichbar sind -- aber nicht von beiden.
========

[[rev-list-explained]]
==== Referenz vs. Liste von Referenzen

Im Beispiel werden mit A immer alle Commits bezeichnet, die von A
erreichbar sind. Aber eigentlich ist ein Branch ja nur eine Referenz
auf _einen_ Commit. Warum listet also `log` immer alle von
A erreichbaren Commits auf, während das Git-Kommando
`show` mit dem Argument `A` nur diesen einen Commit
anzeigt?

Der Unterschied liegt darin, was die Kommandos als Argument erwarten:
`show` erwartet ein _Objekt_, also eine Referenz auf
_ein_ Objekt, das dann angezeigt wird.{fn51}
Viele andere Kommandos erwarten stattdessen einen (oder auch mehrere)
_Commits_, und diese Kommandos wandeln die Argumente in eine
Liste von Commits um (traversieren die Liste bis zum Root-Commit).

[[sec.gitk]]
=== Gitk

Gitk ist ein in Tcl implementiertes grafisches Programm, das in der
Regel von Distributoren zusammen mit den eigentlichen Git-Kommandos
paketiert wird -- Sie können sich also darauf verlassen, es auf fast
jedem System vorzufinden.

Es repräsentiert einzelne Commits oder das ganze Repository in einer
dreiteiligen Ansicht: Oben die Baumstruktur mit zwei weiteren Spalten
für Autor und Datum, unten eine Auflistung der Änderungen im
Unified-Diff-Format sowie eine Liste von Dateien, um die angezeigten
Änderungen einzuschränken.

Die Graph-Ansicht ist intuitiv: Verschiedene Farben helfen, die
verschiedenen Versionsstränge zu unterscheiden. Commits sind jeweils
blaue Punkte, mit zwei Ausnahmen: Der `HEAD` ist gelb markiert,
und ein Commit, der nicht Root-Commit ist, dessen Vorgänger aber nicht
angezeigt ist, wird weiß dargestellt.

Branches mit einer Pfeilspitze deuten an, dass auf dem
Branch weitere Commits getätigt wurden. Aufgrund der zeitlichen
Distanz der Commits blendet Gitk aber den Branch aus. Ein Klick auf
die Pfeilspitze bringt Sie zu der Weiterführung des Branches.

Branches erscheinen als grüne Labels, der aktuell ausgecheckte Branch
zusätzlich fett. Tags sind als gelbe Pfeile dargestellt.

Mit einem Rechtsklick auf einen Branch können Sie diesen löschen oder
auschecken. Auf Commits öffnet ein Rechtsklick ein Menü, in dem Sie
Aktionen mit dem markierten Commit ausführen können. Die einzige, die
mit Gitk möglicherweise leichter zu bewerkstelligen ist als über die
Kommandozeile, ist _Cherry-Picking_, also das Übernehmen
einzelner Commits in einen anderen Branch (siehe auch
<<sec.cherry-pick>>).

.Komplizierte Topologie in Gitk
image::gitk.png[id="fig.gitk",scaledwidth="90%",width="90%"]

Gitk akzeptiert im wesentlichen die gleichen Optionen wie `git
  log`. Einige Beispiele:

[subs="quotes"]
--------
$ *gitk --since=yesterday -- doc/*
$ *gitk e13404a..48effd3*
$ *gitk --all -n 100*
--------

Das erste Kommando zeigt alle Commits seit gestern an, die Änderungen
an einer Datei unterhalb des Verzeichnisses `doc/` vorgenommen
haben. Das zweite Kommando limitiert die Commits auf eine spezielle
Range, während das dritte Kommando die 100 neuesten Commits aller
Branches anzeigt.




[TIP]
========
Erfahrungsgemäß sind Anfänger oft verwirrt, weil `gitk`
standardmäßig nur den aktuellen Branch anzeigt. Das liegt vermutlich
daran, dass `gitk` oft aufgerufen wird, um sich einen
Überblick aller Branches zu verschaffen.  Daher bietet sich
folgendes Shell-Alias an: `alias gik=_gitk --all_`
========

Viele Nutzer lassen `gitk` während der Arbeit offen. Dann ist
es wichtig, von Zeit zu Zeit die Anzeige zu aktualisieren, damit auch
aktuellere Commits erscheinen. Mit _F5_ (_Update_) laden
Sie alle neuen Commits und erneuern die Darstellung der Referenzen.
Manchmal, wenn Sie z.B. einen Branch löschen, reicht dies jedoch
nicht aus. Zwar wird der Branch nicht mehr angezeigt, aber evtl. sind
unerreichbare Commits weiterhin quasi als Artefakte in der GUI
vorhanden. Mit der Tastenkombination _Strg+F5_
(_Reload_) wird das Repository vollständig neu eingelesen, was
das Problem beseitigt.

Alternativ zu `gitk` können Sie auf UNIX-Systemen das GTK-basierte
`gitg` oder Qt-basierte `qgit` verwenden; auf einem OS-X-System können
Sie beispielsweise _GitX_ verwenden; für Windows bieten sich die
_GitExtensions_ an. Einige IDEs verfügen mittlerweile auch über
entsprechende Visualisierungen (z.B. das _Eclipse_-Plugin _EGit_).
Weiterhin können Sie vollwertige Git-Clients wie _Atlassian SourceTree_
(OS X, Windows; kostenlos), _Tower_ (OS X; kommerziell) sowie _SmartGit_
(Linux, OS X und Windows; kostenlos für nichtkommerzielle Nutzung)
verwenden.


[[sec.reflog]]
== Reflog

Das _Reference Log_ (_Reflog_) sind Log-Dateien, die Git für
jeden Branch sowie `HEAD` anlegt. Darin wird gespeichert, wann
eine Referenz von wo nach wo verschoben wurde. Das passiert vor allem
bei den Kommandos `checkout`, `reset`, `merge`
und `rebase`.

Diese Log-Dateien liegen unter `.git/logs/` und tragen den
Namen der jeweiligen Referenz. Das Reflog für den
`master`-Branch finden Sie also unter
`.git/logs/refs/heads/master`. Außerdem gibt es das Kommando
`git reflog show <referenz>`, um das Reflog aufzulisten:

[subs="quotes"]
--------
$ *git reflog show master*
48effd3 master@{0}: HEAD^: updating HEAD
ef51665 master@{1}: rebase -i (finish): refs/heads/master onto 69b9e27
231d0a3 master@{2}: merge @{u}: Fast-forward
...
--------

Das Reflog-Kommando wird selten direkt benutzt und ist nur ein Alias
für `git log -g --oneline`. Die Option `-g` bewirkt
nämlich, dass das Kommando nicht die Vorgänger im Commit-Graphen
anzeigt, sondern die Commits in der Reihenfolge des Reflogs
abarbeitet.

Das können Sie ganz leicht ausprobieren: Erstellen Sie einen
Test-Commit und löschen Sie ihn danach wieder mit `git reset
  --hard HEAD^`. Das Kommando `git log -g` wird nun zuerst
den `HEAD` anzeigen, dann den gelöschten Commit und dann wieder
den `HEAD`.

Das Reflog referenziert also auch Commits, die sonst nicht mehr
referenziert sind, also "`verloren`" sind (siehe
<<sec.branch-management>>). So hilft das Reflog Ihnen
möglicherweise, wenn Sie einen Branch gelöscht haben, von dem sich im
Nachhinein herausstellt, dass Sie ihn doch gebraucht hätten. Zwar
löscht ein `git branch -D` auch das Reflog des Branches.
Allerdings haben Sie den Branch ja auschecken müssen, um Commits
darauf zu machen: Suchen Sie also mit `git log -g HEAD` nach
dem letzten Zeitpunkt, zu dem Sie den gesuchten Branch ausgecheckt
haben. Dann erstellen Sie einen Branch, der auf diese (scheinbar
verlorene) Commit-ID zeigt, und Ihre verlorenen Commits sollten wieder
da sein.{fn52}


Kommandos, die eine oder mehrere Referenzen erwarten, können
allerdings auch implizit das Reflog verwenden. Neben der Syntax, die
sich schon bei der Ausgabe von `git log -g` findet (z.B.{empty}{nbsp}`HEAD@{1}` für die vorherige Position des `HEAD`),
versteht Git auch `<ref>@{<wann>}`.  Git interpretiert den
Zeitpunkt `<wann>` als absolutes oder relatives Datum und
konsultiert dann das Reflog der entsprechenden Referenz, um
herauszufinden, was der zeitlich nächste Log-Eintrag ist. Dieser wird
dann referenziert.

Zwei Beispiele:

[subs="quotes"]
--------
$ *git log \_master@{two weeks ago}..\_*
$ *git show \_@{1st of April, 2011}_*
--------

Das erste Kommando listet alle Commits zwischen `HEAD` und dem
Commit auf, auf den der `master`-Branch vor zwei Wochen gezeigt
hat (beachten Sie das Suffix `..`, was eine Commit-Range bis
`HEAD` bedeutet). Das muss nicht nötigerweise auch ein Commit
sein, der zwei Wochen alt ist: Wenn Sie vor zwei Wochen testweise per
`git reset --hard <initial-commit>` den Branch auf den
allerersten Commit des Repositorys verschoben haben, dann wird genau
dieser Commit referenziert.{fn53}

Die zweite Zeile zeigt den Commit an, auf den der (wegen fehlender
expliziter Referenz vor dem `@`) aktuell ausgecheckte Branch am
1. April 2011 gezeigt hat. In beiden Kommandos muss das Argument mit
Reflog-Anhang sinnvoll in Anführungszeichen eingefasst werden, damit
Git das Argument komplett erhält.

Beachten Sie, dass das Reflog _nur_ lokal vorliegt und somit
nicht zum Repository gehört. Wenn Sie einem anderen Entwickler eine
Commit-ID oder einen Tag-Namen schicken, dann referenziert dies den
gleichen Commit -- ein `master@{yesterday}` kann aber je nach
Entwickler _verschiedene_ Commits referenzieren.

[TIP]
==================
Wenn Sie keinen Branch und keinen Zeitpunkt angeben, nimmt Git `HEAD` an.
Somit können Sie in Kommandos `@` als Kurzform für `HEAD` verwenden.
Weiterhin verstehen viele Kommandos das Argument `-` als `@{-1}`, also
"`letzte Position des `HEAD``":

[subs="quotes"]
------
$ *git checkout feature*   # vorher auf "master"
$ *git commit ...*         # Änderungen, Commits machen
$ *git checkout -*         # zurück auf "master"
$ *git merge -*            # Merge von "feature"
------
==================

