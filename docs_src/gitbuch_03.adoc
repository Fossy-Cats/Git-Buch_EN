// adapted from: "praxis.txt"

[[ch.praxis]]
= Practical Version Control
// Praktische Versionsverwaltung

// @NOTE: Chapter title could be translated better!

include::gitbuch_footnotes.adoc[tag=Chapter_3]


////
Das folgende Kapitel stellt alle wesentlichen Techniken vor, die Sie im täglichen Umgang mit Git einsetzen werden.
Neben einer genaueren Beschreibung des Index und wie man alte Versionen wiederherstellt, liegt der Fokus auf der effektiven Arbeit mit Branches.
////

The following chapter introduces all the essential techniques you'll use in your daily work with Git.
In addition to a more detailed description of the index and how to restore old versions, the focus is on working effectively with branches.



[[sec.branches]]
== References: Branches and Tags
// Referenzen: Branches und Tags

////
"`Branch`" und "`Merge`" sind im CVS-/SVN-Umfeld für Neulinge oft ein Buch mit sieben Siegeln, für Könner regelmäßig Grund zum Haare raufen.
In Git sind das Abzweigen im Entwicklungszyklus (_Branching_) und das anschließende Wiederzusammenführen (_Merging_) alltäglich, einfach, transparent und schnell.
Es kommt häufig vor, dass ein Entwickler an einem Tag mehrere Branches erstellt und mehrere Merges durchführt.
////

// @TODO: Check translation of 2nd sentence! (something seems lost)

In the CVS/SVN environment, "`Branch`" and "`Merge`" are often a book with seven seals for newcomers, but for experts they are a regular cause for hair-raising.
In Git, _branching_ and _merging_ are commonplace, simple, transparent, and fast.
It's common for a developer to create multiple branches and perform multiple merges in one day.


////
Das Tool Gitk ist hilfreich, um bei mehreren Branches nicht den Überblick zu verlieren.
Mit `gitk --all` zeigen Sie alle Branches an.
Das Tool visualisiert den im vorigen Abschnitt erläuterten Commit-Graphen.
Jeder Commit stellt eine Zeile dar.
Branches werden als grüne Labels, Tags als gelbe Zeiger dargestellt.
Für weitere Informationen siehe Abschnitt 3.6.2, "Gitk".
////

The tool Gitk is helpful in order not to lose the overview of several branches.
With `gitk --all` you show all branches.
The tool visualizes the commit graph explained in the previous section.
Each commit represents one line.
Branches are displayed as green labels, tags as yellow pointers.
For more information, see <<sec.gitk>>.


// .Das Beispiel-Repository aus Kapitel 2, Grundlagen in Gitk. Zur Illustration wurde der zweite Commit mit  dem Tag `v0.1` versehen.
.The sample repository from <<ch.basics>>. For illustration purposes, the second commit has been tagged `v0.1`.
image::gitk-basic.png[id="fig.gitk-basic",scaledwidth="90%",width="90%",align="center"]


////
Da Branches in Git "`billig`" und Merges einfach sind, können Sie es sich leisten, Branches exzessiv zu verwenden.
Sie wollen etwas probieren, einen kleinen Bugfix vorbereiten oder mit einem experimentellen Feature beginnen?
Für all das erstellen Sie jeweils einen neuen Branch.
Sie wollen testen, ob sich ein Branch mit dem anderen verträgt?
Führen Sie die beiden zusammen, testen Sie alles, und löschen Sie danach den Merge wieder und entwickeln weiter.
Das ist gängige Praxis unter Entwicklern, die Git einsetzen.
////

Because branches in Git are "`cheap`" and merges are easy, you can afford to use branches excessively.
Want to try something, prepare a small bug fix, or start with an experimental feature?
You can create a new branch for each of these.
You want to test if one branch is compatible with the other?
Merge them together, test everything, then delete the merge again and continue developing.
This is common practice among developers using Git.


////
Zunächst wollen wir uns mit Referenzen generell auseinandersetzen.
Referenzen sind nichts weiter als symbolische Namen für die schwierig zu merkenden SHA-1-Summen von Commits.
////

First, let's look at references in general.
References are nothing more than symbolic names for the hard to remember SHA-1 sums of commits.


////
Diese Referenzen liegen in `.git/refs/`.
Der Name einer Referenz wird anhand des Dateinamens, das Ziel anhand des Inhalts der Datei bestimmt.
Der Master-Branch, auf dem Sie schon die ganze Zeit arbeiten, sieht darin zum Beispiel so aus:
////

These references are stored in `.git/refs/`.
The name of a reference is determined by the file name, and the target is determined by the contents of the file.
For example, the master branch you have been working on all along looks like this:


[subs="quotes"]
--------
$ *cat .git/refs/heads/master*
89062b72afccda5b9e8ed77bf82c38577e603251
--------


[TIP]
===================
////
Wenn Git sehr viele Referenzen verwalten muss, liegen diese nicht zwingend als Dateien unterhalb von `.git/refs/`.
Git erstellt dann stattdessen einen Container, der _gepackte Referenzen_ (_Packed Refs_) enthält: Eine Zeile pro Referenz mit Name und SHA-1-Summe.
Das sequentielle Auflösen vieler Referenzen geht dann schneller.
Git-Kommandos suchen Branches und Tags in der Datei `.git/packed-refs`, wenn die entsprechende Datei `.git/refs/<name>` nicht existiert.
////

If Git needs to manage a lot of references, they may not be stored as files under `.git/refs/`.
Instead, Git creates a container that contains packed references (_Packed Refs_): One line per reference with name and SHA-1 sum.
This makes sequential resolution of many references faster.
Git commands search for branches and tags in the `.git/packed-refs` file if the corresponding `.git/refs/<name>` file does not exist.
===================


////
Unterhalb von `.git/refs/` gibt es verschiedene Verzeichnisse, die für die "`Art`" von Referenz stehen.
Fundamental unterscheiden sich diese Referenzen aber nicht, lediglich darin, wann und wie sie angewendet werden.
Die Referenzen, die Sie am häufigsten verwenden werden, sind Branches.
Sie sind unter `.git/refs/heads/` gespeichert.
_Heads_ bezeichnet das, was in anderen Systemen zuweilen auch "`Tip`" genannt wird: Den neuesten Commit auf einem Entwicklungsstrang.[29]
Branches rücken weiter, wenn Sie Commits auf einem Branch erstellen -- sie bleiben also an der Spitze der Versionsgeschichte.
////

Under `.git/refs/` there are several directories that represent the "`type`" of reference.
There is no fundamental difference between these references, only when and how they are used.
The references you will use most often are branches.
They are stored under `.git/refs/heads/`.
_Heads_ refers to what is sometimes called a "`tip`" in other systems: The latest commit on a development branch.{fn29}
Branches move up when you make commits on a branch, so they remain at the top of the version history.


// .Der Branch referenziert immer den aktuellsten Commit
.A branch always references the most recent commit
image::commit.svg[id="fig.commit",scaledwidth="60%",width="60%",align="center"]


////
Branches in Repositories anderer Entwickler (z.B. der Master-Branch des offiziellen Repositorys), sog. Remote-Tracking-Branches, werden unter `.git/refs/remotes/` abgelegt (siehe Abschnitt 5.2.2, "Remote-Tracking-Branches").
Tags, statische Referenzen, die meist der Versionierung dienen, liegen unter `.git/refs/tags/` (siehe Abschnitt 3.1.3, "Tags -- Wichtige Versionen markieren").
////

Branches in other developers' repositories (e.g. the master branch of the official repository), so-called remote tracking branches, are stored under `.git/refs/remotes/` (see <<sec.remote-tracking-branches>>).
Tags, static references, which are mostly used for versioning, are stored under `.git/refs/tags/` (see <<sec.tags>>).



[[sec.branch-refs]]
=== HEAD and Other Symbolic References
//  HEAD und andere symbolische Referenzen

Eine Referenz, die Sie selten explizit, aber ständig implizit benutzen, ist `HEAD`.
Sie referenziert meist den gerade ausgecheckten Branch, hier `master`:

One reference that you rarely use explicitly, but always implicitly, is `HEAD`.
It usually refers to the branch you just checked out, in this case `master`:


[subs="quotes"]
--------
$ *cat .git/HEAD*
ref: refs/heads/master
--------



////
`HEAD` kann auch direkt auf einen Commit zeigen, wenn Sie `git checkout <commit-id>` eingeben.
Sie sind dann allerdings im sogenannten _Detached-Head_-Modus, in dem Commits möglicherweise verlorengehen, siehe auch Abschnitt 3.2.1, "Detached HEAD".
////

`HEAD` can also point directly to a commit if you type `git checkout <commit-id>`.
However, you are then in so-called _detached-head_ mode, in which commits may get lost, see also <<sec.detached-head>>.


////
Der `HEAD` bestimmt, welche Dateien im Working Tree zu finden sind, welcher Commit Vorgänger bei der Erstellung eines neuen wird, welcher Commit per `git show` angezeigt wird etc.
Wenn wir hier von "`dem aktuellen Branch`" sprechen, dann ist damit technisch korrekt der `HEAD` gemeint.
////

The `HEAD` determines which files are found in the working tree, which commit becomes the predecessor when a new one is created, which commit is displayed by `git show`, and so on.
When we speak of "`the current branch`", we mean the `HEAD` in a technically correct sense.


////
Die simplen Kommandos `log`, `show` und `diff` nehmen ohne weitere Argumente `HEAD` als erstes Argument an.
Die Ausgabe von `git log` ist gleich der von `git log HEAD` usw. -- dies gilt für die meisten Kommandos, die auf einem Commit operieren, wenn Sie keinen explizit angeben.
`HEAD` ist somit vergleichbar mit der Shell-Variable `PWD`, die angibt "`wo man ist`".
////

The simple commands `log`, `show`, and `diff` take `HEAD` as their first argument, without any further arguments.
The output of `git log` is the same as the output of `git log HEAD`, and so on -- this applies to most commands that operate on a commit if you don't specify one explicitly.
`HEAD` is thus similar to the shell variable `PWD`, which specifies "`where you are`".


////
Wenn wir von einem Commit sprechen, dann ist es einem Kommando in der Regel egal, ob man die Commit-ID komplett oder verkürzt angibt oder den Commit über eine Referenz, wie z.B. ein Tag oder Branch, ansteuert.
Eine solche Referenz muss aber nicht immer eindeutig sein.
Was passiert, wenn es einen Branch `master` gibt und ein Tag gleichen Namens?
Git überprüft, ob die folgenden Referenzen existieren:
////

When we talk about a commit, a command usually doesn't care whether you specify the commit ID in full or in abbreviated form, or whether you access the commit by reference, such as a tag or branch.
However, such a reference may not always be unique.
What happens if there is a branch `master` and a tag with the same name?
Git checks if the following references exist:


////
* `.git/<name>` (meist nur sinnvoll für `HEAD` o.ä.)
////

* `.git/<name>` (mostly only useful for `HEAD` or similar)
* `.git/refs/<name>`
* `.git/refs/tags/<name>`
* `.git/refs/heads/<name>`
* `.git/refs/remotes/<name>`
* `.git/refs/remotes/<name>/HEAD`


////
Die erste gefundene Referenz nimmt Git als Treffer an.
Sie sollten also Tags immer ein eindeutiges Schema geben, um sie nicht mit Branches zu verwechseln.
So können Sie Branches direkt über den Namen statt über `heads/<name>` ansprechen.
////

Git will take the first matching reference it finds.
So you should always give tags a unique scheme so that they don't get confused with branches.
This way you can address branches directly by name instead of `heads/<name>`.


////
Besonders wichtig sind dafür die Suffixe `^` und `~<n>`.
Die Syntax `<ref>^` bezeichnet den direkten Vorfahren von `<ref>`.
Dieser muss aber nicht immer eindeutig sein: Wenn zwei oder mehr Branches zusammengeführt wurden, hat der Merge-Commit mehrere direkte Vorfahren.
`<ref>^` bzw. `<ref>^1` bezeichnen dann den ersten _direkten_ Vorfahren, `<ref>^2` den zweiten usw.[30]
Die Syntax `HEAD^^` bedeutet also "`der zwei Ebenen vorher liegende direkte Vorfahre des aktuellen Commits`".
Achten Sie darauf, dass `^` in Ihrer Shell möglicherweise eine spezielle Bedeutung hat und Sie es durch Anführungszeichen oder mit einem Backslash schützen müssen.
////

Especially important are the suffixes `^` and `~<n>`.
The syntax `<ref>^` indicates the direct ancestor of `<ref>`.
This does not always have to be unique: If two or more branches were merged, the merge commit has several direct ancestors.
`<ref>^` or `<ref>^1` then denotes the first direct ancestor, `<ref>^2` the second, and so on.{fn30}
So the syntax `HEAD^^` means "`the two-level previous direct ancestor of the current commit`".
Note that `^` may have a special meaning in your shell and you may need to protect it with quotes or a backslash.



// .Relative-Referenzen, `^` und `~<n>`
.Relative References, `^` and `~<n>`
image::relative-refs.svg[id="fig.relative-refs",scaledwidth="60%",width="60%",align="center"]


////
Die Syntax `<ref>~<n>` kommt einer _n_-fachen Wiederholung von `^` gleich: `HEAD~10` bezeichnet also den zehnten direkten Vorgänger des aktuellen Commits.
Achtung: Das heißt nicht, dass zwischen `HEAD` und `HEAD~10` nur elf Commits liegen: Da `^` bei einem etwaigen Merge nur dem ersten Strang folgt, liegen zwischen den beiden Referenzen die elf und alle durch einen Merge integrierten weiteren Commits.
Die Syntax ist übrigens in der Man-Page `git-rev-parse(1)` im Abschnitt "`Specifying Revisions`" dokumentiert.
////

// @NOTE: I've actually checked the "Specifying Revisions" section title at the
//        'git-rev-parse(1)' man page, so it's correct!

The syntax `<ref>~<n>` is equivalent to repeating `^` _n_ times: `HEAD~10` thus denotes the tenth direct predecessor of the current commit.
Note: This does not mean that only eleven commits are stored between `HEAD` and `HEAD~10`: Since `^` only follows the first string in any merge, the eleven commits stored between the two references, and all the other commits integrated by a merge, are the same.
The syntax is documented in the `git-rev-parse(1)` man page in the "`Specifying Revisions`" section.



[[sec.branch-management]]
=== Managing Branches
//  Branches verwalten

////
Ein Branch ist in Git im Nu erstellt.
Git muss lediglich den aktuell ausgecheckten Commit identifizieren und die SHA-1-Summe in der Datei `.git/refs/heads/<branch-name>` ablegen.
////

A branch is created in Git in no time.
All Git needs to do is identify the currently checked out commit and store the SHA-1 sum in the `.git/refs/heads/<branch-name>` file.


[subs="quotes"]
--------
$ *time git branch neuer-branch*
git branch neuer-branch  0.00s user 0.00s system 100% cpu 0.008 total
--------


////
Das Kommando ist so schnell, weil (im Gegensatz zu anderen Systemen) keine Dateien kopiert und keine weiteren Metadaten abgelegt werden müssen.
Informationen über die Struktur der Versionsgeschichte sind immer aus dem Commit, den ein Branch referenziert, und seinen Vorfahren ableitbar.
////

The command is so fast because (unlike other systems) no files need to be copied and no additional metadata needs to be stored.
Information about the structure of the version history can always be derived from the commit that a branch references and its ancestors.


////
Hier eine Übersicht der wichtigsten Optionen:
////

Here is an overview of the most important options:


////
`git branch [-v]` ::
Listet lokale Branches auf.
Dabei ist der aktuell ausgecheckte Branch mit einem Sternchen markiert.
Mit `-v` werden außerdem die Commit-IDs, auf die die Branches zeigen, sowie die erste Zeile der Beschreibung der entsprechenden Commits angezeigt.
////

`git branch [-v]` ::
Lists local branches.
The currently checked-out branch is marked with an asterisk.
You can also use `-v` to display the commit IDs to which the branches point and the first line of the description of the corresponding commits.
+
[subs="quotes"]
--------
$ *git branch -v*
  maint  65f13f2 Start 1.7.5.1 maintenance track
* master 791a765 Update draft release notes to 1.7.6
  next   b503560 Merge branch \_master_ into next
  pu     d7a491c Merge branch \_js/info-man-path_ into pu
--------

////
`git branch <branch> [<ref>]` ::
Erstellt einen neuen Branch `<branch>`, der auf Commit `<ref>` zeigt (`<ref>` kann die SHA-1-Summe eines Commits sein, ein anderer Branch usw.).
Wenn Sie keine Referenz angeben, ist dies `HEAD`, der aktuelle Branch.
////

`git branch <branch> [<ref>]` ::
Creates a new branch `<branch>` pointing to commit `<ref>` (`<ref>` can be the SHA-1 sum of a commit, another branch, etc.).
If you do not specify a reference, this is HEAD, the current branch.

////
`git branch -m  <neuer-name>`::
`git branch -m  <alter-name> <neuer-name>`
+
In der ersten Form wird der aktuelle Branch in `<neuer-name>` umbenannt.
In der zweiten Form wird `<alter-name>` in `<neuer-name>` umbenannt.
Das Kommando schlägt fehl, wenn dadurch ein anderer Branch überschrieben würde.
////


`git branch -m  <new-name>` :: {empty}

`git branch -m  <old-name> <new-name>` ::
In the first form the current branch is renamed to `<new-name>`.
In the second form `<old-name>` is renamed to `<new-name>`.
The command fails if this would overwrite another branch.
+
[subs="quotes"]
--------
$ *git branch -m master*
fatal: A branch named 'master' already exists.
--------
+
////
Wenn Sie einen Branch umbenennen, gibt Git keine Meldung aus.
Sie können also hinterher überprüfen, dass die Umbenennung erfolgreich war:
////
If you rename a branch, Git will not display a message.
So you can check afterwards to make sure the renaming was successful:
+
[subs="quotes"]
--------
$ *git branch*
* master
  test
$ *git branch -m test pu/feature*
$ *git branch*
* master
  pu/feature
--------



////
`git branch -M ...` ::
Wie `-m`, nur dass ein Branch auch umbenannt wird, wenn dadurch ein anderer überschrieben wird.
Achtung: Dabei können Commits des überschriebenen Branches verlorengehen!
////

`git branch -M ...` ::
Like `-m`, except that a branch is also renamed if it overwrites another branch.
Attention: Commits of the overwritten branch may be lost!


////
`git branch -d <branch>` ::
Löscht `<branch>`.
Sie können mehrere Branches gleichzeitig angeben.
Git weigert sich, einen Branch zu löschen, wenn er noch nicht komplett in seinen Upstream-Branch, oder, falls dieser nicht existiert, in `HEAD`, also den aktuellen Branch, integriert ist.
(Mehr über Upstream-Branches finden Sie in Abschnitt 5.3.2, "git pull".)
////

`git branch -d <branch>` ::
Delete `<branch>`.
You can specify several branches at once.
Git refuses to delete a branch if it is not yet fully integrated into its upstream branch, or, if it does not exist, into `HEAD`, the current branch.
(For more on upstream branches, see <<sec.pull>>).



////
`git branch -D ...` ::
Löscht einen Branch, auch wenn er Commits enthält, die noch nicht in den Upstream- oder aktuellen Branch integriert wurden.
Achtung: Diese Commits können möglicherweise verlorengehen, wenn sie nicht anders referenziert werden.
////

`git branch -D ...` ::
Deletes a branch, even if it contains commits that have not yet been integrated into the upstream or current branch.
Note: These commits may be lost unless they are referenced differently.




[[sec.branch-checkout]]
==== Changing Branches: Checkout
//   Branches wechseln: checkout

////
Branches wechseln Sie mit `git checkout <branch>`.
Wenn Sie einen Branch erstellen und direkt darauf wechseln wollen, verwenden Sie `git checkout -b <branch>`.
Das Kommando ist äquivalent zu `git branch <branch> && git checkout <branch>`.
////

You can change branches with `git checkout <branch>`.
If you create a Branch and want to switch directly to it, use `git checkout -b <branch>`.
The command is equivalent to `git branch <branch> && git checkout <branch>`.



////
Was passiert bei einem Checkout?
Jeder Branch referenziert einen Commit, der wiederum einen Tree referenziert, also das Abbild einer Verzeichnisstruktur.
Ein `git checkout <branch>` löst nun die Referenz `<branch>` auf einen Commit auf und repliziert den Tree des Commits auf den Index und auf den Working Tree (d.h.  auf das Dateisystem).
////

What happens during a checkout?
Each branch references a commit, which in turn references a tree, that is, the image of a directory structure.
A `git checkout <branch>` now resolves the reference `<branch>` to a commit and replicates the commit's tree to the index and to the working tree (i.e., the filesystem).


////
Da Git weiß, in welcher Version Dateien aktuell in Index und Working Tree vorliegen, müssen nur die Dateien, die sich auf dem aktuellen und dem neuen Branch unterscheiden, ausgecheckt werden.
////

Since Git knows which version of files are currently in the index and working tree, only the files that differ on the current and new branches need to be checked out.

////
Git macht es Anwendern schwer, Informationen zu verlieren.
Daher wird ein Checkout eher fehlschlagen als eventuell nicht abgespeicherte Änderungen in einer Datei überschreiben.
Das passiert in den folgenden beiden Fällen:
////

Git makes it hard for users to lose information.
Therefore, a checkout is more likely to fail than overwrite any unsaved changes in a file.
This happens in the following two cases:



////
* Der Checkout würde eine Datei im Working Tree überschreiben, in der sich Änderungen befinden.
  Git gibt folgende Fehlermeldung aus: `error: Your local changes to the following files
  would be overwritten by checkout: datei`.
////

* The checkout would overwrite a file in the working tree that contains changes.
  Git will display the following error message: `error: Your local changes to the following files would be overwritten by checkout: file`.

////
* Der Checkout würde eine ungetrackte Datei überschreiben, d.h. eine Datei, die nicht von Git verwaltet wird.
  Git bricht dann mit der Fehlermeldung ab: `error: The following untracked working tree files would be overwritten by checkout: datei`.
////

* The checkout would overwrite an untracked file, i.e. a file that is not managed by Git.
  Git then aborts with the error message: error: `The following untracked working tree files would be overwritten by checkout: file.`


////
Liegen allerdings Änderungen im Working Tree oder Index vor, die mit beiden Branches verträglich sind, übernimmt ein Checkout diese Änderungen.
Das sieht dann z.B. so aus:
////

If, however, changes are stored in the working tree or index that are compatible with both branches, a checkout takes over these changes.
This would look like this, for example:

// @TRANSLATE GIT LOG?
// @NOTE: Why "master" is in italics?
[subs="quotes"]
--------
$ *git checkout master*
A   neue-datei.txt
Switched to branch _master_
--------


////
Das bedeutet, dass die Datei `neue-datei.txt` hinzugefügt wurde, die auf keinem der beiden Branches existiert.
Da hier also keine Informationen verlorengehen können, wird die Datei einfach übernommen.
Die Meldung: `A neue-datei.txt` erinnert Sie, um welche Dateien Sie sich noch kümmern sollten.
Dabei steht `A` für hinzugefügt (_added_), `D` für gelöscht (_deleted_) und `M` für geändert (_modified_).
////

This means that the file `new-file.txt` was added, which does not exist on either branch.
So since no information can be lost here, the file is simply transferred.
The message: `A new-file.txt` reminds you which files you should still take care of.
`A` stands for _added_, `D` for _deleted_ and `M` for _modified_.


////
Wenn Sie ganz sicher sind, dass Sie Ihre Änderungen nicht mehr brauchen, können Sie per `git checkout -f` die Fehlermeldungen ignorieren und den Checkout trotzdem ausführen.
////

If you're sure you don't need your changes anymore, you can use `git checkout -f` to ignore the error messages and run the checkout anyway.


////
Wenn Sie sowohl die Änderungen behalten als auch den Branch wechseln wollen (Beispiel: Arbeit unterbrechen und auf einem anderen Branch einen Fehler korrigieren), dann hilft `git stash` (Abschnitt 4.5, "Veränderungen auslagern -- git stash").
////

If you want to keep the changes and change the branch (e.g., interrupt your work and fix a bug on another branch), `git stash` will help (<<sec.stash>>).




[[sec.branch-naming]]
====  Conventions for Naming Branches
//    Konventionen zur Benennung von Branches

////
Sie können Branches prinzipiell fast beliebig benennen.
Ausnahmen sind aber Leerzeichen, einige Sonderzeichen mit spezieller Bedeutung für Git (z.B.``{asterisk}``, `^`, `:`, `~`), sowie zwei aufeinanderfolgende Punkte (`..`) oder ein Punkt am Anfang des Namens.[31]
////

In principle, you can name branches almost arbitrarily.
Exceptions are spaces, some special characters with special meaning for Git (e.g. ``{asterisk}``, `^`, `:`, `~`), as well as two consecutive dots (`..`) or a dot at the beginning of the name.{fn31}


////
Sinnvollerweise sollten Sie Branch-Namen immer komplett in Kleinbuchstaben angeben.
Da Git Branch-Namen unter `.git/refs/heads/` als Dateien verwaltet, ist die Groß- und Kleinschreibung wesentlich.
////

It makes sense to always enter branch names completely in lower case letters.
Since Git manages branch names under `.git/refs/heads/` as files, it is essential that you use upper and lower case.


////
Sie können Branches in "`Namespaces`" gruppieren, indem Sie als Separator einen `/` verwenden.
Branches, die mit der Übersetzung einer Software zu tun haben, können Sie dann z.B. `i18n/german`, `i18n/english` etc. nennen.
Auch können Sie, wenn sich mehrere Entwickler ein Repository teilen, "`private`" Branches unter `<username>/<topic>` anlegen.
Diese Namespaces werden durch eine Verzeichnisstruktur abgebildet, so dass dann unter `.git/refs/heads/` ein Verzeichnis `<username>/` mit der Branch-Datei `<topic>` erstellt wird.
////

You can group branches into "`namespaces`" by using a `/` as a separator.
Branches that are related to the translation of a software can then be named e.g. `i18n/german`, `i18n/english` etc.
If several developers share a repository, you can also create "`private`" branches under `<username>/<topic>`.
These namespaces are represented by a directory structure, so that a directory `<username>/` with the branch file `<topic>` is created under `.git/refs/heads/`.


////
Der Hauptentwicklungszweig Ihres Projekts sollte immer `master` heißen.
Bugfixes werden häufig auf einem Branch `maint` (kurz für "`maintenance`") verwaltet.
Das nächste Release wird meist auf `next` vorbereitet.
Features, die sich noch in einem experimentellen Zustand befinden, sollten in `pu` (für "`proposed updates`") entwickelt werden oder in `pu/<feature>`.
Eine detailliertere Beschreibung, wie Sie mit Branches die Entwicklung strukturieren und Release-Zyklen organisieren, finden Sie in Kapitel 6, _Workflows_ über Workflows.
////

The main development branch of your project should always be called `master`.
Bugfixes are often managed on a branch `maint` (short for "`maintenance`").
The next release is usually prepared for `next`.
Features that are still in an experimental state should be developed in `pu` (for "`proposed updates`") or in `pu/<feature>`.
For a more detailed description of how to use branches to structure development and organize release cycles, see <<ch.workflows>> on Workflows.




[[sec.no-ref-commits]]
==== Deleted Branches and "`Lost`" Commits
//   Gelöschte Branches und "`verlorene`" Commits

////
Commits kennen jeweils einen oder mehrere Vorgänger.
Daher kann man den Commit-Graphen "`gerichtet`", d.h. von neueren zu älteren Commits, durchlaufen, bis man an einem Wurzel-Commit ankommt.
////

Commits each have one or more predecessors.
Therefore, you can walk through the commit graph "`directed`", that is, from newer to older commits, until you reach a root commit.


////
Andersherum geht das nicht: Wenn ein Commit seinen Nachfolger kennen würde, müsste diese Version irgendwo gespeichert werden.
Dadurch würde sich die SHA-1-Summe des Commits ändern, worauf der Nachfolger den entsprechend neuen Commit referenzieren müsste, dadurch eine neue SHA-1-Summe erhielte, so dass wiederum der Vorgänger geändert werden müsste usw.
Git kann also die Commits nur von einer benannten Referenz aus (z.B.  ein Branch oder `HEAD`) in Richtung früherer Commits durchgehen.
////

It's not the other way around: if a commit knew its successor, that version would have to be stored somewhere.
This would change the SHA-1 sum of the commit, and the successor would have to reference the corresponding new commit, which would give it a new SHA-1 sum, so the predecessor would have to be changed, and so on.
So Git can only go through the commits from a named reference (such as a branch or `HEAD`) in the direction of earlier commits.


////
Wenn daher die "`Spitze`" eines Branches gelöscht wird, wird der oberste Commit nicht mehr referenziert (im Git-Jargon: _unreachable_).
Dadurch wird der Vorgänger nicht mehr referenziert usw. -- bis der nächste Commit auftaucht, der irgendwie referenziert wird (sei es von einem Branch oder dadurch, dass er einen Nachfolger hat, der wiederum von einem Branch referenziert wird).
////

Therefore, if the "`top`" of a branch is deleted, the topmost commit is no longer referenced (in Git jargon: _unreachable_).
As a result, the predecessor is no longer referenced, and so on, until the next commit comes along that is referenced in some way (either by a branch, or by having a successor that is itself referenced by a branch).


////
Wenn Sie einen Branch löschen, werden die Commits auf diesem Branch also nicht gelöscht, sie gehen nur "`verloren`".
Git findet sie einfach nicht mehr.
////

So when you delete a branch, the commits on that branch are not deleted, they are just "`lost`".
Git simply doesn't find them anymore.


////
In der Objektdatenbank sind sie allerdings noch eine Weile lang vorhanden.[32]
Sie können also einen Branch ohne weiteres wiederherstellen, indem Sie den vorherigen (und vermeintlich gelöschten) Commit explizit als Referenz angeben:
////

However, they will still be present in the object database for a while.{fn32}
So you can easily restore a branch by explicitly specifying the previous (and supposedly deleted) commit as a reference:



[subs="quotes"]
--------
$ *git branch -D test*
Deleted branch test (was e32bf29).
$ *git branch test e32bf29*
--------


////
Eine weitere Möglichkeit, gelöschte Commits wiederzufinden, ist das
_Reflog_ (siehe dafür Abschnitt 3.7, "Reflog").
////

Another way to retrieve deleted commits is the _reflog_ (see <<sec.reflog>>).




[[sec.tags]]
=== Tags -- Marking Important Versions
//  Tags -- Wichtige Versionen markieren

////
SHA-1-Summen sind zwar eine sehr elegante Lösung, um Versionen dezentral zu beschreiben, aber semantikarm und für Menschen unhandlich.
Im Gegensatz zu linearen Revisionsnummern sagen uns Commit-IDs allein nichts über die Reihenfolge der Versionen.
////

SHA-1 sums are a very elegant solution to describe versions decentrally, but they are semantically poor and unwieldy for humans.
Unlike linear revision numbers, commit IDs alone tell us nothing about the order of versions.


////
Während der Entwicklung von Softwareprojekten müssen verschiedene "`wichtige`" Versionen so markiert werden, dass sie leicht in dem Repository zu finden sind.
Die wichtigsten sind meist solche, die veröffentlicht werden, die sogenannten _Releases_.
Auch _Release Candidates_ werden häufig auf diese Weise markiert, also Versionen, die die Basis für die nächste Version bilden und im Zuge der Qualitätssicherung auf kritische Fehler untersucht werden, ohne dass neue Features hinzugefügt werden.
Je nach Projekt und Entwicklungsmodell gibt es verschiedene Konventionen, um Releases zu bezeichnen, und Abläufe, wie sie vorbereitet und publiziert werden.
////

During the development of software projects, different "`important`" versions need to be marked so that they can be easily found in the repository.
The most important ones are usually those that are released, called _releases_.
_Release candidates_ are also often marked in this way, i.e. versions that form the basis for the next version and are checked for critical bugs in the course of quality assurance without adding new features.
Depending on the project and development model, there are different conventions for marking releases and procedures for preparing and publishing them.


////
Im Open-Source-Bereich haben sich zwei Versionierungsschemata durchgesetzt: die klassische _Major/Minor/Micro-Versionierung_ und neuerdings auch die _datumsbasierte Versionierung_.
Bei der Major/Minor/Micro-Versionierung, welche z.B. beim Linux-Kernel und auch Git eingesetzt wird, ist eine Version durch drei (oft auch vier) Zahlen gekennzeichnet: `2.6.39` oder `1.7.1`.
Bei der datumsbasierten Versionierung hingegen ist die Bezeichnung aus dem Zeitpunkt des Releases abgeleitet, z.B.: `2011.05` oder `2011-05-19`.
Das hat den großen Vorteil, dass das Alter einer Version leicht ersichtlich ist.[33]
////

In the open source area, two versioning schemes have become established: the classic _major_/_minor_/_micro versioning_ scheme and, more recently, _date-based versioning_.
With major/minor/micro versioning, which is used e.g. with the Linux kernel and also Git, a version is identified by three (often four) numbers: `2.6.39` or `1.7.1`.
With date-based versioning, on the other hand, the designation is derived from the time of the release, e.g.: `2011.05` or `2011-05-19`.
This has the great advantage that the age of a version is easily identifiable.{fn33}


////
Git bietet Ihnen mit _Tags_ ("`Etiketten`") die Möglichkeit, beliebige Git-Objekte -- meist Commits -- zu markieren, um markante Zustände in der Entwicklungsgeschichte hervorzuheben.
Tags sind, wie Branches auch, als Referenzen auf Objekte implementiert.
Im Gegensatz zu Branches jedoch sind Tags statisch, das heißt, sie werden nicht verschoben, wenn neue Commits hinzukommen, und zeigen stets auf dasselbe Objekt.
Es gibt zwei Arten von Tags: _Annotated_ (mit Anmerkungen versehen) und _Lightweight_ ("`leichtgewichtig`", d.h. ohne Anmerkungen).
Annotated Tags sind mit Metadaten -- z.B. Autor, Beschreibung oder GPG-Signatur -- versehen.
Lightweight Tags zeigen hingegen "`einfach nur`" auf ein bestimmtes Git-Objekt.
Für beide Arten von Tags legt Git unter `.git/refs/tags/` bzw. `.git/packed-refs` Referenzen an.
Der Unterschied ist, dass Git für jedes Annotated Tag ein spezielles Git-Objekt -- und zwar ein _Tag-Objekt_ -- in der Objektdatenbank anlegt, um die Metadaten sowie die SHA-1-Summe des markierten Objekts zu speichern, während ein Lightweight Tag direkt auf das markierte Objekt zeigt.
Abbildung 3.4, "Das Tag-Objekt" zeigt den Inhalt eines Tag-Objekts; vergleichen Sie auch die anderen Git-Objekte, Abbildung 2.4, "Git-Objekte".
////

Git offers _tags_ ("`labels`") that can be used to mark any Git object -- usually commits -- to highlight prominent states in its development history.
Like branches, tags are implemented as references to objects.
Unlike branches, however, tags are static, meaning that they are not moved when new commits are added, and always point to the same object.
There are two types of tags: _annotated_ and _lightweight_.
Annotated tags are tagged with metadata, such as author, description, or GPG signature.
Lightweight tags, on the other hand, "`simply`" point to a specific Git object.
For both types of tags, Git creates references under `.git/refs/tags/` or `.git/packed-refs`.
The difference is that for each annotated tag, Git creates a special Git object -- a _tag object_ -- in the Object Database to store the metadata and SHA-1 sum of the selected object, while a Lightweight tag points directly to the selected object.
<<fig.tag-object>> shows the contents of a tag object; compare also the other git objects, <<fig.git-objects>>.


// @TRANSLATE IMAGE TEXT?

// @IMPORTANT! This diagram should have same scaledwidth as Fig. 4!
// .Das Tag-Objekt
.The Tag Object
image::tags.svg[id="fig.tag-object",scaledwidth="90%",width="90%",align="center"]


////
Das gezeigte Tag-Objekt hat sowohl eine Größe (158 Byte) als auch eine SHA-1-Summe.
Es enthält die Bezeichnung (`0.1`), den Objekt-Typ und die SHA-1-Summe des referenzierten Objekts sowie den Namen und E-Mail des Autors, der im Git-Jargon _Tagger_ heißt.
Außerdem enthält das Tag eine Tag-Message, die zum Beispiel die Version beschreibt, sowie optional eine GPG-Signatur.
Im Git-Projekt etwa besteht eine Tag-Message aus der aktuellen Versionsbezeichnung und der Signatur des Maintainers.
////

The tag object shown has both a size (158 bytes) and a SHA-1 sum.
It contains the name (`0.1`), the object type and the SHA-1 sum of the referenced object as well as the name and e-mail of the author, which is called _tagger_ in Git jargon.
In addition, the tag contains a tag message that describes the version, for example, and optionally a GPG signature.
In the Git project, for example, a tag message consists of the current version designation and the signature of the maintainer.


////
Schauen wir im Folgenden zunächst, wie Sie Tags lokal verwalten.
Wie Sie Tags zwischen Repositories austauschen, beschreibt Abschnitt 5.8, "Tags austauschen".
////

In the following, let's first look at how you manage tags locally.
<<sec.remote-tags>> describes how you exchange tags between repositories.




[[sec.managing-tags]]
==== Managing Tags
//   Tags verwalten

////
Tags verwalten Sie mit dem Kommando `git tag`.
Ohne Argumente zeigt es alle vorhandenen Tags an.
Je nach Projektgröße lohnt es sich, die Ausgabe mit der Option `-l` und einem entsprechenden Muster einzuschränken.
Mit folgendem Befehl zeigen Sie alle Varianten der Version `1.7.1` des Git-Projekts an, also sowohl die Release-Candidates mit dem Zusatz `-rc*` sowie die (vierstelligen) Maintenance-Releases:
////

You can manage tags with the command `git tag`.
Without arguments it shows all existing tags.
Depending on the size of the project, it is worth limiting the output with the `-l` option and a corresponding pattern.
With the following command you display all variants of version 1.7.1 of the git project, i.e. both the release candidates with the addition `-rc*` and the (four-digit) maintenance releases:


[subs="quotes,attributes"]
--------
$ *git tag -l v1.7.1{asterisk}*
v1.7.1
v1.7.1-rc0
v1.7.1-rc1
v1.7.1-rc2
v1.7.1.1
v1.7.1.2
v1.7.1.3
v1.7.1.4
--------



////
Den Inhalt eines Tags liefert Ihnen `git show`:
////

The content of a tag is provided by `git show`:


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git show 0.1 | head*
tag 0.1
Tagger: Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
Date:   Wed Mar 23 16:52:03 2011 +0100

Erste Veröffentlichung

commit e2c67ebb6d2db2aab831f477306baa44036af635
Author: Valentin Haenel &lt;valentin.haenel@gmx.de&gt;
Date:   Sat Jan 8 20:30:58 2011 +0100
--------


////
Gitk stellt Tags als gelbe, pfeilartige Kästchen dar, die sich
deutlich von den grünen, rechteckigen Branches unterscheiden:
////

Gitk presents tags as yellow, arrow-like boxes that are clearly distinguishable from the green, rectangular branches:

.Tags in Gitk
image::tag-screenshot.png[id="fig.tag-gitk",scaledwidth="90%",width="90%",align="center"]





[[sec.lightweight-tags]]
==== Lightweight Tags

////
Um den `HEAD` mit einem Lightweight Tag zu versehen, übergeben
Sie den gewünschten Namen an das Kommando (in diesem Beispiel, um einen
wichtigen Commit zu markieren):
////

To add a lightweight tag to the `HEAD`, pass the desired name to the command (in this example, to mark an important commit)


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git tag api-aenderung*
$ *git tag*
api-aenderung
--------


////
Sie können aber auch die SHA-1-Summe eines Objekts oder eine valide Revisionsbezeichnung (z.B.{empty}{nbsp}`master` oder `HEAD~23`) angeben, um ein Objekt nachträglich zu markieren.
////

To add a lightweight tag to the `HEAD`, pass the desired name to the command (in this example, to mark an important commit)


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git tag pre-regression HEAD~23*
$ *git tag*
api-aenderung
pre-regression
--------


////
Tags sind einzigartig -- sollten Sie versuchen, ein Tag erneut zu erzeugen, bricht Git mit einer Fehlermeldung ab:
////

Tags are unique -- if you try to recreate a tag, Git will abort with an error message:


[subs="quotes"]
--------
$ *git tag pre-regression*
fatal: tag 'pre-regression' already exists
--------





[[sec.annotated-tags]]
==== Annotated Tags

////
Annotated Tags erzeugen Sie mit der Option `-a`.
Wie bei `git commit` öffnet sich ein Editor, mit dem Sie die Tag-Message verfassen.
Oder Sie übergeben die Tag-Message mit der Option `-m` -- dann ist die Option `-a` redundant:
////

Annotated tags are created with the `-a` option.
As with `git commit`, an editor will open and allow you to write the tag message.
Or you can pass the tag message with the option `-m` -- in which case the option `-a` is redundant:


[subs="quotes"]
--------
$ *git tag -m "Zweite Veröffentlichung" 0.2*
--------




[[sec.signed-tags]]
==== Signed Tags
//   Signierte Tags

////
Um ein signiertes Tag zu überprüfen, verwenden Sie die Option `-v` (_verify_):
////

To verify a signed tag, use the `-v` (_verify_) option:

[subs="quotes"]
--------
$ *git tag -v v1.7.1*
object d599e0484f8ebac8cc50e9557a4c3d246826843d
type commit
tag v1.7.1
tagger Junio C Hamano &lt;gitster@pobox.com&gt; 1272072587 -0700

Git 1.7.1
gpg: Signature made Sat Apr 24 03:29:47 2010 CEST using DSA key ID F3119B9A
gpg: Good signature from "Junio C Hamano &lt;junkio@cox.net&gt;"
...
--------


////
Das setzt natürlich voraus, dass Sie sowohl GnuPG installiert als auch den Schlüssel des Signierenden bereits importiert haben.
////

Of course, this assumes that you have both GnuPG installed and that you have already imported the signer's key.

////
Um selbst Tags zu signieren, müssen Sie zunächst den dafür bevorzugten Key einstellen:
////

In order to sign tags yourself, you must first set the preferred key:


[subs="quotes"]
--------
$ *git config --global user.signingkey &lt;GPG-Key-ID&gt;*
--------

////
Nun können Sie signierte Tags mit der Option `-s` (_sign_) erstellen:
////

Now you can create signed tags with the `-s` (_sign_) option:


[subs="quotes"]
--------
$ *git tag -s -m "Dritte Veröffentlichung" 3.0*
--------




[[sec.deleting-tags]]
==== Deleting and Overwriting Tags
//   Tags löschen und überschreiben

////
Mit den Optionen `-d` und `-f` löschen Sie Tags bzw. überschreiben sie:
////

Use the `-d` and `-f` options to delete or overwrite tags:

[subs="quotes"]
--------
$ *git tag -d 0.2*
Deleted tag '0.2' (was 4773c73)
--------


////
Die Optionen sind mit Vorsicht zu genießen, besonders wenn Sie die Tags nicht nur lokal verwenden, sondern auch veröffentlichen.
Unter bestimmten Umständen kann es dazu kommen, dass Tags unterschiedliche Commits bezeichnen -- Version `1.0` im Repository X zeigt auf einen anderen Commit als Version `1.0` im Repository Y.
Aber sehen Sie hierzu auch Abschnitt 5.8, "Tags austauschen".
////

The options should be used with caution, especially if you use the tags not only locally, but also publish them.
Under certain circumstances, tags may indicate different commits -- version `1.0` in repository X points to a different commit than version `1.0` in repository Y.
But see also <<sec.remote-tags>>.




[[sec.tags-lightweight-vs-heavyweight]]
==== Lightweight vs. Annotated Tags

////
Für die öffentliche Versionierung von Software sind allgemein Annotated Tags sinnvoller.
Sie enthalten im Gegensatz zu Lightweight Tags Metainformationen, aus denen zu ersehen ist, wer wann ein Tag erstellt hat -- der Ansprechpartner ist eindeutig.
Auch erfahren Benutzer einer Software so, wer eine bestimmte Version abgesegnet hat.
Zum Beispiel ist klar, dass Junio C. Hamano die Git-Version 1.7.1 getaggt hat -- sie hat also quasi sein "`Gütesiegel`".
Die Aussage bestätigt natürlich auch die kryptographische Signatur.
Lightweight Tags hingegen eignen sich vor allem, um lokal Markierungen anzubringen, zum Beispiel um bestimmte, für die aktuelle Aufgabe relevante Commits zu kennzeichnen.
Achten Sie aber darauf, solche Tags nicht in ein öffentliches Repository hochzuladen (siehe  Abschnitt 5.8, "Tags austauschen"), da diese sich sonst verbreiten könnten.
Sofern Sie die Tags nur lokal verwenden, können Sie sie auch löschen, wenn sie ihren Dienst erfüllt haben (s.o.).
////

For public versioning of software, annotated tags are generally more useful.
Unlike lightweight tags, they contain meta-information that shows who created a tag and when -- the person contact is unique.
Users of software can also find out who has approved a particular version.
For example, it's clear that Junio C. Hamano has tagged Git version 1.7.1 -- so it has his "`seal of approval`".
The statement also confirms the cryptographic signature, of course.
Lightweight tags, on the other hand, are particularly suitable for applying local markers, for example to identify certain commits relevant to the current task.
However, make sure not to upload such tags to a public repository (see <<sec.remote-tags>>), as they might spread.
If you only use the tags locally, you can also delete them once they have fulfilled their service (see above).



[[sec.non-commit-tags]]
==== Non-Commit Tags

////
Mit Tags markieren Sie beliebige Git-Objekte, also nicht nur Commits, sondern auch Tree-, Blob- und sogar Tag-Objekte selbst!
Das klassische Beispiel ist, den öffentlichen GPG-Schlüssel, der von dem Maintainer eines Projekts zum Signieren von Tags verwendet wird, in einem Blob zu hinterlegen.
////

With tags you can mark any Git object, not only commits, but also trees, blobs and even tag objects themselves!
The classic example is to put the GPG public key used by the maintainer of a project to sign tags in a blob.

////
So zeigt das Tag `junio-gpg-pub` im Git-Repository von Git auf den Schlüssel von Junio C. Hamano:
////

For example, the tag `junio-gpg-pub` in the Git repository of Git points to the key of Junio C. Hamano:


[subs="quotes"]
--------
$ *git show junio-gpg-pub | head -5*
tag junio-gpg-pub
Tagger: Junio C Hamano &lt;junkio@cox.net&gt;
Date:   Tue Dec 13 16:33:29 2005 -0800

GPG key to sign git.git archive.
--------



////
Weil dieses Blob-Objekt von keinem Tree referenziert wird, ist die Datei quasi getrennt vom eigentlichen Code, aber dennoch im Repository vorhanden.
Außerdem ist ein Tag auf einen "`einsamen`" Blob notwendig, damit dieser nicht als _unreachable_ gilt und im Zuge der Repository-Wartung gelöscht wird.[34]
////

Because this blob object is not referenced by any tree, the file is virtually separate from the actual code, but still exists in the repository.
In addition, a tag on a "`lonely`" blob is necessary so that it is not considered unreachable and is deleted during repository maintenance.{fn34}

////
Um den Schlüssel zu verwenden, gehen Sie wie folgt vor:
////

To use the key, proceed as follows:


[subs="quotes"]
--------
$ *git cat-file blob junio-gpg-pub | gpg --import*
gpg: key F3119B9A: public key "Junio C Hamano &lt;junkio@cox.net&gt;" imported
gpg: Total number processed: 1
gpg:               imported: 1
--------


////
Sie können dann, wie oben beschrieben, alle Tags im Git-via-Git-Repository verifizieren.
////

You can then verify all tags in the Git-via-Git repository, as described above.



[[sec.git-describe]]
==== Describing Commits
//   Commits beschreiben

////
Tags sind sehr nützlich, um beliebige Commits "`besser`" zu beschreiben.
Das Kommando `git describe` gibt eine Beschreibung, die aus dem aktuellsten Tag und dessen relativer Position im Commit-Graphen besteht.
Hier ein Beispiel aus dem Git-Projekt: Wir beschreiben einen Commit mit dem SHA-1-Präfix `28ba96a`, der sich im Commit-Graphen sieben Commits nach der Version `1.7.1` befindet:
////

Tags are very useful for describing any commit "`better`".
The `git describe` command gives a description consisting of the most recent tag and its relative position in the commit graph.
Here's an example from the git project: we describe a commit with the SHA-1 prefix `28ba96a`, which is located in the commit graph seven commits after version `1.7.1`:


// .Der zu beschreibende Commit in Grau hervorgehoben
.The commit to be described highlighted in gray
image::describe-screenshot.png[id="fig.describe",scaledwidth="90%",width="90%",align="center"]


[subs="quotes"]
--------
$ *git describe --tags*
v1.7.1-7-g28ba96a
--------


////
Die Ausgabe von `git describe` ist wie folgt formatiert:
////

The output of `git describe` is formatted as follows:


--------
<tag>-<position>-g<SHA-1>
--------


////
Das Tag ist `v1.7.1`; die Position besagt, dass sich sieben neue Commits zwischen dem Tag und dem beschriebenen Commit befinden.[35]
Das Kürzel `g` vor der ID besagt, dass die Beschreibung aus einem Git-Repository abgeleitet ist, was in Umgebungen mit mehreren Versionsverwaltungssystemen nützlich ist.
Standardmäßig sucht `git describe` nur nach Annotated Tags, mit der Option `--tags` erweitern Sie die Suche auch auf Lightweight Tags.
////

The tag is `v1.7.1`; the position indicates that there are seven new commits between the tag and the described commit.{fn35}
The `g` before the ID indicates that the description is derived from a Git repository, which is useful in environments with multiple version control systems.
By default, `git describe` only searches for annotated tags, but the `--tags` option extends the search to include lightweight tags.

////
Das Kommando ist sehr nützlich, weil es einen inhaltsbasierten Bezeichner in etwas für Menschen Sinnvolles übersetzt: `v1.7.1-7-g28ba96a` ist deutlich näher an `v1.7.1` als `v1.7.1-213-g3183286`.
Dadurch können Sie die Ausgaben sinnvoll -- wie im Git-Projekt auch -- direkt in die Software einkompilieren:
////

The command is very useful because it translates a content-based identifier into something useful for humans: `v1.7.1-7-g28ba96a` is much closer to `v1.7.1` than `v1.7.1-213-g3183286`.
This allows you to compile the output directly into the software in a way that makes sense, just like in the Git project:



[subs="quotes"]
--------
$ *git describe*
v1.7.5-rc2-8-g0e73bb4
$ *make*
GIT_VERSION = 1.7.5.rc2.8.g0e73bb
...
$ *./git --version*
git version 1.7.5.rc2.8.g0e73bb
--------


////
Somit weiß ein Benutzer ungefähr, welche Version er hat, und kann nachvollziehen, aus welchem Commit die Version kompiliert wurde.
////

This way a user knows roughly what version he has, and can track which commit the version was compiled from.




[[sec.undo]]
== Restoring Versions
// Versionen wiederherstellen

////
Ziel einer Versionskontrollsoftware ist es nicht nur, Änderungen zwischen Commits zu untersuchen.
Wichtig ist vor allem auch, ältere Versionen einer Datei oder ganzer Verzeichnisbäume wiederherzustellen oder Änderungen rückgängig zu machen.
Dafür sind in Git insbesondere die Kommandos `checkout`, `reset` und `revert` zuständig.
////

The goal of version control software is not just to examine changes between commits.
Above all, it is also important to restore older versions of a file or entire directory trees, or to undo changes.
In Git, the commands `checkout`, `reset`, and `revert` are particularly useful for this.

//\label{sec:checkout}

////
Das Git-Kommando `checkout` kann nicht nur Branches wechseln, sondern auch Dateien aus früheren Commits wiederherstellen.
Die Syntax lautet allgemein:
////

The Git command `checkout` can not only change branches, but also restore files from previous commits.
The syntax is general:


--------
git checkout [-f] <referenz> -- <muster>
--------


////
`checkout` löst die angegebene Referenz (und wenn diese fehlt, `HEAD`) auf einen Commit auf und extrahiert alle Dateien, die auf `<muster>` passen, in den Working Tree.
Ist `<muster>` ein Verzeichnis, bezieht sich das auf alle darin enthaltenen Dateien und Unterverzeichnisse.
Sofern Sie kein Muster explizit angeben, werden alle Dateien ausgecheckt.
Dabei werden Änderungen an einer Datei nicht einfach überschrieben, es sei denn, Sie geben die Option `-f` an (s.o.).
Außerdem wird `HEAD` auf den entsprechenden Commit (bzw. Branch) gesetzt.
////

`checkout` resolves the given reference (and `HEAD` if missing) to a commit and extracts all files matching `<pattern>` to the working tree.
If `<pattern>` is a directory, it refers to all files and subdirectories in it.
Unless you explicitly specify a pattern, all files are checked out.
Changes to a file are not simply overwritten, unless you specify the `-f` option (see above).
`HEAD` is also set to the corresponding commit (or branch).


////
Wenn Sie allerdings ein Muster angeben, dann überschreibt `checkout` diese Datei(en) ohne Nachfrage.
Um also alle Änderungen an `<datei>` zu verwerfen, geben Sie `git checkout -- <datei>` ein: Git ersetzt dann `<datei>` durch die Version im aktuellen Branch.
Auf diese Weise können Sie auch den älteren Zustand einer Datei rekonstruieren:
////

However, if you specify a pattern, `checkout` overwrites this file(s) without prompting.
So to discard all changes to `<file>`, enter `git checkout -- <file>`: Git then replaces `<file>` with the version in the current branch.
This way, you can also reconstruct the older state of a file:


[subs="quotes"]
--------
$ *git checkout ce66692 -- &lt;datei&gt;*
--------


////
Das doppelte Minus trennt die Muster von den Optionen bzw. Argumenten.
Es ist allerdings nicht notwendig: Gibt es keine Branches oder andere Referenzen mit dem Namen, versucht Git, eine solche Datei zu finden.
Die Separierung macht also nur eindeutig, dass Sie die entsprechende(n) Datei(en) wiederherstellen möchten.
////

The double minus separates the patterns from the options or arguments.
It is not necessary, however: If there are no branches or other references with that name, Git will try to find one.
So the separation only makes it clear that you want to recover the file(s) in question.

////
Um den Inhalt einer Datei aus einem bestimmten Commit anzuschauen, ohne sie auszuchecken, nutzen Sie das folgende Kommando:
////

To view the contents of a file from a particular commit without checking it out, use the following command:


[subs="quotes"]
--------
$ *git show ce66692:&lt;file&gt;*
--------


[TIP]
==================
////
Mit `--patch` bzw. `-p` rufen Sie `git checkout` im interaktiven Modus auf.
Der Ablauf ist der gleiche wie bei `git add -p` (siehe Abschnitt 2.1.2, "Commits schrittweise erstellen"), jedoch können Sie hier Hunks einer Datei schrittweise zurücksetzen.
////

Use `--patch` or `-p` to call `git checkout` in interactive mode.
The procedure is the same as for `git add -p` (see <<sec.add-p>>), but here you can reset hunks of a file step-by-step.
==================




[[sec.detached-head]]
=== Detached HEAD

////
Wenn Sie einen Commit auschecken, der nicht durch einen Branch referenziert wird, befinden Sie sich im sogenannten _Detached-HEAD_-Modus:
////

If you check out a commit that is not referenced by a branch, you are in _detached-HEAD_ mode:


[subs="quotes"]
--------
$ *git checkout 3329661*
Note: checking out '3329661'.

You are in 'detached HEAD' state. You can look around, make
experimental changes and commit them, and you can discard any
commits you make in this state without impacting any branches
by performing another checkout.

If you want to create a new branch to retain commits you create,
you may do so (now or later) by using -b with the checkout command
again. Example:

  git checkout -b new_branch_name

HEAD is now at 3329661... Add LICENSE file
--------


////
Wie die Erklärung, die Sie durch setzen der Option `advice.detachedHead` auf `false` ausblenden können, schon warnt, werden Änderungen, die Sie nun tätigen, im Zweifel verlorengehen: Da Ihr `HEAD` danach die einzige direkte Referenz auf den Commit ist, werden weitere Commits nicht direkt von einem Branch referenziert (sie sind _unreachable_, s.o.).
////

As the explanation, which you can hide by setting the option `advice.detachedHead` to `false`, already warns you, changes you make now will be lost in case of doubt: Since your `HEAD` is the only direct reference to the commit after that, further commits are not directly referenced by a branch (they are _unreachable_, see above).


////
Im Detached-HEAD-Modus zu arbeiten bietet sich also vor allem dann an, wenn Sie schnell etwas probieren wollen: Ist der Fehler eigentlich schon im Commit `3329661` aufgetaucht? Gab es zum Zeitpunkt von `3329661` eigentlich schon die Datei `README`?
////

So working in detached HEAD mode is especially useful if you want to try something quickly: Has the bug actually already appeared in commit `3329661`? Was there actually a `README` file at the time of `3329661`?


[TIP]
============
////
Wenn Sie von dem ausgecheckten Commit aus mehr machen wollen als sich bloß umzuschauen und beispielsweise testen möchten, ob Ihre Software schon damals einen bestimmten Bug hatte, sollten Sie einen Branch erstellen:
////

If you want to do more than just look around from the commit you checked out, for example, to see if your software already had a particular bug at the time, you should create a branch:

[subs="quotes"]
--------
$ *git checkout -b &lt;temp-branch&gt;*
--------

////
Dann können Sie wie gewohnt Commits machen, ohne befürchten zu müssen, dass diese verlorengehen.
////

Then you can make commits as usual without fear of losing them.
============



[[sec.revert]]
=== Rolling Back Commits
//  Commits rückgängig machen

////
Wenn Sie alle Änderungen, die ein Commit einbringt, rückgängig machen wollen, hilft das Kommando `revert`.
Es löscht aber keinen Commit, sondern erstellt einen neuen, dessen Änderungen genau dem Gegenteil des anderen Commits entsprechen: Gelöschte Zeilen werden zu hinzugefügten und umgekehrt.
////

If you want to undo all the changes a commit makes, the `revert` command helps.
However, it does not delete a commit, but creates a new one whose changes are exactly the opposite of the other commit: Deleted lines become added lines, and vice versa.


////
Angenommen, Sie haben einen Commit, der eine Datei `LICENSE` erstellt.
Der Patch des entsprechenden Commits sieht so aus:
////

Suppose you have a commit that creates a `LICENSE` file.
The patch of the corresponding commit looks like this:


--------
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1 @@
+This software is released under the GNU GPL version 3 or newer.
--------


////
Nun können Sie die Änderungen rückgängig machen:
////

Now you can undo the changes:


[subs="quotes"]
--------
$ *git revert 3329661*
Finished one revert.
[master a68ad2d] Revert "Add LICENSE file"
 1 files changed, 0 insertions(+), 1 deletions(-)
 delete mode 100644 LICENSE
--------


////
Git erstellt einen neuen Commit auf dem aktuellen Branch -- sofern Sie nichts anderes angeben -- mit der Beschreibung `Revert "<Alte Commit-Nachricht>"`.
Dieser Commit sieht so aus:
////

Git creates a new commit on the current branch -- unless you specify otherwise -- with the description `Revert "<Old commit message>"`.
This commit looks like this:


[subs="quotes"]
--------
$ *git show*
commit a68ad2d41e9219383449d703521573477ee7da48
Author: Julius Plenz &lt;feh@mali&gt;
Date:   Mon Mar 7 05:28:47 2011 +0100

    Revert "Add LICENSE file"

    This reverts commit 3329661775af3c52e6b2ad7e9e7e7d789ba62712.

diff --git a/LICENSE b/LICENSE
deleted file mode 100644
index 3fd9c20..0000000
--- a/LICENSE
+++ /dev/null
@@ -1 +0,0 @@
-This software is released under the GNU GPL version 3 or newer.
--------


////
Beachten Sie also, dass in der Versionsgeschichte eines Projekts ab nun sowohl der Commit als auch der Revert auftauchen.
Sie machen also nur die _Änderungen_ rückgängig, löschen aber keine Informationen aus der Versionsgeschichte.
////

Note that from now on, both the commit and the revert will appear in the version history of a project.
You therefore only undo the _changes_, but do not delete any information from the version history.


////
Sie sollten daher `revert` nur einsetzen, wenn Sie eine Änderung, die bereits veröffentlicht wurde, rückgängig machen müssen.
Entwickeln Sie allerdings lokal in einem eigenen Branch, ist es sinnvoller, diese Commits komplett zu löschen (siehe dafür den folgenden Abschnitt über `reset` sowie das Thema _Rebase_, Abschnitt 4.1, "Commits verschieben – Rebase").
////

You should therefore only use `revert` if you need to undo a change that has already been published.
However, if you are developing locally in a separate branch, it makes more sense to delete these commits completely (see the following section on `reset` and the topic _Rebase_, <<sec.rebase>>).


////
Sofern Sie einen Revert durchführen wollen, allerdings nicht für sämtliche Änderungen des Commits, sondern nur für die einer Datei, können Sie sich zum Beispiel so behelfen:
////

If you want to perform a rebase, but not for all changes to the commit, but only for those to a file, you can use this procedure:



[subs="quotes"]
--------
$ *git show -R 3329661 -- LICENSE | git apply --index*
$ *git commit -m 'Revert change to LICENSE from 3329661'*
--------


////
Das Kommando `git show` gibt die Änderungen von Commit `3329661` aus, die sich auf die Datei `LICENSE` beziehen.
Die Option `-R` sorgt dafür, dass das Unified-Diff-Format "`andersherum`" angezeigt wird (_reverse_).
Die Ausgabe wird an `git apply` weitergeleitet, um die Änderungen an der Datei und dem Index vorzunehmen.
Anschließend werden die Änderungen eingecheckt.
////

The `git show` command prints the changes from commit `3329661` that apply to the `LICENSE` file.
The `-R` option causes the unified-diff format to be displayed "`the other way around`" (_reverse_).
The output is passed to `git apply` to make the changes to the file and index.
The changes are then checked in.


////
Eine weitere Möglichkeit, eine Änderung rückgängig zu machen, besteht darin, eine Datei aus einem vorherigen Commit auszuchecken, sie dem Index hinzuzufügen und neu einzuchecken:
////

Another way to undo a change is to check out a file from a previous commit, add it to the index, and check it in again:


[subs="quotes"]
--------
$ *git checkout 3329661 -- &lt;datei&gt;*
$ *git add &lt;datei&gt;*
$ *git commit -m 'Reverting &lt;datei&gt; to resemble 3329661'*
--------




[[sec.reset]]
=== Reset and the Index
//  Reset und der Index

////
Wenn Sie einen Commit gänzlich löschen, also nicht nur rückgängig machen, dann verwenden Sie `git reset`.
Das Reset-Kommando setzt den `HEAD` (und damit auch den aktuellen Branch) sowie wahlweise auch Index und Working Tree auf einen bestimmten Commit.
Die Syntax lautet `git reset [<option>] [<commit>]`.
////

If you are deleting a commit completely, not just undoing it, use `git reset`.
The reset command sets the `HEAD` (and thus the current branch), and optionally the index and working tree, to a particular commit.
The syntax is `git reset [<option>] [<commit>]`.


////
Die wichtigsten Reset-Typen sind die folgenden:
////

The most important types of resets are the following:




////
`--soft` ::
Setzt nur den `HEAD` zurück; Index und Working Tree bleiben unberührt.

`--mixed` ::
Voreinstellung, wenn Sie keine Option angeben.
Setzt `HEAD` und Index auf den angegebenen Commit, die Dateien im Working Tree bleiben aber unberührt.

`--hard` ::
Synchronisiert `HEAD`, Index und Working Tree und setzt sie auf den gleichen Commit.
Dabei gehen möglicherweise Änderungen im Working Tree verloren!
////

[horizontal]
`-{wj}-{wj}soft` ::
Resets only the `HEAD`; index and working tree remain unaffected.

`-{wj}-{wj}mixed` ::
Default setting if you do not specify an option.
Sets `HEAD` and index to the specified commit, but the files in the working tree are not affected.

`-{wj}-{wj}hard` ::
Synchronizes `HEAD`, Index and Working Tree and sets them to the same commit.
Changes in the working tree may be lost!



////
Wenn Sie `git reset` ohne Optionen aufrufen, entspricht dies einem `git reset --mixed HEAD`.
Das Kommando haben wir schon kennengelernt: Git setzt den aktuellen `HEAD` auf `HEAD` (verändert ihn also nicht) und den Index auf `HEAD` -- dabei gehen die vorher hinzugefügten Änderungen verloren.
////

If you call `git reset` without any options, this is equivalent to a `git reset --mixed HEAD`.
We've already seen this command: Git sets the current `HEAD` to `HEAD` (so it doesn't change it) and the index to `HEAD` -- in this case, the changes you added before are lost.


////
Die Anwendungsmöglichkeiten dieses Kommandos sind vielfältig und werden in den verschiedenen Kommandosequenzen wieder auftauchen.
Daher ist es wichtig, die Funktionalität zu verstehen, auch wenn es teilweise alternative Kommandos gibt, die den gleichen Effekt haben.
////

The possible uses of this command are many and varied and will reappear in the various command sequences.
Therefore it is important to understand the functionality, even if there are sometimes alternative commands that have the same effect.


////
Angenommen, Sie haben auf `master` zwei Commits gemacht, die Sie eigentlich auf einen neuen Branch verschieben wollen, um noch weiter daran zu arbeiten.
Die folgende Kommandosequenz erstellt einen neuen Branch, der auf den `HEAD` zeigt, und setzt anschließend `HEAD` und damit den aktuellen Branch `master` zwei Commits zurück.
Dann checken Sie den neuen Branch `<neues-feature>` aus.
////

Suppose you have made two commits to `master` that you actually want to move to a new branch to work on further.
The following command sequence creates a new branch pointing to `HEAD`, and then resets `HEAD` and the current branch `master` two commits.
Then check out the new branch `<new-feature>`.


[subs="quotes"]
--------
$ *git branch &lt;neues-feature&gt;*
$ *git reset --hard HEAD^^*
$ *git checkout &lt;neues-feature&gt;*
--------


////
Alternativ hat die folgende Sequenz den gleichen Effekt: Sie erstellen einen Branch `<neues-feature>`, der auf den aktuellen Commit zeigt.
Dann löschen Sie `master` und erstellen ihn neu, so dass er auf den zweiten Vorgänger des aktuellen Commits zeigt.
////

Alternatively, the following sequence has the same effect: you create a Branch `<new-feature>` that points to the current commit.
Then you delete `master` and re-create it so that it points to the second predecessor of the current commit.


[subs="quotes"]
--------
$ *git checkout -b &lt;new-feature&gt;*
$ *git branch -D master*
$ *git branch master HEAD^^*
--------




[[sec.reset-usage]]
==== Using Reset
//   reset benutzen

////
Mit `reset` löschen Sie nicht beliebige Commits, sondern verschieben immer nur Referenzen.
Dadurch gehen die nicht mehr referenzierten Commits verloren, werden also quasi gelöscht (_unreachable_).
Sie können also mit `reset` nur die obersten Commits auf einem Branch löschen, nicht beliebige Commits "`irgendwo aus der Mitte`", da dies den Commit-Graphen zerstören würde.
(Für das etwas kompliziertere Löschen von Commits "`mittendrin`" siehe Rebase, Abschnitt 4.1, "Commits verschieben -- Rebase".)
////

With `reset` you do not delete any commits, but only move references.
As a result, the commits that are no longer referenced are lost, and are therefore deleted (_unreachable_).
So you can use `reset` to delete only the topmost commits on a branch, not arbitrary commits "`somewhere in the middle,`" as this would destroy the commit graph.
(For the somewhat more complicated deletion of commits "`in the middle,`" see _rebase_, <<sec.rebase>>).


////
Git speichert den ursprünglichen `HEAD` immer unter `ORIG_HEAD` ab.
Falls Sie also fälschlicherweise einen Reset durchgeführt haben, machen Sie diesen mit `git reset --hard ORIG_HEAD` rückgängig (auch wenn der Commit vermeintlich gelöscht wurde).
Das betrifft allerdings _nicht_ die verlorengegangenen Änderungen am Working Tree (die Sie noch nicht eingecheckt haben) -- diese werden unwiderruflich gelöscht.
////

Git always stores the original `HEAD` under `ORIG_HEAD`.
So if you have performed a reset by mistake, use `git reset --hard ORIG_HEAD` to undo it (even if the commit was supposedly deleted).
However, this _does not_ affect lost changes to the working tree (which you have not yet checked in) -- they are deleted irrevocably.


////
Das Resultat von oben (zwei Commits auf einen neuen Branch verschieben) erreichen Sie also alternativ auch so:
////

The result from above (moving two commits to a new branch) can also be achieved this way:



[subs="quotes"]
--------
$ *git reset --hard HEAD^^*
$ *git checkout -b &lt;new-feature&gt; ORIG_HEAD*
--------


////
Eine häufige Anwendung von `reset` ist, testweise Änderungen zu verwerfen.
Sie wollen einen Patch probieren?
Ein bisschen Debugging-Output einbauen?
Ein paar Konstanten ändern?
Gefällt das Ergebnis nicht, löscht ein `git reset --hard` alle Änderungen am Working Tree.
////

A common use of `reset` is to discard changes on a test basis.
You want to try a patch?
Add some debugging output?
Change a few constants?
If you don't like the result, a `git reset --hard` deletes all changes to the working tree.


////
Auch können Sie mit Hilfe von `reset` Ihre Versionsgeschichte "`schön machen`".
Wenn Sie beispielsweise ein paar Commits auf einem auf `master` aufbauenden Branch `<feature>` haben, die aber nicht  sinnvoll gegliedert (oder viel zu groß) sind, können Sie einen Branch `<reorder-feature>` erstellen und _alle_ Änderungen in neue Commits verpacken:
////

You can also use `reset` to "`make your version history nice.`"
For example, if you have a few commits on a branch `<feature>` based on `master`, but they are not well structured (or much too large), you can create a branch `<reorder-feature>` and pack all changes into new commits:


[subs="quotes"]
--------
$ *git checkout -b &lt;reorder-feature&gt; &lt;feature&gt;*
$ *git reset master*
$ *git add -p*
$ *git commit*
$ ...
--------


////
Das Kommando `git reset master` setzt Index und `HEAD` auf den Stand von `master`.
Ihre Änderungen im Working Tree bleiben aber erhalten, d.h. alle Änderungen, die den Branch `<feature>` von `master` unterscheiden, sind nun lediglich in den Dateien im Working Tree enthalten.
Jetzt können Sie die Änderungen _schrittweise_ per `git add -p` hinzufügen und in (mehrere) handliche Commits verpacken.[36]
////

The command `git reset master` sets index and `HEAD` to the state of `master`.
However, your changes in the working tree are preserved, i.e. all changes that distinguish the branch `<feature>` from `master` are now only contained in the files in the working tree.
Now you can add the changes _incrementally_ using `git add -p` and package them into (several) handy commits.{fn36}


////
Angenommen, Sie arbeiten an einer Änderung und wollen diese temporär einchecken (um später daran weiterzuarbeiten).
Dann können Sie folgende Kommandos verwenden:
////

Suppose you are working on a change and want to check it in temporarily (to continue working on it later).
You can then use the following commands:


// @TRANSLATE GIT LOG?
[subs="quotes"]
--------
$ *git commit -m 'feature (noch unfertig)'*
(später)
$ *git reset --soft HEAD^*
(weiterarbeiten)
--------


////
Das Kommando `git reset --soft HEAD^` setzt den `HEAD` einen Commit zurück, lässt allerdings den Index sowie den Working Tree unberührt.
Alle Änderungen aus Ihrem temporären Commit sind also nach wie vor im Index und Working Tree, aber der eigentliche Commit geht verloren.
Sie können nun weitere Änderungen machen und später einen neuen Commit erstellen.
Eine ähnliche Funktionalität stellt die Option `--amend` für `git commit` sowie auch das Kommando `git stash` (dt. "`verstauen`") bereit, das in Abschnitt 4.5, "Veränderungen auslagern -- git stash" erklärt wird.
////

The command `git reset --soft HEAD^` resets the `HEAD` one commit, but leaves the index and the working tree untouched.
So all changes from your temporary commit are still in the index and working tree, but the actual commit is lost.
You can now make further changes and create a new commit later.
Similar functionality is provided by the `--amend` option for `git commit`, as well as the `git stash` command, which is explained in <<sec.stash>>.



[[sec.merge]]
== Merging Branches
// Branches zusammenführen: Merges

////
Das Zusammenführen von Branches nennt man in Git _mergen_; der Commit, der zwei oder mehr Branches miteinander verbindet, heißt entsprechend _Merge-Commit_.
////

Merging branches is called _merging_ in Git; the commit that merges two or more branches together is called a _merge commit_.


////
Git stellt das Subkommando `merge` bereit, mit dem Sie einen Branch in einen anderen integrieren.
Das bedeutet, dass alle Änderungen, die Sie auf dem Branch getätigt haben, in den aktuellen einfließen.
////

Git provides the `merge` subcommand, which allows you to merge one branch into another.
This means that any changes you make to the branch will be reflected in the current one.


////
Beachten Sie, dass das Kommando den angegebenen Branch in den _aktuell ausgecheckten Branch_ (d.h. `HEAD`) integriert.
Das Kommando benötigt also nur ein Argument:
////

Note that the command integrates the specified branch into the _currently checked-out branch_ (i.e., `HEAD`).
The command therefore only needs one argument:


[subs="quotes"]
--------
$ *git merge &lt;branch-name&gt;*
--------


////
Wenn Sie wohlüberlegt mit Ihren Branches hantieren, dürfte es keine Probleme beim Mergen geben.
Wenn doch, dann stellen wir in diesem Abschnitt auch Strategien vor, wie Sie Merge-Konflikte lösen.
////

If you handle your branches carefully, there should be no problems with merging.
If there are, then this section also presents strategies for resolving merge conflicts.


////
Zunächst schauen wir uns einen Merge-Vorgang auf Objektebene an.
////

First, we will look at an object-level merge process.



[[sec.merge-detail]]
=== Two-Branches Merge
//  Zwei Branches verschmelzen

////
Die zwei Branches `topic` und `master`, die Sie mergen wollen, referenzieren jeweils den aktuellsten Commit in einer Kette von Commits (F und D), und diese beiden Commits wiederum einen Tree (entspricht dem obersten Verzeichnis Ihres Projekts).
////

The two branches, `topic` and `master`, that you want to merge, each reference the most recent commit in a chain of commits (F and D), and these two commits in turn reference a tree (corresponding to the top-level directory of your project).


////
Zunächst berechnet Git eine sogenannte _Merge-Basis_, also einen Commit, den beide zu verschmelzenden Commits als gemeinsamen Vorfahren haben.
In der Regel gibt es mehrere solcher Basen -- im untenstehenden Diagramm A und B -- , dann wird die neueste (die also die anderen Basen als Vorfahren hat) verwendet.[37]
Anschaulich gesprochen, ist dies für einfache Fälle der Commit, an dem die Branches divergiert haben (also B).
////

First, Git calculates a so-called _merge base_, that is, a commit that both of the commits to be merged have as common ancestors.
Usually there are several such bases -- in the diagram below, A and B -- and then the most recent one (which has the other bases as ancestors) is used.{fn37}
In simple terms, this is the commit where the branches diverged (i.e., B).


////
Wenn Sie nun zwei Commits miteinander verschmelzen wollen (D und F zu M), dann müssen also die von den Commits referenzierten Trees verschmolzen werden.
////

Now, if you want to merge two commits (D and F to M), then the trees referenced by the commits must be merged.



// .Merge-Basis und Merge-Commit
.Merge base and merge commit
image::merge-base-commit.svg[id="fig.merge-base-commit",scaledwidth="80%",width="80%",align="center"]



////
Dafür geht Git so vor:[38] Wenn ein Tree-Eintrag (ein weiterer Tree oder ein Blob) in beiden Commits gleich ist, wird genau dieser Tree-Eintrag auch im Merge-Commit übernommen.
Das passiert in zwei Fällen:
////

Git does this as follows:{fn38} If a tree entry (another tree or a blob) is the same in both commits, then that very tree entry will be taken over in the merge commit.
This happens in two cases:

////
. Eine Datei wurde von keinem der beiden Commits geändert, oder ein Unterverzeichnis enthält keine geänderte Datei: Im ersten Fall ist die Blob-SHA-1-Summe dieser Datei in beiden Commits gleich, im zweiten Fall wird von beiden Commits das gleiche Tree-Objekt referenziert.
Der referenzierte Blob bzw. Tree ist also derselbe wie der in der Merge-Basis referenzierte.

. Eine Datei wurde _auf beiden Seiten_ und _äquivalent_ geändert (gleiche Blobs).
Das passiert zum Beispiel, wenn aus dem einen Branch alle Änderungen an einer Datei per `git cherry-pick` (siehe Abschnitt 3.5, "Einzelne Commits übernehmen: Cherry-Pick") übernommen wurden.
Der referenzierte Blob ist dann _nicht_ derselbe wie in der Merge-Basis.
////

. A file has not been changed by either commit, or a subdirectory does not contain a changed file: In the first case, the blob SHA 1 sum of this file is the same in both commits.
In the second case, the same tree object is referenced by both commits.
The referenced blob or tree is therefore the same as the one referenced in the merge base.

. A file was changed _on both sides_ and _equivalently_ (same blobs).
This happens, for example, if all changes to a file were copied from one branch using `git cherry-pick` (see <<sec.cherry-pick>>).
The referenced blob is then _not_ the same as in the merge base.



////
Wenn ein Tree-Eintrag in einem der Commits verschwindet, im anderen aber noch vorhanden ist und 'der gleiche ist wie in der Merge-Basis', dann wird er nicht übernommen.
Das entspricht dem Löschen einer Datei oder eines Verzeichnisses, wenn an der Datei auf der anderen Seite keine Änderungen vorgenommen wurden.
Analog, wenn ein Commit einen neuen Tree-Eintrag mitbringt, wird dieser in den Merge-Tree übernommen.
////

If a tree entry disappears in one of the commits, but is still present in the other, and is the same as in the merge base, then it is not taken over.
This is equivalent to deleting a file or directory if no changes have been made to the file on the other side.
Similarly, if a commit brings a new tree entry, it is copied to the merge tree.


////
Was passiert nun, wenn eine Datei aus den Commits verschiedene Blobs aufweist, die Datei also zumindest auf der einen Seite verändert wurde?
Im Falle, dass einer der Blobs der gleiche ist wie in der Merge-Basis, wurden nur auf einer Seite Änderungen an der Datei durchgeführt -- Git kann diese Änderungen also einfach übernehmen.
////

Now what happens if a file from the commits has different blobs, that is, the file has been changed at least on one side?
In the event that one of the blobs is the same as in the merge base, only one side of the file has been changed, so Git can simply adopt those changes.


////
Wenn sich aber _beide_ Blobs von der Merge-Basis unterscheiden, könnte es möglicherweise zu Problemen kommen.
Zunächst versucht Git, die Änderungen beider Seiten zu übernehmen.
////

However, if _both_ blobs are different from the merge base, you might run into problems.
First, Git tries to apply the changes on both sides.


////
Dafür wird in der Regel ein _3-Wege-Merge_-Algorithmus verwendet.
Im Gegensatz zum klassischen 2-Wege-Merge-Algorithmus, der eingesetzt wird, wenn Sie zwei unterschiedliche Versionen A und B einer Datei haben und diese zusammenführen wollen, bezieht dieser 3-Wege-Algorithmus eine dritte Version C der Datei ein, extrahiert aus obiger Merge-Basis.
Der Algorithmus kann daher, weil ein gemeinsamer Vorgänger der Datei bekannt ist, in vielen Fällen besser (d.h. nicht nur anhand der Zeilennummer bzw. des Kontextes) entscheiden, wie Änderungen zusammengeführt werden.
In der Praxis werden so viele trivial lösbare Merge-Konflikte schon automatisch ohne Zutun des Nutzers gelöst.
////

A _3-way merge_ algorithm is usually employed for this purpose.
Unlike the classic 2-way merge algorithm, which is used when you have two different versions A and B of a file and want to merge them, this 3-way algorithm involves a third version C of the file, extracted from the above merge base.
Therefore, because a common ancestor of the file is known, the algorithm can in many cases better (that is, not only based on the line number or context) decide how to merge changes.
In practice, so many trivial merge conflicts are already solved automatically without user intervention.


////
Es gibt allerdings Konflikte, die kein noch so guter Merge-Algorithmus zusammenführen kann.
Das passiert zum Beispiel, wenn in Version A der Datei der Kontext direkt vor einer Änderung in Datei B geändert wurde, oder, schlimmer noch, Version A und B und C unterschiedliche Versionen einer Zeile aufweisen.
////

However, there are conflicts that no merge algorithm, no matter how good, can merge.
This happens, for example, if the context in version A of the file was changed just before a change in file B, or, worse still, version A and B and C have different versions of a line.


////
Einen solchen Fall nennt man _Merge-Konflikt_.
Git führt alle Dateien so gut es geht zusammen und präsentiert dem Nutzer dann die in Konflikt stehenden Änderungen, damit dieser sie manuell verschmelzen (und damit den Konflikt lösen) kann (siehe dafür Abschnitt 3.4, "Merge-Konflikte lösen").

////
Such a case is called a _merge conflict_.
Git merges all the files as best it can, and then presents the conflicting changes to the user so they can manually merge them (and thus resolve the conflict) (see <<sec.merge-conflicts>>).


////
Zwar ist es grundsätzlich möglich, mit einem speziell auf die jeweilige Programmiersprache ausgerichteten Algorithmus eine syntaktisch korrekte Auflösung zu erzeugen -- allerdings kann ein Algorithmus nicht hinter die _Semantik_ des Codes schauen, also die Bedeutung des Codes erfassen.
Daher wäre eine so generierte Lösung in der Regel nicht sinnvoll.
////

Although it is basically possible to generate a syntactically correct resolution with an algorithm that is specially designed for the respective programming language, an algorithm cannot look beyond the _semantics_ of the code, i.e., cannot grasp the meaning of the code.
Therefore, a solution generated in this way would usually not make sense.





[[sec.merge-ff]]
=== Fast Forward Merges: Fast Forwarding One Branch
//  Fast-Forward-Merges: Einen Branch vorspulen

////
Das Kommando `git merge` erzeugt nicht immer einen Merge-Commit.
Ein trivialer Fall, der aber häufig vorkommt, ist der sogenannte _Fast-Forward-Merge_, also ein Vorspulen des Branches.
////

The `git merge` command does not always create a merge commit.
A trivial case, but one that does occur frequently, is the so-called _fast-forward merge_, i.e. a fast forward merge of the branch.


////
Ein Fast-Forward-Merge tritt dann auf, wenn ein Branch, z.B. `topic`, Kind eines zweiten Branches, `master`, ist:
////

A fast forward merge occurs when a branch, for example `topic`, is the child of a second branch, `master`:


// .Vor dem _Fast-Forward_-Merge
.Before the _fast forward_ merge
image::ff-before.svg[id="fig.merge-ff-before",scaledwidth="70%",width="70%",align="center"]


////
Ein einfaches `git merge topic` im Branch `master` führt nun dazu, dass `master` einfach weitergerückt wird -- es wird kein Merge-Commit erzeugt.
////

A simple `git merge topic` in Branch `master` now causes `master` to simply be moved forward -- no merge commit is created.


// .Nach dem _Fast-Forward_-Merge – es wurde kein Merge-Commit erzeugt
.After the _fast forward_ merge -- no merge commit was created
image::ff-after.svg[id="fig.merge-ff-after",scaledwidth="70%",width="70%",align="center"]


////
Ein solches Verhalten geht natürlich nur dann, wenn die beiden Branches nicht divergiert haben, wenn also die Merge-Basis beider Branches einer der beiden Branches selbst ist, in diesem Falle `master`.
////

Of course, such a behavior only works if the two branches have not diverged, i.e. if the merge base of both branches is one of the two branches itself, in this case `master`.


////
Dieses Verhalten ist häufig wünschenswert:
////

This behavior is often desirable:


////
. Sie wollen Upstream-Änderungen, also Änderungen aus einem anderen Git-Repository, integrieren.
Dafür verwenden Sie typischerweise ein Kommando wie `git merge origin/master`.
Auch ein `git pull` wird einen Merge ausführen.
Wie Sie Änderungen zwischen Git-Repositories austauschen, behandeln wir in Kapitel 5, Verteiltes Git.

. Sie wollen einen experimentellen Branch einpflegen.
Da Sie besonders einfach und schnell Branches in Git erstellen, empfiehlt es sich, für jedes Feature einen neuen Branch anzufangen.
Wenn Sie nun etwas Experimentelles auf einem Branch ausprobiert haben und dies integrieren wollen, ohne dass man einen "`Zeitpunkt der Integration`"" erkennen kann, dann geschieht das per _Fast-Forward_.
////


. You want to integrate upstream changes, that is, changes from another Git repository.
You typically use a command like `git merge origin/master` to do this.
A `git pull` will also perform a merge.
To learn how to merge changes between git repositories, see <<ch.distributed-git>>.

. You want to add an experimental branch.
Because it's quick and easy to create branches in Git, it's a good idea to start a new branch for each feature.
If you've tried something experimental on a branch and want to integrate it without being able to tell when it's "`time to integrate`", you can do so by _fast-forwarding_.


[TIP]
===============
////
Mit den Optionen `--ff-only` und `--no-ff` können Sie das Merge-Verhalten anpassen.
Wenn Sie die erste Option verwenden und die Branches können nicht per Fast-Forward zusammengeführt werden, wird Git mit einer Fehlermeldung abbrechen.
Die zweite Option zwingt Git dazu, einen Merge-Commit zu erstellen, obwohl ein Fast-Forward möglich gewesen wäre.
////

With the options `--ff-only` and `--no-ff` you can adjust the merge behavior.
If you use the first option and the branches cannot be merged using fast-forward, Git will abort with an error message.
The second option forces Git to create a merge commit even though fast forward would have been possible.
===============


////
Es gibt verschiedene Meinungen, ob man Änderungen immer per Fast-Forward integrieren sollte oder lieber einen Merge-Commit erstellt, obwohl dies nicht unbedingt nötig ist.
Die Resultate sind in beiden Fällen gleich: Die Änderungen aus einem Branch werden in einen anderen integriert.
////

There are different opinions on whether changes should always be integrated via fast-forward or whether it is better to create a merge commit, although this is not absolutely necessary.
The results are the same in both cases: Changes from one branch are integrated into another.


////
Wenn Sie allerdings einen Merge-Commit erstellen, dann wird die _Integration_ eines Features deutlich.
Betrachten Sie die beiden folgenden Ausschnitte aus der Versionsgeschichte eines Projekts:
////

However, when you create a Merge-Commit, the _integration_ of a feature becomes clear.
Consider the following two excerpts from the version history of a project:



// @TODO: TRANSLATE IMAGE ID

// .Integration eines Features mit und ohne Fast-Forward
.Integration of a feature with and without fast forward
image::ff-no-ff-vergleich.png[id="fig.ff-vergleich",scaledwidth="80%",width="80%",align="center"]



////
Im oberen Fall können Sie nicht ohne weiteres erkennen, welche Commits ehemals im Branch `sha1-caching` entwickelt wurden, also mit einem spezifischen Feature der Software zu tun haben.
////

In the above case, you cannot easily see which commits were previously developed in branch `sha1-caching`, that is, they have to do with a specific feature of the software.


////
In der unteren Version jedoch können Sie auf den ersten Blick erkennen, dass es genau vier Commits auf diesem Branch gab und er dann integriert wurde.
Da parallel nichts entwickelt wurde, wäre der Merge-Commit prinzipiell unnötig, allerdings macht er die Integration des Features deutlich.
////

In the lower version, however, you can see at first glance that there were exactly four commits on that branch, and that it was then integrated.
Since nothing was developed in parallel, the merge commit would in principle be unnecessary, but it does make the integration of the feature clear.


[TIP]
===============
////
Es bietet sich daher an, statt auf die Magie von `git merge` zu vertrauen, zwei Aliase (siehe auch Abschnitt 1.3.1, "Git Aliase") zu kreieren, die einen Fast-Forward-Merge forcieren oder verbieten:
////

So instead of relying on the magic of `git merge`, it makes sense to create two aliases (see <<sec.git-alias>>) that force or forbid fast forward merge:

--------
nfm = merge --no-ff     # no-ff-merge
ffm = merge --ff-only   #    ff-merge
--------
===============



////
Ein expliziter Merge-Commit ist auch hilfreich, weil Sie diesen mit einem einzigen Kommando rückgängig machen können.
Dies ist beispielsweise dann sinnvoll, wenn Sie einen Branch integriert haben, der aber Fehler aufweist: Wenn der Code in Produktion läuft, ist es häufig wünschenswert, die gesamte Änderung vorerst wieder auszubauen, bis der Fehler korrigiert ist.
Verwenden Sie dafür:
////

An explicit merge commit is also helpful because you can undo it with a single command.
This is useful, for example, if you have integrated a branch but it has bugs: If the code is running in production, it is often desirable to merge the entire change back in until the bug is fixed.
Use for this:


------
git revert -m 1 <merge-commit>
------


////
Git produziert dann einen neuen Commit, der alle Änderungen rückgängig macht, die durch den Merge verursacht wurden.
Die Option `-m 1` gibt hier an, welche "`Seite`" des Merges als _Mainline_, also stabile Entwicklungslinie, gelten soll: deren Änderungen bleiben bestehen.
Im obigen Beispiel würde `-m 1` dazu führen, dass die Änderungen der vier Commits aus dem Branch `sha1-caching`, also dem zweiten Strang des Merges, rückgängig gemacht würden.
////

Git then produces a new commit that reverses any changes made by the merge.
The `-m 1` option here specifies which "`side`" of the merge should be considered the _mainline_, or stable line of development: its changes are preserved.
In the above example, `-m 1` would cause the changes made by the four commits from branch `sha1-caching`, the second string of the merge, to be undone.




[[sec.merge-strategies]]
=== Merging Strategies
//  Merge-Strategien

////
Git kennt fünf verschiedene Merge-Strategien, deren Verhalten teilweise noch durch Strategie-Optionen weiter angepasst werden kann.
Die Strategie bestimmen Sie per `-s`, so dass ein Merge-Aufruf  wie folgt lautet:
////

Git has five different merge strategies, some of which can be further adjusted by strategy options.
You determine the strategy by `-s`, so a merge call is as follows:


--------
git merge -s <strategy> <branch>
--------


////
Manche dieser Strategien können nur zwei Branches zusammenführen, andere eine beliebige Anzahl.
////

Some of these strategies can only merge two branches, others any number.


////
`resolve` ::
Die `resolve`-Strategie kann zwei Branches mit Hilfe einer 3-Wege-Merge-Technik zusammenführen.
Als Merge-Basis wird dafür die neueste (beste) aller möglichen Basen verwendet.
Diese Strategie ist schnell und erzeugt generell gute Ergebnisse.
////

`resolve` ::
The `resolve` strategy can merge two branches using a 3-way merge technique.
The newest (best) of all possible bases is used as the merge base.
This strategy is fast and generally produces good results.


////
`recursive` ::
Dies ist die Standard-Strategie, die Git einsetzt, um zwei Branches zu verschmelzen.
Auch hier wird ein 3-Wege-Merge-Algorithmus eingesetzt.
Allerdings geht diese Strategie geschickter vor als `resolve`: Existieren mehrere Merge-Basen, die allesamt "`gleiche Berechtigung`"haben,[39] dann führt Git zunächst diese Basen zusammen, um das Ergebnis dann als Merge-Basis für den 3-Wege-Merge-Algorithmus zu verwenden.
Neben der Tatsache, dass dadurch auch Merges mit Dateiumbenennungen besser verarbeitet werden können, hat ein Testlauf auf der Versionsgeschichte des Linux-Kernels gezeigt, dass durch diese Strategien weniger Merge-Konflikte auftreten als mit der `resolve`-Strategie.
Die Strategie kann durch diverse Optionen angepasst werden (s.u.).
////

`recursive` ::
This is the standard strategy that Git uses to merge two branches.
A 3-way merge algorithm is also used here.
However, this strategy is more clever than `resolve`: If several merge bases exist, all of which have "`equal rights,`"{fn39} then Git first merges these bases together, and then uses the result as the merge base for the 3-way merge algorithm.
In addition to the fact that merges with file renames can be processed more easily as a result, a test run on the version history of the Linux kernel has shown that these strategies result in fewer merge conflicts than the `resolve` strategy.
The strategy can be adapted by various options (see below).


////
`octopus` ::
Standard-Strategie, wenn drei oder mehr Branches zusammengeführt werden.
Die Octopus-Strategie kann im Gegensatz zu den beiden vorher genannten Strategien nur dann Merges durchführen, wenn kein Fehler auftritt, also keine manuelle Konfliktauflösung notwendig ist.
Die Strategie ist besonders dafür gedacht, viele Topic-Branches, von denen bekannt ist, dass sie sich mit der Mainline (Haupt-Entwicklungsstrang) vertragen, zu integrieren.
////

`octopus` ::
Standard strategy when three or more branches are merged.
In contrast to the two strategies mentioned above, the octopus strategy can only perform merges if no error occurs, i.e. if no manual conflict resolution is necessary.
The strategy is especially designed to integrate many topic branches that are known to be compatible with the mainline (main development strand).


////
`ours` ::
Kann beliebig viele Branches verschmelzen, nutzt aber keinen Merge-Algorithmus.
Stattdessen werden immer die Blobs bzw. Trees des aktuellen Branch (d.h. von dem Branch, von dem aus Sie `git merge` eingegeben haben) übernommen.
Die Strategie wird vor allem dann verwendet, wenn Sie alte Entwicklungen mit dem aktuellen Stand der Dinge überschreiben wollen.
////

`ours` ::
Can merge any number of branches, but does not use a merge algorithm.
Instead, the blobs or trees of the current branch (that is, the branch from which you entered `git merge`) are always used.
This strategy is mainly used when you want to overwrite old developments with the current state of affairs.


////
`subtree` ::
Funktioniert wie `recursive`, allerdings vergleicht die Strategie die Trees nicht "`auf gleicher Augenhöhe`", sondern bemüht sich, den Tree der einen Seite als Subtree der anderen Seite zu finden und erst dann zu verschmelzen.
Diese Strategie ist zum Beispiel dann sinnvoll, wenn Sie das Unterverzeichnis `Documentation/` Ihres Projekts in einem separaten Repository verwalten.
Dann können Sie die Änderungen aus diesem Repository in das Haupt-Repository übernehmen, indem Sie über  `git pull -s subtree <documentation-repo>` die `subtree`-Strategie bemühen, die die Inhalte von `<documentation-repo>` als Unterverzeichnis des Haupt-Repositorys erkennt und den Merge-Vorgang nur auf das entsprechende Unterverzeichnis anwendet.
Dieses Thema wird eingehender in Abschnitt 5.11, "Unterprojekte verwalten" behandelt.
////

`subtree` ::
Works like `recursive`, but the strategy does not compare the trees "`on equal footing,`" but tries to find the tree of one side as a subtree of the other side and only then merge them.
This strategy is useful, for example, if you manage the `Documentation/` subdirectory of your project in a separate repository.
Then you can merge the changes from that repository into the master repository by using `git pull -s subtree <documentation-repo>` to apply the `subtree` strategy, which recognizes the contents of `<documentation-repo>` as a subdirectory of the master repository and applies the merge process only to that subdirectory.
This topic is discussed in more detail in <<sec.subprojects>>.





[[sec.recursive-options]]
=== Options for the Recursive Strategy
//  Optionen für die recursive-Strategie

////
Die Default-Strategie `recursive` kennt mehrere Optionen, die das Verhalten besonders bezüglich der Konfliktlösung anpassen.
Sie bestimmen sie über die Option `-X`; die Syntax lautet also:
////

The default strategy `recursive` knows several options that adjust the behavior especially with regard to conflict resolution.
You specify them with the option `-X`; the syntax is:


--------
git merge -s recursive -X <option> <branch>
--------


////
Sofern Sie nur zwei Branches mergen, müssen Sie die `recursive`-Strategie nicht explizit per `-s recursive` angeben.
////

If you only merge two branches, you do not need to explicitly specify the `recursive` strategy by `-s recursive`.


////
Da die Strategie nur zwei Branches zusammenführen kann, ist es möglich, von _unserer_ (engl. _our_) und _deren_ (engl. _theirs_) Version zu sprechen: _unsere_ Version ist dabei der ausgecheckte Branch beim Merge-Vorgang, während _deren_ Version den Branch, den Sie integrieren wollen, referenziert.
////

Since the strategy can only merge two branches, it is possible to speak of _our_ version and _theirs_: _our_ version is the checked-out branch in the merge process, while _their_ version references the branch you want to integrate.


////
`ours` ::
Wenn ein Merge-Konflikt auftritt, der normalerweise manuell gelöst werden müsste, wird stattdessen _unsere_ Version verwendet.
Die Strategie-_Option_ unterscheidet sich allerdings von der _Strategie_ `ours`, denn dort werden jegliche Änderungen der Gegenseite(n) ignoriert.
Die `ours`-Option hingegen übernimmt alle Änderungen unserer sowie der Gegenseite und gibt nur im Konfliktfall und nur an den Konfliktstellen _unserer_ Seite Vorrang.
////

`ours` ::
If a merge conflict occurs that would normally need to be resolved manually, _our_ version is used instead.
The strategy _option_ is different from `ours`, however, because it ignores any changes made by the other side(s).
The `ours` option, on the other hand, takes all changes made by our side and the other side, and only gives priority in the event of a conflict and only at the points of conflict on _our_ side.


////
`theirs` ::
Wie `ours`, nur dass genau gegenteilig vorgegangen wird: bei Konflikten wird _deren_ Version bevorzugt.
////

`theirs` ::
Like `ours`, except that the opposite is true: in case of conflicts, _their_ version is preferred.


////
`ignore-space-change`, `ignore-all-space`, `ignore-space-at-eol` ::
Da Whitespace in den meisten Sprachen keine syntaktische Rolle spielt, können Sie mit diesen Optionen Git anweisen, im Falle eines Merge-Konfliktes zu probieren, ob dieser automatisch lösbar ist, wenn Whitespace keine Rolle spielt.
Ein häufiger Anwendungsfall ist, dass ein Editor oder eine IDE Quellcode automatisch umformatiert hat.
+
Die Option `ignore-space-at-eol` ignoriert Whitespace am Ende der Zeile, was insbesondere dann hilfreich ist, wenn beide Seiten verschiedene Zeilenende-Konventionen (LF/CRLF) verwenden.
Geben Sie `ignore-space-change` an, wird _außerdem_ Whitespace als reiner Trenner betrachtet: Für den Vergleich einer Zeile ist also unwesentlich, wie viele Leerzeichen oder Tabs an einer Stelle stehen -- eingerückte Zeilen bleiben eingerückt, und getrennte Wörter bleiben getrennt.
Die Option `ignore-all-space` ignoriert jeglichen Whitespace.
+
Generell geht die Strategie so vor: Falls _deren_ Version nur durch die angegebene Option abgedeckte Whitespace-Änderungen hineinbringt, werden diese ignoriert und _unsere_ Version verwendet; bringt sie weitere Änderungen mit, und _unsere_ Version hat nur Whitespace-Änderungen, so wird _deren_ Version verwendet.
Wenn aber auf beiden Seiten nicht nur Whitespace geändert wurde, so gibt es weiterhin einen Merge-Konflikt.
+
Generell empfiehlt es sich nach einem Merge, den Sie nur mit Hilfe einer dieser Optionen lösen konnten, die entsprechenden Dateien noch einmal zu normalisieren, also die Zeilenenden und Einrückungen einheitlich zu machen.
////

`ignore-space-change`, `ignore-all-space`, `ignore-space-at-eol` ::
Since whitespace does not play a syntactic role in most languages, these options allow you to tell Git to try to resolve a merge conflict automatically if whitespace is not important.
A common use case is when an editor or IDE has automatically reformatted source code.
+
The option `ignore-space-at-eol` ignores whitespace at the end of the line, which is especially helpful if both sides use different line-end conventions (LF/CRLF).
If you specify `ignore-space-change`, whitespace is also treated as a pure separator: Thus, when comparing a line, it is irrelevant how many spaces or tabs are in one place -- indented lines remain indented, and separated words remain separated.
The option `ignore-all-space` ignores any whitespace.
+
This is the general strategy: If _their_ version brings in only whitespace changes covered by the specified option, they are ignored and _our_ version is used; if they bring in further changes and _our_ version has only whitespace changes, _their_ version is used.
However, if both sides have not only whitespace changes, there is still a merge conflict.
+
In general, after a merge that you could only solve by using one of these options, it is recommended to normalize the corresponding files again, i.e. to make the line endings and indentations uniform.


////
`subtree=<tree>` ::
Ähnlich wie die `subtree`-_Strategie_, allerdings wird hier ein expliziter Pfad angegeben.
Analog zum obigen Beispiel würden Sie
+
------------
git pull -Xsubtree=Documentation <documentation-repo>
------------
+
verwenden.
////

`subtree=<tree>` ::
Similar to the `subtree` _strategy_, but an explicit path is specified here.
Similar to the above example, you would use:
+
------------
git pull -Xsubtree=Documentation <documentation-repo>
------------



[[sec.merge-conflicts]]
== Resolving Merge Conflicts
// Merge-Konflikte lösen

////
Wie bereits beschrieben, sind manche Konflikte nicht durch Algorithmen aufzulösen -- hier ist manuelle Nachbesserung nötig.
Gute Team-Koordination sowie schnelle Integrationszyklen können größere Merge-Konflikte minimieren.
Aber gerade in der frühen Entwicklung, wenn möglicherweise die Interna einer Software geändert werden, statt neue Features hinzuzufügen, kann es zu Konflikten kommen.
////

As already described, some conflicts cannot be resolved by algorithms -- in this case manual rework is necessary.
Good team coordination and fast integration cycles can minimize major merge conflicts.
But especially in early development, when possibly the internals of a software are changed instead of adding new features, conflicts can occur.


////
Wenn Sie in einem größeren Team arbeiten, dann ist in der Regel der Entwickler, der maßgeblich am konfliktbehafteten Code gearbeitet hat, dafür verantwortlich, eine Lösung zu finden.
Eine solche Konfliktlösung ist aber meist nicht schwierig, wenn der Entwickler einen guten Überblick über die Software allgemein und insbesondere über sein Stück Code und dessen Interaktion mit anderen Teilen hat.
////

If you are working in a larger team, the developer who has done most of the work on the conflicted code is usually responsible for finding a solution.
However, such a conflict resolution is usually not difficult if the developer has a good overview of the software in general and of his piece of code and its interaction with other parts in particular.


////
Wir werden die Lösung eines Merge-Konflikts anhand eines einfachen Beispiels in C durchgehen.
Betrachten Sie die folgende Datei `output.c`:
////

We will go through the solution of a merge conflict using a simple example in C.
Take a look at the following `output.c` file:



[source,c]
----------------------------------
int i;

for(i = 0; i < nr_of_lines(); i++)
    output_line(i);

print_stats();
----------------------------------



////
Das Stück Code geht alle Zeilen einer Ausgabe durch und gibt diese nacheinander aus.
Zuletzt liefert es eine kleine Statistik.
////

The piece of code goes through all lines of an output and outputs them one after the other.
Finally it returns a small statistic.


////
Nun ändern zwei Entwickler etwas an diesem Code.
Der erste, Axel, schreibt eine Funktion, die die Zeilen umbricht, bevor sie ausgegeben werden, und ersetzt im obigen Codestück `output_line` durch seine verbesserte Version `output_wrapped_line`:
////

Now two developers change something in this code.
The first one, Axel, writes a function that wraps the lines before they are output and replaces `output_line` in the above piece of code with his improved version `output_wrapped_line`:



[source,c]
----------------------------------
int i;
int tw = 72;

for(i = 0; i < nr_of_lines(); i++)
    output_wrapped_line(i, tw);

print_stats();
----------------------------------


////
Die zweite Entwicklerin, Beatrice, modifiziert den Code, damit ihre neu eingeführte Konfigurationseinstellung `max_output_lines` honoriert wird, und nicht zu viele Zeilen ausgegeben werden:
////

The second developer, Beatrice, modifies the code so that her newly introduced configuration setting `max_output_lines` is honored and not too many lines are output:


[source,c]
------------------------------------------
int i;

for(i = 0; i < nr_of_lines(); i++) {
    if(i > config_get("max_output_lines"))
        break;
    output_line(i);
}

print_stats();
------------------------------------------


////
Beatrice verwendet also die "`veraltete`" Version `output_line`, und Axel hat noch nicht das Konstrukt, das die Konfigurationseinstellung überprüft.
////

So Beatrice uses the "`obsolete`" version `output_line`, and Axel does not yet have the construct that checks the configuration setting.

////
Nun versucht Beatrice, ihre Änderungen auf Branch B in den Branch `master` zu übernehmen, auf dem Axel seine Änderungen schon integriert hat:
////

Now Beatrice tries to transfer her changes on Branch B to the branch `master`, where Axel has already integrated his changes:


[subs="quotes"]
--------
$ *git checkout master*
$ *git merge B*
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
Automatic merge failed; fix conflicts and then commit the result.
--------


////
In der Datei `output.c` platziert Git nun sogenannte _Konflikt-Marker_, unten halbfett hervorgehoben, die anzeigen, wo sich Änderungen überschneiden.
Es gibt zwei Seiten: Zum einen `HEAD`, d.h. der Branch, in den Beatrice die Änderungen übernehmen will -- in diesem Falle `master`.
Die andere Seite ist der zu integrierende Branch -- B.
Die beiden Seiten werden durch eine Reihe von Gleichheitszeichen voneinander getrennt:
////

In the `output.c` file, Git now places _conflict markers_, highlighted in semi-bold at the bottom to indicate where changes overlap.
There are two pages: The first is `HEAD`, i.e. the branch to which Beatrice wants to apply the changes -- in this case `master`.
The other side is the branch to be integrated -- B.
The two sides are separated by a series of equal signs:


[subs="quotes"]
--------
int i;
int tw = 72;

*&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD*
for(i = 0; i &lt; nr_of_lines(); i++)
    output_wrapped_line(i, tw);
*=======*
for(i = 0; i &lt; nr_of_lines(); i++) {
    if(i &gt; config_get("max_output_lines"))
        break;
    output_line(i);
}
*&gt;&gt;&gt;&gt;&gt;&gt;&gt;*

print_stats();
--------


////
Zu beachten ist hier, dass nur die wirklich _konfliktbehafteten_ Änderungen von Beatrice beanstandet werden.
Axels Definition von `tw` weiter oben wird, obwohl bei Beatrice noch nicht vorhanden, anstandslos übernommen.
////

It should be noted here that only the actual _conflicting changes_ are objected to by Beatrice.
Axel's definition of `tw` above is accepted without any problems, although it is not yet available in Beatrice.

////
Beatrice muss nun den Konflikt lösen.
Das passiert, indem sie zunächst die Datei direkt editiert, den Code so abwandelt, wie er sein soll, und anschließend die Konflikt-Marker entfernt.
Wenn Axel in seiner Commit-Nachricht entsprechend ausführlich dokumentiert hat[40] wie seine neue Funktion arbeitet, sollte das schnell gehen:
////

Beatrice must now resolve the conflict.
This is done by first editing the file directly, modifying the code as it should be, and then removing the conflict markers.
If Axel has documented in detail in his commit message{fn40} how his new function works, this should be done quickly:


[source,c]
------------------------------------------
int i;
int tw = 72;

for(i = 0; i < nr_of_lines(); i++) {
    if(i > config_get("max_output_lines"))
        break;
    output_wrapped_line(i, tw);
}

print_stats();
------------------------------------------


////
Anschließend muss Beatrice die Änderungen per `git add` hinzufügen.
Sofern keine Konflikt-Marker mehr in der Datei verbleiben, ist dies für Git das Zeichen, dass ein Konflikt gelöst wurde.
Schließlich muss das Resultat noch eingecheckt werden:
////

Beatrice must then add the changes using `git add`.
If no conflict markers remain in the file, Git will indicate that a conflict has been resolved.
Finally, the result has to be checked in:


[subs="quotes"]
--------
$ *git add output.c*
$ *git commit*
--------


////
In der Commit-Nachricht sollte unbedingt stehen, wie dieser Konflikt gelöst wurde.
Auch mögliche Seiteneffekte auf andere Teile des Programms sollten nicht unerwähnt bleiben.
////

The commit message should definitely state how this conflict was resolved.
It should also mention possible side effects on other parts of the program.


////
Normalerweise sind Merge-Commits "`leer`", d.h. in `git show` erscheint keine Diff-Ausgabe (weil die Änderungen ja von anderen Commits verursacht wurden).
Im Falle eines Merge-Commits, der einen Konflikt löst, ist dies aber anders:
////

Normally, merge commits are "`empty`", i.e., there is no diff output in `git show` (because the changes were caused by other commits).
This is different in the case of a merge commit that resolves a conflict:


[subs="quotes"]
--------
$ *git show*
commit 6e6c55810c884356402c078f30e45a997047058e
Merge: f894659 256329f
Author: Beatrice &lt;beatrice@gitbu.ch&gt;
Date:   Mon Feb 28 05:59:36 2011 +0100

    Merge branch 'B'

    * B:
      honor max_output_lines config option

    Conflicts:
        output.c

diff --cc output.c
index a2bd8ed,f4c8bec..e39e39d
--- a/output.c
+++ b/output.c
@@@ -1,7 -1,9 +1,10 @@@
  int i;
 **+**int tw = 72;

*-* for(i = 0; i < nr_of_lines(); i++)
*+* for(i = 0; i < nr_of_lines(); i++) {
*+*     if(i > config_get("max_output_lines"))
*+*         break;
 *-*    output_line(i);
 *+*    output_wrapped_line(i, tw);
*+* }

  print_stats();
--------




////
Diese _kombinierte_ Diff-Ausgabe unterscheidet sich vom üblichen Unidiff-Format: Es gibt nicht nur _eine_ Spalte mit den Markern für hinzugefügt (`+`), entfernt (`-`) und Kontext bzw. ungeändert (&#x2423;), sondern zwei.
Git vergleicht also das Resultat mit _beiden_ Vorfahren.
Die in der zweiten Spalte geänderten Zeilen entsprechen genau denen des Commits von Axel; die (halbfett markierten) Änderungen in der ersten Spalte sind der Commit von Beatrice inklusive Konfliktlösung.
////

This _combined_ diff output differs from the usual unidiff format: There is not only one column with the markers for added (`+`), removed (`-`) and context or unchanged (`␣`), but two.
So Git compares the result with _both_ ancestors.
The lines changed in the second column are exactly the same as Axel's commit; the (semi-bold) changes in the first column are Beatrice's commit including conflict resolution.


//\label{sec:merge-conflicts-detailed}

////
Der Standard-Weg, wie oben gesehen, ist der folgende:
////

The default way, as seen above, is the following:


////
. konfliktbehaftete Datei öffnen
. Konflikt lösen, Marker entfernen
. Datei per `git add` als "`gelöst`" markieren
. Schritt eins bis drei für alle Dateien wiederholen, in denen Konflikte auftraten
. Konfliktlösungen per `git commit` einchecken
////

. Open conflicting file
. Resolve conflict, remove markers
. Mark file as "`resolved`" via `git add`
. Repeat steps one to three for all files where conflicts occurred
. Check in conflict solutions via `git commit`



////
Wenn Sie ad hoc nicht wissen, wie der Konflikt zu lösen ist (und zum Beispiel den ursprünglichen Entwickler damit beauftragen wollen, eine konfliktfreie Version des Codes zu produzieren), können Sie per `git merge --abort` den Merge-Vorgang abbrechen -- also den Zustand Ihres Working Trees wieder auf den Stand bringen, auf dem er war, bevor Sie den Merge-Vorgang angestoßen haben.
Dieses Kommando bricht auch einen Merge ab, den Sie schon teilweise gelöst haben.
Achtung: Dabei gehen alle nicht eingecheckten Änderungen verloren.
////

If you don't know how to resolve the conflict on an _ad hoc_ basis (for example, if you want to hire the original developer to produce a conflict-free version of the code), you can use `git merge --abort` to abort the merge process -- that is, to restore your working tree to the state it was in before you initiated the merge.
This command also aborts a merge that you have already partially resolved.
Attention: All changes that have not been checked in will be lost.


[TIP]
=====================
////
Um einen Überblick zu erhalten, welche Commits für den Merge-Konflikt relevante Änderungen an Ihrer Datei verursacht haben, können Sie das Kommando
////

To get an overview of which commits caused changes to your file relevant to the merge conflict, you can use the command

--------
git log --merge -p -- <file>
--------

////
verwenden.
Git listet dann die Diffs von Commits auf, die seit der Merge-Basis Änderungen an `<datei>` vorgenommen haben.
////

Git then lists the diffs of commits that have made changes to `<file>` since the merge base.
=====================


////
Wenn Sie sich in einem Merge-Konflikt befinden, liegt eine Datei mit Konflikten in drei Stufen (_Stages_) vor: Stufe eins enthält die Version der Datei in der Merge-Basis (also die gemeinsame Ursprungsversion der Datei), Stufe zwei enthält die Version aus dem `HEAD` (also die Version aus dem Branch, _in den_ Sie mergen).
Stufe drei enthält schließlich die Datei in der Version des zu integrierenden Branches (dieser hat die symbolische Referenz `MERGE_HEAD`).
Im Working Tree befindet sich die Kombination dieser drei Stufen mit Konflikt-Markern.
Sie können diese Versionen aber jeweils mit `git show :<n>:<datei>` anzeigen:
////

If you are in a merge conflict, a file with conflicts is stored in three _stages_: Stage one contains the version of the file in the merge base (that is, the common original version of the file), stage two contains the version from the `HEAD` (that is, the version from the branch _into_ which you are merging).
Finally, stage three contains the file in the version of the branch you are merging into (this has the symbolic reference `MERGE_HEAD`).
The working tree contains the combination of these three stages with conflict markers.
However, you can display these versions with `git show :<n>:<file>`:


[subs="quotes"]
--------
$ *git show :1:output.c*
$ *git show :2:output.c*
$ *git show :3:output.c*
--------


////
Mit einem speziell für 3-Wege-Merges entwickelten Programm behalten Sie allerdings wesentlich leichter den Überblick.
Das Programm betrachtet die drei Stufen einer Datei, visualisiert sie entsprechend und bietet Ihnen Möglichkeiten an, Änderungen hin- und herzuschieben.

////
With a program specially developed for 3-way merges, however, it is much easier for you to keep an overview.
The program looks at the three stages of a file, visualizes them accordingly and offers you options to move changes back and forth.




[[sec.mergetool]]
=== Help with Merging: Mergetool
//  Hilfe beim Merge: mergetool

////
Bei nicht-trivialen Merge-Konflikten empfiehlt sich ein Merge-Tool, das die drei Stufen einer Datei entsprechend visualisiert und dadurch die Lösung des Konflikts erleichtert.
////

In the case of non-trivial merge conflicts, a merge tool is recommended that visualizes the three stages of a file accordingly, thereby facilitating the resolution of the conflict.


////
Gängige IDEs und Editoren wie z.B. Vim und Emacs bieten einen solchen Modus an.
Außerdem gibt es externe Tools, wie zum Beispiel _KDiff3_[41] und _Meld_[42].
Letzteres visualisiert besonders gut, wie sich eine Datei zwischen den Commits verändert hat.
////

Common IDEs and editors such as Vim and Emacs offer such a mode.
There are also external tools such as _KDiff3_{fn41} and _Meld_.{fn42}
The latter visualizes particularly well how a file has changed between commits.


// .Der Beispiel-Merge-Konflikt, im Merge-Tool "`Meld`" visualisiert
.The example merge conflict, visualized in the merge tool "`Meld`"
image::meld-example.png[id="fig.meld",scaledwidth="100%",width="100%",align="center"]


////
Sie starten ein solches Merge-Tool über `git mergetool`.
Git wird alle Dateien, die Konflikte enthalten, durchgehen und jeweils (wenn Sie Eingabe drücken) in einem Merge-Tool anzeigen.
Per Default ist das Vimdiff[43].
////

You launch such a merge tool via `git mergetool`.
Git will go through all the files that contain conflicts and display each one (when you press enter) in a merge tool.
By default this is Vimdiff.{fn43}


////
Ein solches Programm wird in der Regel die drei Versionen einer Datei -- _unsere_ Seite, _deren_ Seite sowie die soweit wie möglich zusammengeführte Datei inklusive Konflikt-Markern -- in drei Spalten nebeneinander anzeigen, letztere sinnvollerweise in der Mitte.
Wesentlich ist immer, dass Sie die Änderung (Konfliktlösung) in der mittleren Datei machen, also auf der Working-Copy.
Die anderen Dateien sind temporär und werden wieder gelöscht, wenn das Merge-Tool beendet wurde.
////

Such a program will usually display the three versions of a file -- _our_ page, _their_ page, and the file merged as far as possible, including conflict markers -- in three columns side by side, the latter sensibly in the middle.
It is always essential that you make the change (conflict resolution) in the middle file, i.e. in the working copy.
The other files are temporary and are deleted again when the merge tool is finished.


////
Prinzipiell können Sie ein beliebiges anderes Tool verwenden.
Das `mergetool`-Script legt lediglich die drei Stufen der Datei mit entsprechendem Dateinamen ab und startet das Diff-Tool auf diesen drei Dateien.
Beendet sich das Programm wieder, überprüft Git, ob noch Konflikt-Marker in der Datei enthalten sind -- wenn nicht, wird Git annehmen, dass der Konflikt erfolgreich gelöst wurde, und die Datei automatisch per `git add` dem Index hinzufügen.
Wenn Sie also alle Dateien abarbeiten, müssen Sie schließlich nur noch einen Commit-Aufruf ausführen, um die Konfliktlösung zu besiegeln.
////

In principle, you can use any other tool.
The `mergetool` script simply stores the three stages of the file with the corresponding file name and starts the diff tool on these three files.
If it quits again, Git checks to see if there are any conflict markers left in the file -- if not, Git will assume that the conflict was resolved successfully and automatically add the file to the index using `git add`.
Finally, when you have finished processing all the files, you only need to make one commit call to seal the conflict resolution.


////
Welches Tool Git auf der Datei startet, regelt die Option `merge.tool`.
Die folgenden Kommandos sind bereits vorkonfiguriert, d.h. Git weiß bereits, in welcher Reihenfolge das Programm die Argumente erwartet und welche Zusatzoptionen angegeben werden müssen:
////

The `merge.tool` option determines which tool Git starts on the file.
The following commands are already preconfigured, meaning that Git already knows in which order the program expects the arguments and which additional options need to be specified:



-------------------
araxis bc3 codecompare deltawalker diffmerge diffuse
ecmerge emerge gvimdiff gvimdiff2 gvimdiff3 kdiff3
meld opendiff p4merge tkdiff tortoisemerge
vimdiff vimdiff2 vimdiff3 xxdiff
-------------------


////
Um Ihr eigenes Merge-Tool zu verwenden, müssen Sie `merge.tool` auf einen geeigneten Namen setzen, zum Beispiel `mymerge`, und anschließend zumindest die Option `mergetool.mymerge.cmd` angeben.
Den darin gespeicherten Ausdruck wertet die Shell aus, und die Variablen `BASE`, `LOCAL`, `REMOTE` sowie `MERGED`, die die Datei mit den Konflikt-Markern enthält, sind auf die entsprechend erzeugten temporären Dateien gesetzt.
Sie können die Eigenschaften Ihres Merge-Kommandos weiter konfigurieren, siehe dafür die Man-Page `git-config(1)` im Abschnitt der `mergetool`-Konfiguration.
////

To use your own merge tool, you must set `merge.tool` to a suitable name, for example `mymerge`, and then at least specify the `mergetool.mymerge.cmd` option.
The shell evaluates the expression stored in it, and the variables `BASE`, `LOCAL`, `REMOTE`, and `MERGED`, which are contained in the file with the conflict markers, are set to the corresponding temporary files.
You can further configure the properties of your merge command, see the `git-config(1)` man page in the `mergetool` configuration section.


[TIP]
================
////
Wenn Sie sich zeitweise (nicht dauerhaft) für ein anderes Merge-Programm entscheiden, geben Sie dieses über die Option `-t <tool>` an.
Um also Meld auszuprobieren, geben Sie während eines Merge-Konflikts einfach `git mergetool -t meld` ein -- dafür muss Meld natürlich installiert sein.
////

If you temporarily (not permanently) decide to use another merge program, specify it with the `-t <tool>` option.
So to try Meld, during a merge conflict, simply type `git mergetool -t meld` -- of course Meld must be installed for this to work.
================



[[sec.rerere]]
=== rerere: Reuse Recorded Resolution
//  rerere: Reuse Recorded Resolution

////
Git besitzt ein relativ unbekanntes (und schlecht dokumentiertes), aber sehr hilfreiches Feature: Rerere, kurz für _Reuse Recorded Resolution_ ("`gespeicherte Konfliktlösung wiederverwenden`"").
Sie müssen die Option `rerere.enabled` auf `true` setzen, damit das Kommando automatisch aufgerufen wird (beachten Sie das `d` am Ende von `enabled`).
////

Git has a relatively unknown (and poorly documented), but very helpful feature: Rerere, short for _Reuse Recorded Resolution_.
You need to set the `rerere.enabled` option to `true` to have the command called automatically (note the `d` at the end of `enabled`).


////
Die Idee hinter Rerere ist simpel, aber effektiv: Sobald ein Merge-Konflikt auftritt, nimmt Rerere automatisch ein _Preimage_ auf, ein Abbild der Konfliktdatei inklusive Markern.
Im Falle des obigen Beispiels sähe das so aus:
////

The idea behind Rerere is simple but effective: Whenever a merge conflict occurs, Rerere automatically records a _pre-image_, an image of the conflict file including markers.
In the case of the example above, it would look like this:


[subs="quotes"]
--------
$ *git merge B*
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
*Recorded preimage for 'output.c'*
Automatic merge failed; fix conflicts and then commit the result.
--------


////
Wird der Konflikt wie oben gelöst und die Lösung eingecheckt, speichert Rerere die Konfliktlösung ab:
////

If the conflict is resolved as above and the solution is checked in, Rerere saves the conflict resolution:


[subs="quotes"]
--------
$ *vim output.c*
$ *git add output.c*
$ *git commit*
*Recorded resolution for 'output.c'.*
[master 681acc2] Merge branch 'B'
--------


////
Bisher hat Rerere noch nicht wirklich geholfen.
Jetzt aber können wir den Merge-Commit komplett löschen (und sind wieder in der Ausgangssituation vor dem Merge).
Dann führen wir den Merge noch einmal aus:
////

So far Rerere has not really helped.
But now we can delete the merge commit completely (and are back to the situation before the merge).
Then we execute the merge again:


[subs="quotes"]
--------
$ *git reset --hard HEAD^*
HEAD is now at f894659 wrap output at 72 chars
$ *git merge B*
Auto-merging output.c
CONFLICT (content): Merge conflict in output.c
*Resolved 'output.c' using previous resolution.*
Automatic merge failed; fix conflicts and then commit the result.
--------


////
Rerere bemerkt, dass der Konflikt bekannt ist und dass bereits eine Lösung gefunden wurde. [44]
Also berechnet Rerere einen 3-Wege-Merge zwischen dem gespeicherten Preimage, der gespeicherten Lösung und der im Working Tree vorliegenden Version der Datei.
So kann Rerere nicht nur dieselben Konflikte lösen, sondern auch _ähnliche_ (wenn zwischenzeitlich weitere Zeilen außerhalb des Konfliktbereichs geändert wurden).
////

Rerere notices that the conflict is known and that a solution has already been found.{fn44}
So Rerere calculates a 3-way-merge between the saved pre-image, the saved solution and the version of the file in the working tree.
This way Rerere can resolve not only the same conflicts, but also _similar_ ones (if in the meantime further lines outside the conflict area have been changed).


////
Das Ergebnis wird _nicht_ direkt dem Index hinzugefügt.
Die Lösung wird lediglich in die Datei übernommen.
Sie können dann per `git diff` nachschauen, ob die Lösung sinnvoll aussieht, eventuell Tests laufen lassen etc.
Wenn alles gut aussieht, übernehmen Sie wie üblich die automatische Lösung per `git add`.
////

The result is _not_ directly added to the index.
The solution is simply copied to the file.
You can then use `git diff` to check whether the solution looks useful, run tests if necessary, etc.
If everything looks good, you can use the automatic solution via `git add` as usual.



[[sec.rerere-explained]]
==== Why Rerere Makes Sense
//   Warum Rerere sinnvoll ist

////
Man könnte einwenden: Wer geht denn freiwillig das Risiko ein, einen bereits (möglicherweise aufwendig) gelösten Merge-Konflikt zu löschen, um ihn irgendwann wiederholen zu wollen?
////

One might object: Who voluntarily takes the risk of deleting an already (possibly costly) resolved merge conflict in order to want to repeat it at some point?


////
Das Vorgehen ist allerdings wünschenswert: Zunächst ist es _nicht_ sinnvoll, einfach periodisch und aus Gewohnheit die Mainline -- also den Hauptentwicklungsstrang, z.B. `master` -- in den Topic-Branch zu mergen (wir werden noch darauf zurückkommen).
Wenn Sie aber einen langlebigen Topic-Branch haben und diesen gelegentlich darauf testen wollen, ob er sich mit der Mainline verträgt, dann wollen Sie nicht jedes Mal die Konflikte von Hand auflösen -- einmal gelöste Konflikte wird Rerere dann automatisch auflösen.
Sie können so sukzessive Ihr Feature weiterentwickeln, wohlwissend, dass es mit der Mainline in Konflikt steht.
Zum Zeitpunkt der Integration des Features sind die Konflikte aber alle automatisch lösbar (weil Sie gelegentlich Konfliktlösungen mit Rerere abgespeichert haben).
////

However, the procedure is desirable: First of all, it _doesn't_ make sense to simply periodically and out of habit merge the mainline -- i.e. the main development thread, e.g. `master` -- into the topic branch (we will come back to this later).
But if you have a long-lived topic branch and want to test it occasionally to see if it is compatible with the mainline, you don't want to resolve the conflicts by hand every time -- once resolved, Rerere will resolve conflicts automatically.
This way you can successively develop your feature, knowing that it is in conflict with the mainline.
But at the time of the integration of the feature the conflicts are all automatically resolvable (because you have occasionally saved conflict solutions with Rerere).


////
Außerdem wird Rerere auch automatisch in Konfliktfällen aufgerufen, die in einem Rebase-Prozess (siehe Abschnitt 4.1, "Commits verschieben – Rebase") entstehen.
Auch hier gilt wieder: Einmal gelöste Konflikte können automatisch wieder gelöst werden.
Wenn Sie einen Branch einmal testweise per Merge in die Mainline integriert und einen Konflikt gelöst haben, wird diese Lösung automatisch angewendet, wenn Sie diesen Branch per Rebase auf die Mainline neu aufbauen.
////

In addition, Rerere is also called automatically in conflict cases that arise in a rebase process (see <<sec.rebase>>).
Again, once conflicts have been resolved, they can be automatically resolved again.
Once you have merged a branch into the mainline for test purposes and resolved a conflict, this solution is automatically applied when you rebuild this branch on the mainline via rebase.




[[sec.rerere-usage]]
==== Using Rerere
//   Rerere benutzen

////
Damit die Rerere-Funktionalität verwendet wird, müssen Sie, wie schon erwähnt, die Option `rerere.enabled` auf `true` setzen.
Rerere wird dann automatisch aufgerufen, wenn ein Merge-Konflikt auftritt (um das Preimage aufzunehmen, möglicherweise auch um den Konflikt zu lösen) und wenn eine Konfliktlösung eingecheckt wird (um die Lösung abzuspeichern).
////

In order for the Rere functionality to be used, you must set the `rerere.enabled` option to `true`, as mentioned above.
Rerere will then be called automatically when a merge conflict occurs (to capture the pre-image, possibly to resolve the conflict) and when a conflict resolution is checked in (to save the resolution).


////
Rerere legt Informationen wie Preimage und Lösung in `.git/rr-cache/` ab, eindeutig identifiziert durch eine SHA-1-Summe.
Das Subkommando `git rerere` müssen Sie fast nie aufrufen, da es von `merge` und `commit` schon erledigt wird.
Sie können analog zu `git gc` auch `git rerere gc` verwenden, um sehr alte Lösungen zu löschen.

////
Rerere stores information such as pre-image and resolution in `.git/rr-cache/`, uniquely identified by a SHA-1 sum.
You almost never need to call the `git rerere` subcommand, as it is already handled by `merge` and `commit`.
You can also use `git rerere gc` to delete very old solutions.


////
Was passiert, wenn eine falsche Konfliktlösung eingecheckt wurde?
Dann sollten Sie die Konfliktlösung löschen, andernfalls wird Rerere die Lösung, wenn Sie den konfliktbehafteten Merge wiederholen, erneut anwenden.
Dafür gibt es das Kommando `git rerere forget <datei>` -- direkt nachdem Rerere eine falsche Lösung eingespielt hat, können Sie auf diese Weise die falsche Lösung löschen und den Ursprungszustand der Datei wiederherstellen (d.h.  mit Konflikt-Markern).
Wollen Sie nur Letzteres bewirken, hilft auch ein `git checkout -m <datei>`.
////

What happens if a wrong conflict resolution was checked in?
Then you should delete the conflict resolution, otherwise Rerere will reapply the solution when you repeat the conflicted merge.
To do this, there is the command `git rerere forget <file>` -- directly after Rerere has checked in a wrong solution, you can delete the wrong solution in this way and restore the original state of the file (i.e. with conflict markers).
If you only want to do the latter, a `git checkout -m <file>` will also help.



[[sec.avoid-conflicts]]
=== Avoiding Conflicts
//  Konflikte vermeiden

////
Dezentrale Versionskontrollsysteme verwalten Merges generell wesentlich besser als zentrale.
Das liegt vor allem daran, dass es bei dezentralen Systemen Usus ist, viele kleine Änderungen zunächst _lokal_ einzuchecken.
Dadurch entstehen keine "`Monster-Commits`", die wesentlich mehr Konfliktpotential bieten.
Diese feiner granulierte Entwicklungsgeschichte und der Umstand, dass Merges in der Regel wiederum Daten in der Versionsgeschichte sind (im Gegensatz zu einem simplen Kopieren der Codezeilen), führen dazu, dass dezentrale Systeme bei einem Merge nicht nur auf den bloßen Inhalt von Dateien schauen müssen.
////

Decentralized version control systems generally manage merges much better than central ones.
This is mainly due to the fact that it is common practice in decentralized systems to check in many small changes _locally_ first.
This avoids "`monster commits`", which offer much more potential for conflict.
This finer granular development history and the fact that merges are usually data in the version history (as opposed to simply copying the lines of code) mean that decentralized systems do not have to look at the mere contents of files when merging.


////
Um Merge-Konflikte zu minimieren, ist Vorbeugung das beste Mittel.
Machen Sie kleine Commits!
Fassen Sie Ihre Änderungen so zusammen, dass der resultierende Commit als Einheit Sinn ergibt.
Bauen Sie Topic-Branches immer auf dem neuesten Release auf.
Mergen Sie von Topic-Branches in "`Sammel-Branches`" oder direkt in den `master`, nicht anders herum.[45]
Der Einsatz von Rerere erlaubt es, dass bereits gelöste Konflikte nicht ständig erneut auftreten.
////

Prevention is the best way to minimize merge conflicts.
Make small commits!
Combine your changes so that the resulting commit makes sense as a unit.
Always build Topic Branches on the latest release.
Merge from topic branches into "`collection branches`" or directly into `master`, not the other way around.{fn45}
Using Rerere prevents conflicts that have already been resolved from constantly reoccurring.


////
Offensichtlich zählt zur Vorbeugung auch gute Kommunikation unter den Entwicklern: Wenn mehrere Entwickler an der gleichen Funktion unterschiedliche und sich gegenseitig beeinflussende Änderungen implementieren, wird das früher oder später sicher zu Konflikten führen.
////

Obviously, good communication among developers is also important for prevention: If several developers implement different and mutually influencing changes to the same function, this will certainly lead to conflicts sooner or later.


////
Ein weiterer Faktor, der leider häufig zu unnötigen(!) Konflikten führt, sind autogenerierte Inhalte.
Angenommen, Sie schreiben die Dokumentation einer Software in _AsciiDoc_[46] oder arbeiten an einem LaTeX-Projekt mit mehreren Mitstreitern: Fügen Sie keinesfalls die kompilierten Man-Pages oder das kompilierte DVI/PS/PDF im Repository ein!
In den autogenerierten Formaten können kleine Änderungen am Plaintext (d.h. in der Ascii- bzw. LaTeX-Version) große (und unvorhersehbare) Änderungen an den kompilierten Formaten hervorrufen, die Git nicht adäquat auflösen wird.
Sinnvoll ist es stattdessen, entsprechende Makefile-Targets oder Scripte bereitzustellen, um die Dateien zu generieren, und möglicherweise die kompilierte Version auf einem separaten Branch vorzuhalten.[47]
////

Another factor that unfortunately often leads to unnecessary(!) conflicts is autogenerated content.
Suppose you write the documentation of a software in _AsciiDoc_{fn46} or work on a LaTeX project with several contributors: Never add the compiled man pages or the compiled DVI/PS/PDF to the repository!
In the autogenerated formats, small changes to the plaintext (i.e. in the Ascii or LaTeX version) can cause large (and unpredictable) changes to the compiled formats that Git will not resolve adequately.
Instead, it makes sense to provide appropriate Makefile targets or scripts to generate the files, and possibly keep the compiled version on a separate branch.{fn47}




[[sec.cherry-pick]]
== Taking over Individual Commits: Cherry Pick
// Einzelne Commits übernehmen: Cherry-Pick

////
Es wird vorkommen, dass Sie nicht direkt einen ganzen Branch integrieren wollen, sondern zunächst Teile, also einzelne Commits.
Dafür ist das Git-Kommando `cherry-pick` ("`die guten Kirschen herauspicken`"") zuständig.
////

It will happen that you don't want to integrate an entire branch directly, but rather parts, i.e. individual commits, first.
The `cherry-pick` ("`pick the good cherries`") git command is responsible for this.


////
Das Kommando erwartet einen oder mehrere Commits, die auf den aktuellen Branch kopiert werden sollen.
Zum Beispiel:

////
The command expects one or more commits to be copied to the current branch.
For example:


[subs="quotes,attributes"]
--------
$ *git cherry-pick d0c915d*
$ *git cherry-pick topic~5 topic~1*
$ *git cherry-pick topic{tilde}5..topic~1*
--------


////
Das mittlere Kommando kopiert zwei explizit angegebene Commits; das letzte Kommando hingegen kopiert alle zu der angegebenen Commit-Range gehörigen Commits.
////

The middle command copies two explicitly specified commits; the last command, on the other hand, copies all commits belonging to the specified commit range.


////
Im Gegensatz zu einem Merge werden aber nur die Änderungen integriert, nicht der Commit selbst.
Dafür müsste er nämlich seinen Vorgänger referenzieren, so dass dieser auch integriert werden müsste usw. -- was einem Merge gleichkommt.
Wenn Sie Commits mit `cherry-pick` übernehmen, entstehen dabei also _neue_ Commits mit neuer Commit-ID.
Git kann danach _nicht_ ohne weiteres wissen, dass diese Commits eigentlich die gleichen sind.
////

Unlike a merge, however, only the changes are integrated, not the commit itself.
To do this, it would have to reference its predecessor, so that the predecessor would also have to be integrated, and so on, which is equivalent to a merge.
So when you take over commits with `cherry-pick`, _new_ commits are created with a new commit ID.
Git _can't_ know that these commits are actually the same.


////
Daher kann es, wenn Sie zwei Branches mergen, zwischen denen Sie Änderungen per Cherry-Pick ausgetauscht haben, zu Konflikten kommen.[48]
Diese sind meist trivial zu lösen, möglicherweise sind auch die Strategie-Optionen `ours` bzw. `theirs` hilfreich (siehe Abschnitt 3.3.4, "Optionen für die recursive-Strategie").
Das Rebase-Kommando hingegen erkennt solche Commit-Doppelungen,[49] und lässt die gedoppelten Commits aus.
So können Sie einige Commits "`aus der Mitte`" übernehmen und dann den Branch, aus dem die Commits stammten, neu aufbauen.
////

So if you are merging two branches that you have cherry-picked changes between, conflicts can occur.{fn48}
These are usually trivial to resolve, and the strategy options `ours` and `theirs` might be helpful (see <<sec.recursive-options>>).
The rebase command, on the other hand, recognizes such commit duplications,{fn49} and omits the duplicated commits.
This allows you to take some commits "`from the middle`" and then rebuild the branch the commits came from.


////
Das `cherry-pick`-Kommando versteht außerdem selbst diese Merge-Strategie-Optionen: Wenn Sie einen Commit in den aktuellen Branch kopieren wollen, und im Konfliktfall dem neuen Commit recht geben wollen, verwenden Sie:
////

The `cherry-pick` command also understands these merge strategy options itself: If you want to copy a commit to the current branch, and if you want to make sure the new commit is right in case of conflict, use:



------
git cherry-pick -Xtheirs <commit>
------


[TIP]
========
////
Über die Option `-n` bzw. `--no-commit` veranlassen Sie Git, die Änderungen eines Commits zwar in den Index zu übernehmen, aber noch keinen Commit daraus zu machen.
So können Sie mehrere kleine Commits erst im Index "`aggregieren`" und dann als _einen_ Commit verpacken:
////

The `-n or` `--no-commit` option tells Git to commit the changes from a commit to the index, but not to make a commit yet.
This allows you to "`aggregate`" several small commits into the index first, and then package them as _one_ commit:

[subs="quotes"]
--------
$ *git cherry-pick -n 785aa39 512f3e9 4e4a063*
Finished one cherry-pick.
Finished one cherry-pick.
Finished one cherry-pick.
$ *git commit -m "Diverse kleine Änderungen"*
--------
========



[[sec.visualization]]
== Visualizing Repositories
// Visualisierung von Repositories

////
Wenn Sie einige Branches erstellt und wieder zusammengeführt haben, werden Sie gemerkt haben: Man verliert leicht den Überblick.
////

When you have created and merged some branches, you will have noticed that the following is the case: it's easy to lose track.


////
Die Anordnung der Commits und ihre Beziehungen untereinander bezeichnet man als _Topologie_ eines Repositorys.
Im Folgenden werden wir unter anderem das grafische Programm `gitk` vorstellen, um diese Topologien zu untersuchen.
////

The arrangement of commits and their relationships to each other is called the _topology_ of a repository.
In the following, we will introduce the graphical program `gitk`, among other things, to examine these topologies.


////
Rufen Sie bei kleinen Repositories zunächst ganz einfach `gitk --all` auf, das das komplette Repository als Graphen darstellt.
Ein Klick auf die einzelnen Commits zeigt die Metainformationen sowie den erzeugten Patch an.
////

For small repositories, first call `gitk --all`, which displays the entire repository as a graph.
Clicking on the individual commits displays the meta-information as well as the generated patch.



[[rev-list]]
=== Revision Parameters

////
Da die Auflistung mehrerer Commits kaum zu überblicken ist, untersuchen wir ein kleines Beispiel-Repository mit mehreren Branches, die untereinander gemergt wurden:
////

Since the listing of multiple commits is hard to keep track of, we examine a small sample repository with several branches merged together:


// .Der Graph der Commits, wie er in `gitk` dargestellt wird
.The graph of commits as displayed in `gitk`
image::revision-list-commit-graph-gitk.png[id="fig.rev-list-graph",scaledwidth="50%",width="50%",align="center"]


////
Wir erkennen vier Branches (A-D) sowie einen Tag `release`.
Diesen Baum können wir mit geeigneten Kommandozeilenoptionen auch per `log`-Kommando auf der Konsole anzeigen lassen (Branch- und Tag-Namen sind zur besseren Unterscheidung halbfett gedruckt):
////

We recognize four branches (A-D) and one tag `release`.
We can also display this tree on the console with the appropriate command line options using the `log` command (branch and tag names are printed in semi-bold for better distinction):


[subs="quotes"]
--------
$ *git log --decorate --pretty=oneline --abbrev-commit --graph --all*
* c937566 (*HEAD*, *D*) commit on branch D
| *   b0b30ef (*release*, *A*) Merge branch 'C' into A
| |\
| | * 807db47 (*C*) commit on branch C
| | * 996a53b commit on branch C
| |/
|/|
| * 83f6bf3 commit on branch A
| *   5b2c291 Merge branch 'B' into A
| |\
| | * 2417cf7 (*B*) commit on branch B
| |/
|/|
| * 0bf1433 commit on branch A
|/
* 4783886 initial commit
--------


[TIP]
========
////
Die Ausgabe des `log`-Kommandos ist äquivalent zu der Ansicht in Gitk.
Allerdings ist `git log` sehr viel schneller als Gitk und kommt ohne ein weiteres Programmfenster aus.
////

The output of the `log` command is equivalent to the view in Gitk.
However, `git log` is much faster than Gitk and does not require another program window.


////
Für eine schnelle Übersicht ist es also viel praktischer, ein Alias einzurichten, das die vielen langen Optionen automatisch hinzufügt.
Die Autoren verwenden dafür das Alias `tree`, das Sie wie folgt definieren können:
////

So for a quick overview, it's much more convenient to set up an alias that automatically adds the many long options.
The authors use the alias `tree` for this, which you can define as follows:


[subs="quotes"]
--------
$ *git config --global alias.tree \'log --decorate \*
   *--pretty=oneline --abbrev-commit --graph'*
--------


////
Per `git tree --all` erhalten Sie eine ASCII-Version des Graphen des Git-Repositorys.
Im Folgenden nutzen wir dieses Alias, um die Topologie darzustellen.
////

By using `git tree --all` you get an ASCII version of the graph of the git repository.
In the following, we use this alias to represent the topology.
========


////
Nun verändern wir obiges Kommando: Statt der Option `--all`, die alle Commits im Baum unterbringt, geben wir nun `B` an (den Namen des Branch):
////

Now we change the above command: instead of the `--all` option, which puts all commits in the tree, we now specify `B` (the name of the branch)

[subs="quotes"]
--------
$ *git tree B*
* 2417cf7 (*B*) commit on branch B
* 4783886 initial commit
--------


////
Wir erhalten alle Commits, die von B aus erreichbar sind.
Ein Commit kennt jeweils nur seinen bzw. seine Vorgänger (mehrere dann, wenn Branches zusammengeführt werden).
"`Alle von B erreichbaren Commits`"" bezeichnet also die Liste der Commits von B an weiter bis zu einem Commit, der keinen Vorgänger hat (genannt _Root-Commit_).
////

We receive all commits that are accessible from B.
A commit only knows its predecessor(s) (several if branches are merged).
"`All commits reachable from B`" thus refers to the list of commits from B onwards, up to a commit that has no predecessor (called a _root commit_).


////
Statt einer kann das Kommando auch mehrere Referenzen entgegennehmen.
Um also die gleiche Ausgabe wie mit der Option `--all` zu erhalten, müssen Sie die Referenzen A, B und D angeben.
C kann ausgelassen werden, weil der Commit auf dem Weg von A zum Root-Commit bereits "`eingesammelt`" wird.
////

Instead of one, the command can also accept multiple references.
So to get the same output as with the `--all` option, you must specify references A, B, and D.
C can be omitted because the commit is already "`collected`" on the way from A to the root commit.


////
Natürlich können Sie statt symbolischer Referenzen auch direkt eine SHA-1-Summe angeben:
////

Of course, you can also specify an SHA-1 sum directly instead of symbolic references:


[subs="quotes"]
--------
$ *git tree 5b2c291*
*   5b2c291 Merge branch 'B' into A
|\
| * 2417cf7 (*B*) commit on branch B
* | 0bf1433 commit on branch A
|/
* 4783886 initial commit
--------


////
Wird einer Referenz ein Caret (`^`) vorangestellt, so negiert das die Bedeutung.[50]
Die Notation `^A` bedeutet also: _nicht_ die Commits, die von A aus erreichbar sind.
Allerdings schließt dieser Schalter lediglich diese Commits aus, nicht jedoch die anderen ein.
Obiges `log`-Kommando mit dem Argument `^A` wird also nichts ausgeben, da Git nur weiß, welche Commits _nicht_ angezeigt werden sollen.
Wir fügen also wieder `--all` hinzu, um alle Commits aufzulisten, abzüglich derer, die von A erreichbar sind:
////

If a reference is preceded by a caret (`^`), this negates the meaning.{fn50}
So the notation `^A` means: _not_ the commits that are accessible from A.
However, this switch only excludes these commits, but not the others.
So the above log command with the argument `^A` will not output anything, because Git only knows which commits should _not_ be displayed.
So again, we add `--all` to list all commits, minus those that are accessible from A:


[subs="quotes"]
--------
$ *git tree --all ^A*
* c937566 (*HEAD*, *D*) commit on branch D
--------


////
Eine alternative Notation ist mit `--not` verfügbar: Statt `^A` kann man auch `--not A` schreiben.
////

An alternative notation is available with `--not`: Instead of `^A` you can also write `--not A`.


////
Besonders hilfreich sind solche Kommandos, um den _Unterschied_ zwischen zwei Branches zu untersuchen: Welche Commits sind in Branch D, die nicht in A sind?
Die Antwort liefert das Kommando:
////

Such commands are especially useful for examining the _difference_ between two branches: Which commits are in branch D that are not in A?
The command returns the answer:


[subs="quotes"]
--------
$ *git tree D ^A*
* c937566 (*HEAD*, *D*) commit on branch D
--------


////
Weil sich diese Frage häufig stellt, gibt es dafür eine andere, intuitivere Notation: `A..D` ist gleichbedeutend mit `D ^A`:
////

Because this question is often asked, there is another, more intuitive notation for it: `A..D` is equivalent to `D ^A`:


[subs="quotes"]
--------
$ *git tree A..D*
* c937566 (*HEAD*, *D*) commit on branch D
--------


////
Natürlich ist hier die Reihenfolge wichtig: "`D ohne A`" ist eine andere Menge von Commits als "`A ohne D`"!
(Vergleiche auch den vollständigen Graphen.)
////

Of course the order is important here: "`D without A`" is a different set of commits than "`A without D`"!
(Compare also the complete graph.)


////
Im unserem Beispiel gibt es einen Tag `release`.
Um zu überprüfen, welche Commits aus dem Branch D (der für "`Development`" stehen könnte) noch nicht im aktuellen Release enthalten sind, genügt die Angabe `release..D`.
////

In our example there is a tag `release`.
To check which commits from branch D (which could stand for "`Development`") are not yet included in the current release, simply specify `release..D`.


//\label{sec:rev-symmetric}


[TIP]
========
////
Die Syntax `A..B` kann man sich als Idiom "`von A bis B`"" merken.
Diese "`Differenz`"ist aber nicht symmetrisch, d.h. `A..B` sind in der Regel nicht die gleichen Commits wie `B..A`.

////
The syntax `A..B` can be remembered as the idiom "`from A to B`".
However, this "`difference`" is not symmetrical, i.e. `A..B` are usually not the same commits as `B..A`.


////
Alternativ stellt Git die _symmetrische Differenz_ `A...B` bereit.
Sie entspricht dem Argument `A B --not $(git merge-base A B)`, bezieht also alle Commits ein, die von A _oder_ von B erreichbar sind -- aber nicht von beiden.
////

Alternatively, Git provides the _symmetrical difference_ `A..B`.
It is equivalent to the argument `A B --not $(git merge-base A B)`, so it includes all the commits that can be reached from A _or_ B, but not both.
========




[[rev-list-explained]]
==== Reference vs. List of References
//   Referenz vs. Liste von Referenzen

////
Im Beispiel werden mit A immer alle Commits bezeichnet, die von A erreichbar sind.
Aber eigentlich ist ein Branch ja nur eine Referenz auf _einen_ Commit.
Warum listet also `log` immer alle von A erreichbaren Commits auf, während das Git-Kommando `show` mit dem Argument `A` nur diesen einen Commit anzeigt?
////

In the example, A always refers to all commits that are accessible from A.
But actually a branch is just a reference to a _single_ commit.
So why does `log` always list all commits reachable from A, while the git command `show` with the argument A only shows this one commit?


////
Der Unterschied liegt darin, was die Kommandos als Argument erwarten: `show` erwartet ein _Objekt_, also eine Referenz auf _ein_ Objekt, das dann angezeigt wird.[51]
Viele andere Kommandos erwarten stattdessen einen (oder auch mehrere) _Commits_, und diese Kommandos wandeln die Argumente in eine Liste von Commits um (traversieren die Liste bis zum Root-Commit).
////

The difference is what the commands expect as an argument: `show` expects an _object_, that is, a reference to a _single_ object, which is then displayed.{fn51}
Many other commands expect one (or more) commits instead, and these commands convert the arguments into a list of commits (traversing the list until the root commit).




[[sec.gitk]]
=== Gitk

////
Gitk ist ein in Tcl implementiertes grafisches Programm, das in der Regel von Distributoren zusammen mit den eigentlichen Git-Kommandos paketiert wird -- Sie können sich also darauf verlassen, es auf fast jedem System vorzufinden.
////

Gitk is a graphical program implemented in Tcl, which is usually packaged by distributors along with the actual Git commands -- so you can be sure to find it on almost any system.


////
Es repräsentiert einzelne Commits oder das ganze Repository in einer dreiteiligen Ansicht: Oben die Baumstruktur mit zwei weiteren Spalten für Autor und Datum, unten eine Auflistung der Änderungen im Unified-Diff-Format sowie eine Liste von Dateien, um die angezeigten Änderungen einzuschränken.
////

It represents individual commits or the entire repository in a three-part view: at the top is the tree structure with two additional columns for author and date, below is a list of changes in unified diff format, and a list of files to restrict the changes displayed.


////
Die Graph-Ansicht ist intuitiv: Verschiedene Farben helfen, die verschiedenen Versionsstränge zu unterscheiden.
Commits sind jeweils blaue Punkte, mit zwei Ausnahmen: Der `HEAD` ist gelb markiert, und ein Commit, der nicht Root-Commit ist, dessen Vorgänger aber nicht angezeigt ist, wird weiß dargestellt.
////

The graph view is intuitive: Different colors help to distinguish the different version strings.
Commits are always blue dots, with two exceptions: The `HEAD` is highlighted in yellow, and a commit that is not a root commit, but whose predecessor is not displayed, is shown in white.


////
Branches mit einer Pfeilspitze deuten an, dass auf dem Branch weitere Commits getätigt wurden.
Aufgrund der zeitlichen Distanz der Commits blendet Gitk aber den Branch aus.
Ein Klick auf die Pfeilspitze bringt Sie zu der Weiterführung des Branches.
////

Branches with an arrowhead indicate that further commits have been made on the branch.
However, Gitk hides the branch due to the time distance between commits.
A click on the arrowhead will take you to the continuation of the branch.


////
Branches erscheinen als grüne Labels, der aktuell ausgecheckte Branch zusätzlich fett.
Tags sind als gelbe Pfeile dargestellt.
////

Branches appear as green labels, the currently checked out branch additionally bold.
Tags are shown as yellow arrows.


////
Mit einem Rechtsklick auf einen Branch können Sie diesen löschen oder auschecken.
Auf Commits öffnet ein Rechtsklick ein Menü, in dem Sie Aktionen mit dem markierten Commit ausführen können.
Die einzige, die mit Gitk möglicherweise leichter zu bewerkstelligen ist als über die Kommandozeile, ist _Cherry-Picking_, also das Übernehmen einzelner Commits in einen anderen Branch (siehe auch Abschnitt 3.5, "Einzelne Commits übernehmen: Cherry-Pick").
////

You can delete or check out a branch with a right click on it.
Right-clicking on commits opens a menu in which you can perform actions on the selected commit.
The only thing that might be easier to do with Gitk than from the command line is _cherry picking_, i.e. transferring individual commits to another branch (see also <<sec.cherry-pick>>).



// .Komplizierte Topologie in Gitk
.Complex topology in Gitk
image::gitk.png[id="fig.gitk",scaledwidth="90%",width="90%",align="center"]


////
Gitk akzeptiert im wesentlichen die gleichen Optionen wie `git log`.
Einige Beispiele:
////

Gitk accepts essentially the same options as `git log`.
Some examples:



[subs="quotes"]
--------
$ *gitk --since=yesterday -- doc/*
$ *gitk e13404a..48effd3*
$ *gitk --all -n 100*
--------



////
Das erste Kommando zeigt alle Commits seit gestern an, die Änderungen an einer Datei unterhalb des Verzeichnisses `doc/` vorgenommen haben.
Das zweite Kommando limitiert die Commits auf eine spezielle Range, während das dritte Kommando die 100 neuesten Commits aller Branches anzeigt.
////

The first command shows all commits since yesterday that have made changes to a file under the `doc/` directory.
The second command limits the commits to a specific range, while the third command shows the 100 most recent commits from all branches.


[TIP]
========
////
Erfahrungsgemäß sind Anfänger oft verwirrt, weil `gitk` standardmäßig nur den aktuellen Branch anzeigt.
Das liegt vermutlich daran, dass `gitk` oft aufgerufen wird, um sich einen Überblick aller Branches zu verschaffen.
Daher bietet sich folgendes Shell-Alias an: `alias gik='gitk --all'`.
////

Experience shows that beginners are often confused because `gitk` by default only shows the current branch.
This is probably because `gitk` is often called to get an overview of all branches.
Therefore the following shell alias is useful: `alias gik='gitk --all'`.
========


////
Viele Nutzer lassen `gitk` während der Arbeit offen.
Dann ist es wichtig, von Zeit zu Zeit die Anzeige zu aktualisieren, damit auch aktuellere Commits erscheinen.
Mit _F5_ (_Update_) laden Sie alle neuen Commits und erneuern die Darstellung der Referenzen.
Manchmal, wenn Sie z.B. einen Branch löschen, reicht dies jedoch nicht aus. Zwar wird der Branch nicht mehr angezeigt, aber evtl. sind unerreichbare Commits weiterhin quasi als Artefakte in der GUI vorhanden.
Mit der Tastenkombination _Strg+F5_ (_Reload_) wird das Repository vollständig neu eingelesen, was das Problem beseitigt.
////

Many users leave `gitk` open during work.
Then it's important to update the display from time to time so that more recent commits appear.
With kbd:[F5] (_Update_) you load all new commits and refresh the display of the references.
Sometimes, however, if you delete a branch, for example, this is not enough.
Although the branch is no longer displayed, there may still be unreachable commits in the GUI as artifacts.
The key combination kbd:[Ctrl+F5] (_Reload_) completely reloads the repository, which solves the problem.


////
Alternativ zu `gitk` können Sie auf UNIX-Systemen das GTK-basierte `gitg` oder Qt-basierte `qgit` verwenden; auf einem OS-X-System können Sie beispielsweise _GitX_ verwenden; für Windows bieten sich die _GitExtensions_ an.
Einige IDEs verfügen mittlerweile auch über entsprechende Visualisierungen (z.B. das _Eclipse_-Plugin _EGit_).
Weiterhin können Sie vollwertige Git-Clients wie _Atlassian SourceTree_ (OS X, Windows; kostenlos), _Tower_ (OS X; kommerziell) sowie _SmartGit_ (Linux, OS X und Windows; kostenlos für nichtkommerzielle Nutzung) verwenden.
////

As an alternative to `gitk`, you can use the GTK-based `gitg` or Qt-based `qgit` on UNIX systems; on an OS X system, for example, you can use _GitX_; for Windows, you can use _GitExtensions_.
Some IDEs now also have corresponding visualizations (e.g. the _Eclipse_ plugin _EGit_).
Furthermore, you can use full-fledged Git clients like _Atlassian SourceTree_ (OS X, Windows; free of charge), _Tower_ (OS X; commercial) as well as _SmartGit_ (Linux, OS X and Windows; free for non-commercial use).




[[sec.reflog]]
== Reflog

////
Das _Reference Log_ (_Reflog_) sind Log-Dateien, die Git für jeden Branch sowie `HEAD` anlegt.
Darin wird gespeichert, wann eine Referenz von wo nach wo verschoben wurde.
Das passiert vor allem bei den Kommandos `checkout`, `reset`, `merge` und `rebase`.
////

The _Reference Log_ (_Reflog_) are log files that Git creates for each branch and `HEAD`.
They store when a reference was moved from where to where.
This happens especially with the `checkout`, `reset`, `merge` and `rebase` commands.


////
Diese Log-Dateien liegen unter `.git/logs/` und tragen den Namen der jeweiligen Referenz.
Das Reflog für den `master`-Branch finden Sie also unter `.git/logs/refs/heads/master`.
Außerdem gibt es das Kommando `git reflog show <referenz>`, um das Reflog aufzulisten:
////

These log files are stored under `.git/logs/` and are named after the reference.
The reflog for the `master` branch can be found under `.git/logs/refs/heads/master`.
There is also the command `git reflog show <reference>` to list the reflog:



[subs="quotes"]
--------
$ *git reflog show master*
48effd3 master@{0}: HEAD^: updating HEAD
ef51665 master@{1}: rebase -i (finish): refs/heads/master onto 69b9e27
231d0a3 master@{2}: merge @{u}: Fast-forward
...
--------



////
Das Reflog-Kommando wird selten direkt benutzt und ist nur ein Alias für `git log -g --oneline`.
Die Option `-g` bewirkt nämlich, dass das Kommando nicht die Vorgänger im Commit-Graphen anzeigt, sondern die Commits in der Reihenfolge des Reflogs abarbeitet.
////

The Reflog command is rarely used directly and is just an alias for `git log -g --oneline`.
In fact, the `-g` option causes the command not to show the predecessors in the commit graph, but to process the commits in the order in which they were reflogged.


////
Das können Sie ganz leicht ausprobieren: Erstellen Sie einen Test-Commit und löschen Sie ihn danach wieder mit `git reset --hard HEAD^`.
Das Kommando `git log -g` wird nun zuerst den `HEAD` anzeigen, dann den gelöschten Commit und dann wieder den `HEAD`.
////

You can easily try this: Create a test commit, then delete it again with `git reset --hard HEAD^`.
The command `git log -g` will now first show the `HEAD`, then the deleted commit, and then the `HEAD` again.


////
Das Reflog referenziert also auch Commits, die sonst nicht mehr referenziert sind, also "`verloren`" sind (siehe Abschnitt 3.1.2, "Branches verwalten").
So hilft das Reflog Ihnen möglicherweise, wenn Sie einen Branch gelöscht haben, von dem sich im Nachhinein herausstellt, dass Sie ihn doch gebraucht hätten.
Zwar löscht ein `git branch -D` auch das Reflog des Branches.
Allerdings haben Sie den Branch ja auschecken müssen, um Commits darauf zu machen: Suchen Sie also mit `git log -g HEAD` nach dem letzten Zeitpunkt, zu dem Sie den gesuchten Branch ausgecheckt haben.
Dann erstellen Sie einen Branch, der auf diese (scheinbar verlorene) Commit-ID zeigt, und Ihre verlorenen Commits sollten wieder da sein.[52]
////

The reflog thus also references commits that are otherwise no longer referenced, i.e. are "`lost`" (see <<sec.branch-management>>).
The reflog might help you if you have deleted a branch that you would have needed after all.
Although a `git branch -D` also deletes the branch's reflog.
However, you had to check out the branch to commit to it, so use `git log -g HEAD` to find the last time you checked out the branch you were looking for.
Then create a branch that points to this (seemingly lost) commit ID, and your lost commits should be back.{fn52}


////
Kommandos, die eine oder mehrere Referenzen erwarten, können allerdings auch implizit das Reflog verwenden.
Neben der Syntax, die sich schon bei der Ausgabe von `git log -g` findet (z.B. `HEAD@{1}` für die vorherige Position des `HEAD`), versteht Git auch `<ref>@{<wann>}`.
Git interpretiert den Zeitpunkt `<wann>` als absolutes oder relatives Datum und konsultiert dann das Reflog der entsprechenden Referenz, um herauszufinden, was der zeitlich nächste Log-Eintrag ist.
Dieser wird dann referenziert.
////

Commands that expect one or more references can also implicitly use Reflog.
In addition to the syntax already found in the output of `git log -g` (e.g. `HEAD@{1}` for the previous position of the HEAD), Git also understands `<ref>@{<when>}`.
Git interprets the time `<when>` as an absolute or relative date and then consults the reflog of the corresponding reference to find out what the next log entry in time is.
This is then referenced.


////
Zwei Beispiele:
////

Two examples:



[subs="quotes"]
--------
$ *git log 'master@{two weeks ago}..'*
$ *git show '@{1st of April, 2011}'*
--------




////
Das erste Kommando listet alle Commits zwischen `HEAD` und dem Commit auf, auf den der `master`-Branch vor zwei Wochen gezeigt hat (beachten Sie das Suffix `..`, was eine Commit-Range bis `HEAD` bedeutet).
Das muss nicht nötigerweise auch ein Commit sein, der zwei Wochen alt ist: Wenn Sie vor zwei Wochen testweise per `git reset --hard <initial-commit>` den Branch auf den allerersten Commit des Repositorys verschoben haben, dann wird genau dieser Commit referenziert.[53]
////

The first command lists all commits between `HEAD` and the commit the `master` branch pointed to two weeks ago (note the suffix `..` which means a commit range up to `HEAD`).
This doesn't necessarily have to be a commit that is two weeks old: if you test moved the branch to the very first commit in the repository two weeks ago using `git reset --hard <initial-commit>`, then that very commit will be referenced.{fn53}


////
Die zweite Zeile zeigt den Commit an, auf den der (wegen fehlender expliziter Referenz vor dem `@`) aktuell ausgecheckte Branch am 1. April 2011 gezeigt hat.
In beiden Kommandos muss das Argument mit Reflog-Anhang sinnvoll in Anführungszeichen eingefasst werden, damit Git das Argument komplett erhält.
////

The second line shows the commit to which the currently checked out branch (due to missing explicit reference before the `@`) pointed on April 1, 2011.
In both commands, the argument with a Reflog attachment must be enclosed in quotation marks to make sure Git gets the argument completely.


////
Beachten Sie, dass das Reflog _nur_ lokal vorliegt und somit nicht zum Repository gehört.
Wenn Sie einem anderen Entwickler eine Commit-ID oder einen Tag-Namen schicken, dann referenziert dies den gleichen Commit -- ein `master@{yesterday}` kann aber je nach Entwickler _verschiedene_ Commits referenzieren.
////

Note that the reflog is _only_ available locally and therefore does not belong to the repository.
If you send a commit ID or tag name to another developer, it references the same commit, but a `master@{yesterday}` can reference _different_ commits depending on the developer.


[TIP]
==================
////
Wenn Sie keinen Branch und keinen Zeitpunkt angeben, nimmt Git `HEAD` an.
Somit können Sie in Kommandos `@` als Kurzform für `HEAD` verwenden.
Weiterhin verstehen viele Kommandos das Argument `-` als `@{-1}`, also "`letzte Position des `HEAD``":
////

If you don't specify a branch and time, Git will assume `HEAD`.
This allows you to use `@` as the short form for `HEAD` in commands.
Furthermore, many commands understand the argument `-` as `@{-1}`, which is "`last position of `HEAD``":

// @TRANSLATE SIDE COMMENTS IN GIT COMMANDS
[subs="quotes"]
------
$ *git checkout feature*   # vorher auf "master"
$ *git commit ...*         # Änderungen, Commits machen
$ *git checkout -*         # zurück auf "master"
$ *git merge -*            # Merge von "feature"
------
==================

